博学之, 审问之, 慎思之, 明辨之, 笃行之;
壹、贰、叁、肆、伍、陆、柒、捌、玖、拾;



壹.模块导入和导出
    Node采用的是commonJS的规范, 一般将代码拆分到不同的JS文件中, 每一个文件就是一个模块, 文件路径就是模块名;
    在编写每个模块时, 都有require, exports, modules三个系统的变量可供使用, 
    核心模块(已封装好的内置模块);
    自定义的模块;
    第三方模块(npm下载下来的模块);

    require
        require函数用来在一个模块中引入另一个模块, 传入一个模块名, 返回一个模块导出对象, 模块名可用相对路径, 也可用绝对路径;
        作用一: 执行导入的模块中的代码;
        作用二: 返回导入模块中的接口对象;
    

    exports
        exports对象用来导出当前模块的公共方法和属性, 另个模块通过require使用当前模块时, 得到的就是当前模块的exports对象;


    module.exports
        module.exports用来导出一个默认对象, 没有指定对象名称, 常见于修改模块的原始导出对象;
        解释: module.exports导出整个对象,也可单个属性导出, 但export只能导出单个属, 不能导出整个对象;
        

    模块初始化:
        一个模块中的代码仅在模块第一次被使用时被执行一次; 并且在使用过程中进行初始化, 之后缓存起来便于后续继续使用;
        解释: 当require()导入时就会将exports中的代码执行一次, 如果同一个文件导入两次, 代码仍只会执行一次;
                


    第三方模块(npm下载下来的模块);
        require函数会优先查找node_modules中的包, 并不用输入node_modules的具体模块路径(太麻烦了);require会自动帮助查找;
        所以通过npm下载的 node_modules 模块只需要引入包名即可自动查到;

        如果在同级目录中没有node_modules目录, 会往上级父级一只查到这个node_modules目录;
        一直找到磁盘根目录, 如果没有node_modules目录; 就会报错;













贰.文件读取
    fs.readFileSync
        描述:       同步读取文件;
        参数:       fs.readFileSync(读取的文件, {flag: 模式, encodin: 编码模式})
        返回值:     返回 path 的内容
    fs.readFile
        描述:       异步读取文件;
        参数:       fs.readFileSync(读取的文件, {flag: 模式, encodin: 编码模式}, 回调函数);
        返回值:     返回 path 的内容(通过回调函数);










叁.文件写入
    新建write.js 用来操作 write.txt的写入;
        fs.writeFile('文件路径', '写入内容', {flag: 'a', encoding:'utf-8'}, callback(err)());
        文件路径不存在时, 就会自动创建这个文件;
        
        连续写入内容时, 因为是异步不造成后面的代码阻塞, 所以为了保证顺序, 需要用在回调中持续写入;
        这样会造成地狱回调, 所以还是需promise封装;

        
        promise封装以上步骤, 为了避免以上那样的地狱回调;
        function writefs(path, content){
            return new Promise(function (resolve, reject) {
                fs.writeFile(path, content, {flag: 'a', encoding: 'utf-8'}, function (err) {
                    if(err) {
                        reject(err);
                        throw Error(err);
                    }else{
                        resolve(err);
                        console.log('写入内容成功');
                    }
                })
            })    
        }

        通过async进行阻塞代码执行, 即可解决地狱回调;
        async function writeList() {
            await writefs('./write.txt', '今晚上吃什么\n');
            await writefs('./write.txt', '红烧狮子头把\n');
            await writefs('./write.txt', '今吃蒜茄子, 没算不行, 买去\n');
        }
        writeList();




    新建delete.js文件用来删除操作;
        fs.unlink(删除文件的路径, callback);
        谨慎操作, 删除之后, 无法恢复, 回收站找不到删除的文件;
        


    新建buffer.js文件;
        buffer: 数组的数据的二进制的存储, 效率很高,速度很快;
        1.数组不能进行二进制数据的操作;
        2.js数组不像java, python等语言效率高, js为了弥补这个缺点, 能够对二进制进行快速的数据操作, 提升数组性能, 就有了buffer;
        buffer绘制内存空间开辟出固定大小的内存; 

            var str = 'helloworld';
            把helloworld存放到buffer中;
            var buf = Buffer.from(str);
            console.log(buf);
            buf会将str以十六进制显示, 是因为二进制太长了;
            输出buffer内容;
            console.log(buf.toString());





            开辟buffer(缓存区), 之前版本是new Buffer();实例一个buffer, 现在已经废弃掉了, 使用Buffer.alloc(size);
            开辟一个buffer长度为20的buffer(缓冲区), 也可以说是(20个字节), 其实就是buf数组长度为20;
            let buf = Buffer.alloc(20);
            现在buffer就是一个数组, 所以: 可以操作每一位:
            buf[0] = 10;
            buf[1] = 15;
            console.log(buf);
            输出结果为:<Buffer 0a 0f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00>
            因为是十六进制, 所以10 == 0a, 15 == 0f, 16 == 10;

            buf[0] = 255;
            console.log(buf);
            输出为ff; 色码#ffffff转换就是(255,255,255); 其实255 == ff; 相对十六进制来说;
            buf[0] = 256;
            console.log(buf);
            输出为100, 但是显示00, 原因在于十六进制最多显示两位, 所以看不到1, 只能看到00;
            buf[0] = 356;
            console.log(buf);
            输出为ff;



            let buf = Buffer.allocUnsafe(20);
            Unsafe意在创建一个不会置空的buffer, 会遗留之前程序的内容, 所以不太安全, 但是不用每一位索引都置空, 所以会比alloc效率快一点;

            




















肆.输入输出;
    fs.readdir('文件路径', callback(err,files){});
    fs.rmdir('文件路径', callback);
    
    readline.createInterface({
        :process指终端进程, 固定写法, 这两个接口必须要指定;
        input:process.stdin,
        output:process.stdout
    })



    question事件: 输入内容;
    r1设置提问事件;
    r1.question('今晚吃什么', function (answer) {
        console.log(`答复${answer}`);
        r1.close();
    })
    绑定结束事件;
    r1.on('colse', function () {
        process.exit(0);
    });


    命令行会输出: 今晚吃什么: 后面跟着什么答复, 回答就是答复;
    如果没有 r1.close事件的process.exit(0) 这一步骤;
    进程将不会结束, 有procexx.exit(0)这一步时, 答复往后就会自动关闭;
















壹、贰、叁、肆、伍、陆、柒、捌、玖、拾;
伍.文件流;
    
