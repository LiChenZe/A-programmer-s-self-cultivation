博学之, 审问之, 慎思之, 明辨之, 笃行之;
壹、贰、叁、肆、伍、陆、柒、捌、玖、拾;







壹.css拓展功能;
    
    1.嵌套规则;

        Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如

            #main p {
                color: #00ff00;
                width: 97%;

                .redbox {
                    background-color: #ff0000;
                    color: #000000;
                }
            }

            编译为

            #main p {
                color: #00ff00;
                width: 97%; 
            }

            #main p .redbox {
                background-color: #ff0000;
                color: #000000; 
            }
    
        
    2.父选择器;

        在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定 hover 样式时，
        或者当 body 元素有某个 classname 时，可以用 & 代表嵌套规则外层的父选择器

            a {
                font-weight: bold;
                text-decoration: none;
                &:hover { text-decoration: underline; }
                body.firefox & { font-weight: normal; }
            }

            编译为
            
            #main {
                color: black; 
            }
            #main a {
                font-weight: bold; 
            }
            #main a:hover {
                color: red;
            }

        & 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，当父选择器含有不合适的后缀时，Sass 将会报错;

            #main {
                color: black;
                &-sidebar { border: 1px solid; }
            }

            编译为

            #main {
                color: black;
            }

            #main-sidebar {
                border: 1px solid; 
            }




    
    3.属性嵌套;

        有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。
        为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中;

            .funky {
                font: {
                    family: fantasy;
                    size: 30em;
                    weight: bold;
                }
            }

            编译为

            .funky {
                font-family: fantasy;
                font-size: 30em;
                font-weight: bold; 
            }


        命名空间也可以包含自己的属性值;

            .funky {
                font: 20px/24px {
                    family: fantasy;
                    weight: bold;
                }
            }
            编译为

            .funky {
                font: 20px/24px;
                font-family: fantasy;
                font-weight: bold; 
            }



    4.占位符选择器;

        Sass 额外提供了一种特殊类型的选择器：占位符选择器 (placeholder selector)。

        与常用的 id 与 class 选择器写法相似，只是 # 或 . 替换成了 %。必须通过 @extend 指令调用;

        当占位符选择器单独使用时（未通过 @extend 调用），不会编译到 CSS 文件中。

        





贰.注释 /* */ 与 //

    Sass 支持标准的 CSS 多行注释 /* */，以及单行注释 //，
    前者会 被完整输出到编译后的 CSS 文件中，而后者则不会

        /* This comment is
        * several lines long.
        * since it uses the CSS comment syntax,
        * it will appear in the CSS output. */
        body { color: black; }

        // These comments are only one line long each.
        // They won't appear in the CSS output,
        // since they use the single-line comment syntax.
        a { color: green; }
    
    
    将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。

    插值语句 (interpolation) 也可写进多行注释中输出变量值

        $version: "1.2.3";
        /* This CSS is generated by My Snazzy Framework version #{$version}. */

        编译为


        /* This CSS is generated by My Snazzy Framework version 1.2.3. */

    
    

叁.SassScript

    在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。
    通过 interpolation，SassScript 甚至可以生成选择器或属性名，这一点对编写 mixin 有很大帮助

    1.Interactive Shell;

        $ sass -i
        >> "Hello, Sassy World!"
        "Hello, Sassy World!"
        >> 1px + 1px + 1px
        3px
        >> #777 + #777
        #eeeeee
        >> #777 + #888
        white
    
        
    2.变量;
        SassScript 最普遍的用法就是变量，变量以美元符号开头，赋值方法与 CSS 属性的写法一样

            $width: 5em;
            
            直接使用即调用变量：

            #main {
            width: $width;
            }

        
        变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），
        不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明：

            #main {
                $width: 5em !global;
                width: $width;
            }

            #sidebar {
                width: $width;
            }

            编译为

            #main {
                width: 5em;
            }

            #sidebar {
                width: 5em;
            }
        
        

    3.数据类型

        SassScript 支持 6 种主要的数据类型：

            数字                        1, 2, 13, 10px
            字符串                      有引号字符串与无引号字符串，"foo", 'bar', baz
            颜色                        blue, #04a3f9, rgba(255,0,0,0.5)
            布尔型                      true, false
            空值                        null
            数组 (list)                 用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif
            maps,                       相当于 JavaScript 的 object，(key1: value1, key2: value2)
        

        字符串:
            SassScript 支持 CSS 的两种字符串类型：
            有引号字符串 (quoted strings)，  如 "Lucida Grande" 'http://sass-lang.com'；
            无引号字符串 (unquoted strings)，如 sans-serif bold，在编译 CSS 文件时不会改变其类型。
        
                @mixin firefox-message($selector) {
                    body.firefox #{$selector}:before {
                        content: "Hi, Firefox users!";
                    }
                }
                @include firefox-message(".header");

                编译为:
                
                body.firefox .header:before {
                    content: "Hi, Firefox users!"; 
                }

        运算:
            所有数据类型均支持相等运算 == 或 !=，此外，每种数据类型也有其各自支持的运算方式。
            SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值。
            关系运算 <, >, <=, >= 也可用于数字运算，相等运算 ==, != 可用于所有数据类型
            SassScript 支持布尔型的 and or 以及 not 运算。
            
            
        插值语句:
            通过 #{} 插值语句可以在选择器或属性名中使用变量：

                $name: foo;
                $attr: border;
                p.#{$name} {
                    #{$attr}-color: blue;
                }

                编译为

                p.foo {
                border-color: blue; }
            

    4.变量定义:
        可以在变量的结尾添加 !default 给一个未通过 !default 声明赋值的变量赋值，
        此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。
        
            $content: "First content";
            $content: "Second content?" !default;
            $new_content: "First time reference" !default;

            #main {
                content: $content;
                new-content: $new_content;
            }

            编译为

            #main {
                content: "First content";
                new-content: "First time reference";
            }
            
    
        变量是 null 空值时将视为未被 !default 赋值
            
            $content: null;
            $content: "Non-null content" !default;

            #main {
                content: $content;
            }
            
            编译为

            #main {
                content: "Non-null content";
            }
            
                
                    

肆.@-Rules 与指令 (@-Rules and Directives)

    Sass 支持所有的 CSS3 @-Rules，以及 Sass 特有的 “指令”（directives）
    
    1.@import
        Sass 拓展了 @import 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中
        另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用

            @import "foo.scss"

            或

            @import "foo";

        Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：

            @import "foo.scss", "bar.scss";
            
        
        不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套@import

        




    2.@media
        
        Sass 中 @media 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。
        如果 @media 嵌套在 CSS 规则内，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器。
        这个功能让 @media 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。


            .sidebar {
                width: 300px;
                @media screen and (orientation: landscape) {
                    width: 500px;
                }
            }

            编译为

            .sidebar {
                width: 300px; 
            }
            @media screen and (orientation: landscape) {
                .sidebar {
                    width: 500px;
                } 
            }

        @media 的 queries 允许互相嵌套使用，编译时，Sass 自动添加 and

            @media screen {
                .sidebar {
                    @media (orientation: landscape) {
                        width: 500px;
                    }
                }
            }
            编译为

            @media screen and (orientation: landscape) {
                .sidebar {
                    width: 500px; 
                } 
            }


        @media 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值

            $media: screen;
            $feature: min-width;
            $value: 1000px;

            @media #{$media} and ($feature: $value) {
                .sidebar {
                    width: 500px;
                }
            }

            编译为

            @media screen and (min-width: 1000px) {
                .sidebar {
                    width: 500px; 
                } 
            }


    3.@extend
        @extend 的作用是将重复使用的样式 (.error) 延伸 (extend) 给需要包含这个样式的特殊样式（.seriousError）
            .error {
                border: 1px #f00;
                background-color: #fdd;
            }
            .error.intrusion {
                background-image: url("/image/hacked.png");
            }
            .seriousError {
                @extend .error;
                border-width: 3px;
            }

            编译为:
            
            .error, .seriousError {
                border: 1px #f00;
                background-color: #fdd; 
            }

            .error.intrusion, .seriousError.intrusion {
                background-image: url("/image/hacked.png"); 
            }

            .seriousError {
                border-width: 3px;
            }

        
        Class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 .special.cool，a:hover 或者 a.user[href^="http://"] 等;

            .hoverlink {
                @extend a:hover;
            }
            a:hover {
                text-decoration: underline;
            }

            编译为:
            
            a:hover, .hoverlink {
                text-decoration: underline; 
            }
    

        

            .hoverlink {
                @extend a:hover;
            }
            .comment a.user:hover {
                font-weight: bold;
            }

            编译为:
            
            .comment a.user:hover, comment .user.hoverlink{
                font-weight: bold;
            }
    
    
        同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器

            .error {
                border: 1px #f00;
                background-color: #fdd;
            }
            .attention {
                font-size: 3em;
                background-color: #ff0;
            }
            .seriousError {
                @extend .error;
                @extend .attention;
                border-width: 3px;
            }
    
            编译为:

            .error, .seriousError {
                border: 1px #f00;
                background-color: #fdd;
            }

            .attention, .seriousError {
                font-size: 3em;
                background-color: #ff0;
            }

            .seriousError {
                border-width: 3px;
            }


        当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个

            .error {
                border: 1px #f00;
                background-color: #fdd;
            }
            .seriousError {
                @extend .error;
                border-width: 3px;
            }
            .criticalError {
                @extend .seriousError;
                position: fixed;
                top: 10%;
                bottom: 10%;
                left: 10%;
                right: 10%;
            }

            编译为:
            .error, .seriousError, .criticalError{
                border: 1px #f00;
                background-color: #fdd;
            }
            
            .seriousError, .criticalError {
                border-width: 3px;
            }
            
            .criticalError {
                @extend .seriousError;
                position: fixed;
                top: 10%;
                bottom: 10%;
                left: 10%;
                right: 10%;
            }

        



    4.@at-root
        指定和父级元素是同级的;
            .parent {
            ...
            @at-root {
                .child1 { ... }
                .child2 { ... }
            }
            .step-child { ... }
            }






伍.控制指令(Control Directives);
    
    SassScript 提供了一些基础的控制指令，比如在满足一定条件时引用样式，或者设定范围重复输出格式。
    控制指令是一种高级功能，日常编写过程中并不常用到，主要与混合指令 (mixin) 配合使用;

    1.@if, @ease, @ease if;
        当@if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码
            p {
                @if 1 + 1 == 2 { border: 1px solid; }
                @if 5 < 3 { border: 2px dotted; }
                @if null  { border: 3px double; }
            }

            编译为

            p {
                border: 1px solid;
            }
            
        @if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。如果 @if 声明失败，Sass 将逐条执行 @else if 声明，如果全部失败，最后执行 @else 声明

            $type: monster;
            p {
                @if $type == ocean {
                    color: blue;
                } @else if $type == matador {
                    color: red;
                } @else if $type == monster {
                    color: green;
                } @else {
                    color: black;
                }
            }

            输出为

            p {
                color: green;
            }
            
    
    2.@for
        @for 指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。
        这个指令包含两种格式：

            @for $var from <start> through <end>，或者 @for $var from <start> to <end>，

        区别在于 through 与 to 的含义：
            当使用 through 时，条件范围包含 <start> 与 <end> 的值，
            而使用 to 时条件范围只包含 <start> 的值不包含 <end> 的值。
            另外，$var 可以是任何变量，比如 $i；<start> 和 <end> 必须是整数值
            
        
        @for $i from 1 through 3 {
            .item-#{$i} { width: 2em * $i; }
        }


        
    3.@each
        @each 指令的格式是 $var in <list>, $var 可以是任何变量名，比如 $length 或者 $name，而 <list> 是一连串的值，也就是值列表

            @each $animal in puma, sea-slug, egret, salamander {
                .#{$animal}-icon {
                    background-image: url('/images/#{$animal}.png');
                }
            }

            编译为:

            .puma-icon {
                background-image: url('/images/puma.png');
            }
            .sea-slug-icon {
                background-image: url('/images/sea-slug.png');
            }
            .egret-icon {
                background-image: url('/images/egret.png');
            }
            .salamander-icon {
                background-image: url('/images/salamander.png');
            }
    

        @each指令还可以使用多个变量，如@each$var1，$var2..., 如果是列表，则子列表的每个元素都被分配给相应的变量
            @each $animal, $color, $cursor in (puma, black, default),(sea-slug, blue, pointer),(egret, white, move) {
                .#{$animal}-icon {
                    background-image: url('/images/#{$animal}.png');
                    border: 2px solid $color;
                    cursor: $cursor;
                }
            }

            编译为:
            
            .puma-icon {
                background-image: url('/images/puma.png');
                border: 2px solid black;
                cursor: default;
            }
            .sea-slug-icon {
                background-image: url('/images/sea-slug.png');
                border: 2px solid blue;
                cursor: pointer;
            }
            .egret-icon {
                background-image: url('/images/egret.png');
                border: 2px solid white;
                cursor: move;
            }
        
        由于映射被视为对的列表，因此多个赋值也可以与它们一起工作
            @each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) {
                #{$header} {
                    font-size: $size;
                }
            }

            编译为
            
            h1 {
                font-size: 2em;
            }
            h2 {
                font-size: 1.5em;
            }
            h3 {
                font-size: 1.2em;
            }

    4.@while
        @while 指令重复输出格式直到表达式返回结果为 false。这样可以实现比 @for 更复杂的循环，只是很少会用到
            $i: 6;
                @while $i > 0 {
                    .item-#{$i} { width: 2em * $i; }
                    $i: $i - 2;
                }

            输出为

            .item-6 {
                width: 12em;
            }

            .item-4 {
                width: 8em;
            }

            .item-2 {
                width: 4em;
            }
            
        

    
陆.混合指令 (Mixin Directives)
    混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 .float-left。
    混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式

        @mixin large-text {
            font: {
                family: Arial;
                size: 20px;
                weight: bold;
            }
            color: #ff0000;
        }

        
        
    
    

柒



捌



玖



拾





7. @-Rules 与指令
    1. @import
    1. 分音
    2. 嵌套 @import
    2. @media
    3. @extend
    1. How it Works
    2. 延伸复杂的选择器
    3. 多重延伸
    4. 继续延伸
    5. 选择器列
    1. 合并选择器列
    6. @extend-Only 选择器
    7. !optional 声明
    8. 在指令中延伸
    4. @at-root
    1. @at-root
    5. @debug
    6. @warn
    7. @warn



8. 控制指令
    1. if
    2. @if
    3. @for
    4. @each
    8.4.1 Multiple Assignment
    5. @while





9. 混合指令
    1. 定义混合指令 @mixin
    2. 引用混合样式 @include
    3. 参数
    1. 关键词参数
    2. 参数变量
    4. 向混合样式中导入内容
    1. Variable Scope and Content Blocks



10. 函数指令



11. 输出格式
    1. :nested
    2. :expanded
    3. :compact
    4. :compressed



12. 拓展 Sass

    1. 自定义 Sass 函数
    2. 存储缓存
    3. 自定义导入