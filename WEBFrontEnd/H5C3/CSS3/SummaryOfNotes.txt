博学之, 审问之, 慎思之, 明辨之, 笃行之;
壹、贰、叁、肆、伍、陆、柒、捌、玖、拾;





壹.样式组件设计与导入技巧
    
    @import url();
    在css文件中依赖其他的css文件(引入css文件);
    这样就可以更细的划分某个模块的css, 比如在页面中引入的文件之引入了一个css文件, 而这个css文件中依赖了很多的css文件(menu.css, head.css, foot.css, main.css等..);
    如果页面中的哪个部位出现了问题, 我们就直接找css依赖的对应的部位css文件进行修改, 这样安全性高,也很清晰结构, 一目了然;
    
贰.vscode添加less支持
    vscode下载插件 Easy Less;
    插件功能: 在书写less文件保存之后, 会在同级目录中自动生成一份同名的css文件, 内容由less自动生成为css文件;



    
叁.选择器原理和常用选择器
    
    通配符选择          *
    标签选择器          tagName
    群组选择器          tagName, tagName
    兄弟选择器          tagName~tagName(所有后面的兄弟元素);
    兄弟选择器          tagName+tagName(紧邻后面的兄弟元素);
    类选择器            .
    ID选择器            #(唯一值,一般不作用于样式);
    结构选择器          div p选择div中的所有p元素;
    子元素选择器        > 只选择子级元素;不会选择子级下的元素;
    属性选择器          div[title][id]  既有title又有id的div元素, div[title="titleValue"]   title="titleValue"的div元素;
                       div[title^='titleValue'] title的属性值是以titleValue开始的div元素,
                       div[title$='titleValue'] title的属性值是以titleValue结束的div元素,
                       div[title*='titleValue'] title的属性值中有titleValue内容的div元素,
                       div[title~='titleValue'] title的属性值中有titleValue内容并且是独立的单词的div元素,
    伪类选择器          :link   默认时的状态
                        :visited    访问过的状态
                        :acive      点击时的状态
                        :hover      划过时的状态
                        :focus      获取到焦点时
                        :target     当前活动锚点触发元素(点击URL时候包含锚的id名字元素)
                        :root       最顶级的选择器,根元素(html);
                        :empty      内容为空的元素
                        等等...     自信查阅文档    https://www.runoob.com/css/css-pseudo-classes.html#table13
                        结构伪类选择器:                     :first-child            选中第一个元素
                                                            :first-of-type          选中同类型中的第一个元素
                                                            :last-child             选中最后一个元素
                                                            :last-of-type           选中同类型中的最后一个元素
                                                            :only-child             选中唯一的元素
                                                            :only-of-type           选中同类型的唯一元素
                                                            :nth-child(2)           选中是第2个的元素
                                                            :nth-child(2n)          选中偶数行
                                                            :nth-child(odd)         选中偶数行
                                                            :nth-child(2n-1)        选中奇数行
                                                            :nth-child(even)        选中奇数行
                                                                这个n其实是一个变量(当前是第几个,n就是几), 2n就是2*n, 所以就是偶数, 2n-1就是奇数来实现奇数行和偶数行;
                                                            :nth-child(-n+2)        选中前两个元素
                                                            :nth-of-type(2)         选中同类型的第二个元素;
                                                            :nth-last-child(2)      选中倒数第二个的元素;
                                                            :nth-last-of-type(2)    选中同类型的倒数第二个元素;
                                                            :not(p)                 排除p元素
                                                                                
                        表单选择器                          :disabled   选择被禁用的表单元素
                                                            :enabled    选中可用的表单元素
                                                            :checked    选中被选择的元素(radio, checkbox)
                                                            :optional   选中非必填的表单元素
                                                            :required   选中必填的表单元素
                                                            :valid      选中当验证有效时的表单元素
                                                            :invalid    选中验证无效时的表单元素
                        文本伪类操作                        ::first-letter              选中每个段落的第一个字;
                                                            ::first-line                选中每个段落的第一行;
                                                            ::after                     在元素之后添加内容(配合content: '内容',这个属性);
                                                            ::before                    在元素之前添加内容(配合content: '内容',这个属性);
                                                            






肆.样式权重的计算
    权重排名:
        important   无限大(无建议使用, 会破坏css的规则);
        行内样式    1000,
        ID:         0100,
        class:      0010,
        tagName:    0001,
        *           0000,
        样式继承    null
        css中的样式继承是内有权重的, 所以*的权限大于继承(改掉之前的思想误区);


伍.字体文本样式和排版模式

    font-family 这个属性可以设置多个字体, 中间用逗号分隔, 如果用户电脑上没有一个而字体, 就会展示逗号之后的下一个字体;
    
    <!-- 自定义字体或者图标 -->
    @font-face{
        <!-- 定义字体名字 -->
        font-family: 'leechenze';
        <!-- 定义字体来源url()字体路径, 和format()字体格式; -->
        src: url("C:/Windows/Fonts/楷体 常规") format("opentype"),
            url('C:/Windows/Fonts/webdings.ttf') format("opentype");
    }
    

    font-famiy: 'Courier New', Courier, monospace;
    font-size: 40px;
    line-height: 1.5em;
    font-weight: bolder;
    font-style: italic;

    简写方式如下:(中间使用空格分开, size和family属性值必须要有, 否则全不会生效), 然后行高加载字体大小后面使用/分割;
    
    font: bold italic 45px/1.5em 'Courier New', Courier, monospace;
    先后循序为(weight, style, size/lineHeight, family);
    


    text-transform: capitalize;                 文本的首字母大写;
    text-transform: lowercase;                  文本设置小写
    text-transform: uppercase;                  文本设置大写


    text-decoration: underline;                 添加下划线
    text-decoration: overline;                  添加上划线
    text-decoracion: line-through;              添加中划线
    text-decoration: none;                      删除线条样式
    

    text-shadow: #ddd 5px 5px 5px;              颜色, x轴偏移, y轴偏移, 模糊值;
    text-overflow: ellipsis;                    文本溢出显示省略号
    text-indent: 2em;                           首行文本缩进
    text-align: center;                         文本的对齐方式;
    vertical-align: 10px;                       内联元素的垂直对齐方式;

    white-space: pre;                           空白处理, 可以保留标签之前的空格, 等同于pre标签的功能;
    white-space: pre-wrap;                      空白处理, 保留空白和换行;
    white-space: pre-line;                      空白处理, 删除空白但保留换行;
    white-space: nowrap;                        空白处理, 空白处强制不换行
    

    letter-spacing: 2px;                        字符之间的间隔;
    word-spacing: 2px;                          单词之间的间隔;
    

    writing-mode: horizontal-tb;                排版模式: 水平排列(默认模式);
    writing-mode: vertical-rl;                  垂直排列(从右到左排列);
    writing-mode: vertical-lr;                  垂直排列(从左到右排列);
    
    
    




陆.尺寸使用规范和盒模型
    
    <!-- 盒模型: -->
    <article>
        <div>leechenze.com</div>
    </article>
    两个元素之间如果都有margin, 会涉及到边距合并, 也就是这两个元素之间的margin只会取一个, margin值比较大的元素来进行覆盖另一个margin值小的元素,
    也就是说俩元素之间margin值小的会被覆盖;

    


    border-style: double;               定义边框样式为双线;
                    none	            定义无边框。
                    dotted	            定义点状边框。在大多数浏览器中呈现为实线。
                    dashed	            定义虚线。在大多数浏览器中呈现为实线。
                    solid	            定义实线。
                    double	            定义双线。双线的宽度等于 border-width 的值。
                    groove	            定义 3D 凹槽边框。其效果取决于 border-color 的值。
                    ridge	            定义 3D 垄状边框。其效果取决于 border-color 的值。
                    inset	            定义 3D inset 边框。其效果取决于 border-color 的值。
                    outset	            定义 3D outset 边框。其效果取决于 border-color 的值。
    
    border-top-style:double;            定义顶部边框样式;
    
    border-width:10px;                  定义边框宽度;

    border-color: red;                  定义边框颜色;
    
    border-radius: 30px 30px 30px 30px; 定义边框角度:参数为(上右下左), 也可以设置百分比,50%就是一个圆形;
    
    border-top-left-radius              定义边框左上角
    border-top-right-radius             定义边框右上角
    border-bottom-left-radius           定义边框左下角
    border-bottom-right-radius          定义边框右下角
    
    border-spacing: 30px;               定义边框边距
    border-collapse: collapse;          合并边框(两个紧挨着的元素的边框合并为一个边框);
    
    
    outline-style: double;              定义轮廓样式;
    outline-width: 10px;                定义轮廓宽度;
    outline-color: red;                 定义轮廓颜色;
    outline: 1px solid #000;            轮廓线的简写形式;
    

    display: none;                      隐藏元素(隐藏元素空间位);
    display: block;                     设置元素为块级元素;
    display: inline-block;              设置元素为内联块元素(内联块元素可以设置宽高, 但是不会独占一行);
    display: inline;                    设置元素为内联元素;
    diaplay: flex;                      定义弹性盒;
    

    visibility: hidden;                 隐藏元素(不隐藏元素空间位);
    visibility: visible;                显示元素(显示元素);
    opacity: 0;                         设置元素的透明度为0, 取值为0-1, 0为透明, 1为不透明;
    

    overflow: scroll;                   溢出显示滚动条;
    overflow: hidden;                   溢出内容隐藏;
    

    min-width: 10%;                     定义最小宽度
    max-width: 10%;                     定义最大宽度
    
    width: -webkit-fill-available;      定义宽度填充可用空间;
    height: -weikit-fill-available;     定义高度填充可用空间;
    width: fit-content;                 定义元素宽度根据内容占据;
    height: fit-content;                定义元素高度根据内容占据;
    width: min-content;                 自适应内部元素为最小的内容区域
    width: max-content;                 自适应内部元素为最大的内容区域
    
    
    
    
    
    
    
    
    
    
    
柒.元素背景属性的使用
    
    background-color: rgba();                 定义背景颜色

    background-image: url(路径),url(路径);      定义背景图片(可以定义多个, 使用逗号分割, 定义多个时候, 其他设置也一样, 使用逗号来分割);
    
    background-clip: content-box;               规定内容区域背景;
    background-clip: padding-box;               规定content和padding区域背景;
    background-clip: border-box;                规定content, padding, border区域背景;
    
    background-repeat: no-repeat;               规定背景图片不重复;
    background-repeat: space;                   规定重复的背景图平均分布;
    
    background-attachment: fixed;               背景图固定在元素上;
    background-attachment: scroll;              背景图跟随元素滚动;
    
    background-position: center;                设置背景图片居中;
    background-position: 50% 50%;               设置背景图片居中(也可以以数值的方式进行设置);
    
    background-size: 100px auto;               设置背景图的大小, 后面的auto意为: 根据图片大小定义,设置宽度, 高度自动, 防止图片变形;
    background-size: contain;                   保证图片会完全显示;
    
    background: red url(src) no-repeat center   background多个属性的缩写形式, 参数依次为: color, image, repeat, position;
    

    box-shadow: 10px 10px 10px rgba(100, 100, 100, 1);
    规定盒子阴影, 参数分别为:  x轴方向, y轴方向, 模糊度, 阴影颜色;
    
    background: linear-gradient(45deg, red 50%, green 30%, blue 20%);
    background: linear-gradient(to top left, red 50%, green 30%, blue 20%);
    设置背景线性渐变色, linear-gradient的参数依次为: 渐变方向, 渐变色1, 渐变色2, 渐变色3;
    他们之间的参数由于逗号分割, 参数中还有多位, 就使用空格分割
    参数渐变色1,2,3 后面的50%, 30%, 20%分别是标识位, 表示每个颜色所占的面积比, 如果都是33.3%时候, 就没有渐变的效果了
    也就是说这三个标识位不把100占满了就会有渐变的效果;
    同理渐变色参数如果有两个的话, 每个是50%, 也不会有渐变效果;

    background: linear-gradient(45deg, red, 30% green, 70% blue);
    中间的这个百分比这个参数是: 中间阈值, 和标识位不同, 阈值是一个独立的参数, 阈值只写在两个渐变色参数之间
    表示的是: 头一个渐变色和后一个渐变色中间的临界值;
    
    background: radial-gradient(100px 100px, red 50%, green 30%, blue 20%);
    background: radial-gradient(at top left, red 50%, green 30%, blue 20%);
    background: radial-gradient(at 50% 50%, red 50%, green 30%, blue 20%);
    设置别进圆角渐变色, radial-gradient的参数依次为: 渐变方向, 渐变色1, 渐变色2, 渐变色3;
    
    background: repeating-linear-gradient(90deg, black 15px, red 30px);
    重复线性渐变, 参数和linear-gradient相同;
    
    background: repeating-radial-gradient(100px 100px, black, red 15px);
    重复圆角渐变, 参数和radial-gradient相同;
    
    


捌.数据表格设计与表格定义
    display: table;                 定义为块级表格元素;
            table-row-group	        此元素会作为一个或多个行的分组来显示（类似 <tbody>）。
            table-header-group	    此元素会作为一个或多个行的分组来显示（类似 <thead>）。
            table-footer-group	    此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。
            table-row	            此元素会作为一个表格行显示（类似 <tr>）。
            table-column	        此元素会作为一个单元格列显示（类似 <col>）
            table-cell	            此元素会作为一个表格单元格显示（类似 <td> 和 <th>）
            table-caption	        此元素会作为一个表格标题显示（类似 <caption>）
    caption-size: top;              定义标题位置;

    
    table标签下对于td,th的样式属性: 
        empty-cells: hide;                  隐藏没有内容的(空的)单元格;
    

    list-style-type: lower-roman;           设置列表样式为小写的罗马符,
    list-style-image: url(src);             设置列表样式为背景图片;
    list-style-image: linear-gradient();    设置列表样式为镜像渐变;
    list-style-image: radial-gradient();    设置列表样式为镜像圆角渐变;
    

    div::after                                 之后追加属性;
        content: "内容"                              content这个属性用来定义向前添加的内容;
        content: attr(data-link)                    attr()这个方法就是用来读取标签上的属性, 也可以读取自定义属性(data-link), 会读取这个元素(div)属性的值作为内容;
    div::before                                之前追加属性;
    







玖.布局方式和BFC

    浮动元素会脱离文档流对后面元素产生影响, 被浮动的元素不在占据原有的位置;
    文档流定义的块级元素进行进行竖着流动(排列), 行元素横着流动(排列);
    
    如果一个元素使用了浮动, 他会对后面的元素有影响, 而不会影响到前面的元素;
    行内元素在脱离文档流后可以设置宽高;
    


    清除浮动
        clear: left;                    清除左边浮动;
        clear: right;                   清除右边浮动;
        clear: both;                    清除两边浮动;
    
    
    第二种方式
        清除浮动clearfix(clearOne)
        这种方法也很好理解, 在浮动元素之后添加一个元素清除左右浮动, 父元素不能检测到浮动元素的宽高, 但是可以检测到添加清除浮动的元素的宽高;
    
    
    第三种方式
        使用after伪类, 在元素之后添加一个空的内容的元素(content: "";), 然后清除浮动: clear: both; 最后:设置display: bolck;或者display: table;
        和第二种方式其实是一样的, 只不过是使用after伪类添加了这个元素而已;


    第四种方式
        在父元素添加overflow: hidden, 即可清除浮动;
        使用overflow: hidden;或者overflow: scroll;或者overflow: auto;都是可以清除浮动的;
        原理: 使用overflow来触发BFC机制; BFC机制会使父级元素在计算高度时, 仍然不会忽视里面的浮动元素的浮动空间(元素原有占位), 这样即可达到了清除浮动的效果;
        使用overflow方法处理是兼容时, 应该是height: auto; overflow: hidden;
    
    
    
    环绕距离控制
    shape-ouside: border-box;                   定义文本碍着元素的边框;
                    margin-box;                 定义文本碍着元素的margin;
                    padding-box;                定义文本碍着元素的padding;
                    content-box;                定义文本碍着元素的content;
                    url();                      定义图片路径, 文本可以根据图片进行环绕, 但是图片必须是png格式的透明状态才可以, jpg或jpeg是不生效的;             

    定义元素形状
        clip-path: circle(50% at 50% 50%);              定义圆形, 参数为(大小 at 圆心x轴位置 圆心y轴位置);
        clip-path: ellipse(50% 50%);                    定义椭圆, 参数为(以x轴宽度的圆形 以y轴为高度的圆形)
        clip-path: polygon(x y, x y, x y, x y, x y)     定义多边形, 参数为(x y, x y, x y, x y, x y);
    
    定义文本根据元素形状环绕
        clip-path: circle(50% at 50% 50%)               定义元素形状为圆形;
        shape-ouside: circle(50% at 50% 50%);           定义文本环绕方式是根据元素形状环绕;
            需要注意: 为了保证环绕效果, clip-path和shape-outside必须是作用在同一个元素上, 且两个属性的值必须相同才会生效;

    










    

拾.元素定位方式
    
    position: relative:                 相对定位;
        元素相对定位之后会保留原来的位置;
        相对于文档
    position: absolute;                 绝对定位;
        元素绝对定位之后不会保留原来的位置;
        绝对定位, 默认相对于浏览器视口(文档)进行定位, 但是如果某一个祖先元素有定位属性(不包含为static的定位值), 则会根据最近的有定位属性的这个祖先元素进行定位(就近原则);
        使用定位设置尺寸大小, 当一个元素有固定狂傲时, 设置了left, 在设置right多少都是无效的; 但是如果不设固定宽高就会同时实现left值和right值;以此来设置宽高尺寸;
        absolute会根据超出高度的父元素中的内容进行滚动;
    position: fixed;                    固定定位;
        固定定位参考的是页面, 不根据任何有定位属性的父级元素;
    position: sticky;
    粘性定位, 结合relative和fixed两种功能为一体的特殊定位
    释义: 元素先按照普通文档流定位, 然后相对于flow root(BFC) 和 containing block(最近的祖先块级元素)进行定位;
    然后元素定位表现在, 在跨越特定阈值之前表现为相对定位, 超出这个阈值范围则为固定定位;
    这个阈值指的就是sticky定位元素的left, right, top, bottom值;
    也就是, sticky的定位元素在指定left,right, top,bottom这些值时,才会生效;
    z-index: 1;                         定位元素的层级覆盖(值越大则权限越高);


















拾壹.珊格系统布局结构

        父级属性:
            
            display: grid;                      声明珊格容器
            grid-template-cloumns: 50% 50%;     声明珊格布局纵轴排列方式;
            grid-template-rows: 50% 50%;        声明珊格布局横轴排列方式;
            grid-template-rows: repeat(2, 50%); 等同于grid-template-cloumns: 50% 50%;
                绘制两行, 每行占比50%;
            grid-template-rows: repeat(2, 100px 50px); 
                绘制两行, 第一行为100px, 第二行为50px;
            grid-template-rows: repeat(auto-fill,100px);
                每一行为100px, 剩余部分自动填充;
            grid-template-rows: repeat(3,1fr);
                绘制三行, 每一行等位等比占用, 1fr有点类似于弹性盒中的flex: 1;的意思;
            grid-template-rows: 1fr 2fr 3fr;
                绘制三行, 第一行占比1份, 第二行占两份, 第三行占三份;
            grid-template-rows: repeat(2, minmax(50, 100px));
                绘制两行, 每一行的最小值为50px, 最大值为100px;
            grid-row-gap: 10px;                 简写为: row-gap;
                每行的间距为10px;
            grid-columns-gap: 10px;             简写为: columns-gap;
                每列的间距为10px;
            gap: 10px 10px;                     行间距为10px, 列间距为10px, 如果只有一个值则表示行和列都有10px的间距;
            
        
        子级属性:
            grid-row-start: ;                   选中横轴开始珊格线编号
            grid-row-end: ;                     选中横轴结束珊格线编号;
            grid-columns-start: ;               选中纵轴开始珊格线编号;
            grid-columns-end: ;                 选中纵轴结束珊格先编号;
            

            grid-template-rows: [r1-start] 100px [r1-end r2-start] 100px [r2-end r3-start] 100px [r3-end];
            grid-template-columns: [c1-start] 100px [c1-end c2-start] 100px [c2-end c3-start] 100px [c3-end];
            grid-columns-start: 命名名称;        也可使用命名名称来规定线的位置, 这个名称在grid-template-rows中的值之间用[]进行声明;

            以上的方式太过麻烦, 还有以下的形式:
            
            grid-template-rows: repeat(3, [r-start] 1fr [r-end]);
            grid-template-columns: repeat(3, [c-start] 1fr [c-end]);
            grid-column-start: 命名名称;           这种方式和上面的方式无异, 只不过是grid-template-rows: repeat(3, [r-start] 1fr [r-end])的改变;
            

            加行span的思维方式就应该是以珊格为基准而不是以珊格线为基准;

            grid-column-start: span 2;              横轴第一个珊格偏移两格;     
            grid-rows-start:span 2;                 纵轴第一个珊格偏移两格;

            grid-direction-start/end, 的简写形式如下:

            grid-row: start/end;                     
            grid-column: start/end;                          
            如果设置偏移量如下: 
            grid-row: start/span 3;                 等同于以下写法;    
                grid-row-start: start;
                grid-row-end: span 3;
            grid-column: start/span 3;              等同于以下写法;        
                grid-column-start: start;
                grid-column-end: span 3;


        以上方式都是通过珊格线进行定位, 以下使用珊格区域进行定位;

            
            
        父级元素:
            规定珊格布局的区域
            grid-template-areas: "header header" "nav main" "footer footer";
            grid-remplate-areas: '. .' '. .' 'footer footer';
                如果之前的两个不想是一体的话, 可以使用. .来进行占位; 占位是必须的, 否则就是给上面header和nav和main命名
                而不是给footer命名了, 给每个部位进行命名就是就是给他们划分区域而变成一组, 如果变成一组则必须命名而不能占位了;
                
                
                

        
        子级元素:
            grid-area: row-start/column-start/row-end/column-end;           
            grid-area: header;                      根据父级的grid-template-areas的值进行子元素的区域划分;
                那么如.xiaomiLayout的例子, 分为四块(header, nav, main, footer);
                每一块的系统都会默认对每一块珊格线进行命名, 这里用header为例:
                header的水平上边线      ==>         header-start
                header的垂直左边线      ==>         header-start
                header的水平下边线      ==>         header-end
                header的垂直右边线      ==>         header-end

                所以当对子元素进行珊格定位时可以:
                grid-area: header-start/header-start/header-end/header-end
                这里只是用header为例子, 当定位时肯定用其他元素进行定位:main-start或footer-start或nav-start等等;
            
        
        排列方向, 对齐方式,
            父级元素:
                grid-auto-flow: row;                规定布局流动方向为横向;
                grid-auto-flow: column;             规定布局流动方向为纵向;
                grid-auto-flow: dense;              强制填满布局中的预留空白区域;
                grid-auto-flow: row dense;          强制填满布局中的预留空白区域,并且为横向流动的布局;
                
                justify-content: space-between;     规定珊格横轴排列方式
                justify-content: space-around;
                justify-content: space-evenly;
                justify-content: start;
                justify-content: end;
                justify-content: center;
                
                align-content: space-between;       规定珊格纵轴排列方式;
                align-content: space-around;
                align-content: space-evenly;
                align-content: start;
                align-content: end;
                align-content: center;

                分清楚一点不论是弹性布局还是珊格布局, items和content区别在于前者是控制盒子内的子元素的属性, content是控制盒子本身的属性;
                
                justify-items: stretch;             规定珊格横轴子元素的排列方式;默认值, 拉抻;注意如果子元素设置了固定宽高,那么justify-items属性将不会生效,
                justify-items: start;
                justify-items: end;
                justify-items: center;
                justify-items: space-around;
                justify-items: space-evenly;
                justify-items: space-between;

                align-items: stretch;               规定珊格纵轴子元素的排列方式;默认值, 拉抻;注意如果子元素设置了固定宽高,那么align-items属性将不会生效;
                align-items: start;
                align-items: end;
                align-items: center;
                align-items: space-around;
                align-items: space-evenly;
                align-items: space-between;
                
                place-items: justify align;         为justity-items和align-items的简写方式;
                place-content: justify align;       为justify-content和align-content的简写方式;

            子级元素:

                justify-self: stretch;             规定珊格横轴子元素的排列方式;默认值, 拉抻;
                justify-self: start;
                justify-self: end;
                justify-self: center;

                align-self: stretch;               规定珊格纵轴子元素的排列方式;默认值, 拉抻;
                align-self: start;
                align-self: end;
                align-self: center;

                place-self: justify align;       为justify-self和align-self的简写方式;












拾贰.transform转换二维三维;
    
    transform:
            转换属性是针对块级元素, 行内元素不生效就转换为块级元素;

            transform-style: flat;                                              定义所有子元素是在2d平面呈现;
            transform-style: preserve-3d;                                       定义所有子元素是在3d空间呈现;
            transform-origin: x y z;                                            定义元素的基点位置, 多用于rotate,scale等...
                                                                                左边值:[left center right 0-999..%]
                                                                                右边值:[top center bottom 0-999..%]
                                                                                数值是百分比 0 - 99999% 无限大;
                            

            translate
                transform: translateX(50px);                                    规定横轴偏移可以是px也可是%, 正数向后偏移,负数向前偏移;
                transform: translateY(50px);                                    规定纵轴偏移可以是px也可是%, 正数向后偏移,负数向前偏移;
                transform: translateZ(50x);                                     规定Z轴偏移必须是px像素值, 因为Z轴设置百分比是没有参考的, 从平面穿过可以无限延伸
                                                                                所以不像是X,Y轴可以设置百分比,X,Y轴都是可以设置固定值的,Z轴则不然;
                transform: translateY(50px) translateY(50px);                   同时可以应用多个属性值;
                transform: translate(50px 50px);                                以上的简写方式;

                transform: translateY(50%) translateY(50%) translateZ(50px);    同时可以应用多个属性值;
                transform: translate3d(50%, 50%, 50px);                         以上的简写方式: 这是X轴,Y轴,Z轴的简写,translate3d;
            

            scale 
                transform: scaleX(2);                                           横轴放大两倍;
                transform: scaleY(2);                                           纵轴放大两倍;
                transform: scaleZ(1);                                           Z轴拉长或变短(放大或缩小);
                transform: scale(x, y);
                transform: scale3d(x, y, z);                           

            

            rotate
                transform: rotateX(45deg);                                      横轴旋转45deg;
                transform: rotateY(45deg);                                      纵轴旋转45deg;
                transform: rotateZ(90deg);                                      Z轴旋转90deg;
                transform: rotate3d(x, y, z, deg);                              旋转的3d参数不同, 四个参数前三个分别是轴向,最后一个是角度,
                                                                                比如transform: rotate3d(1, 1, 1, 90deg);
                                                                                并且注意xyz轴向添的不是具体值而是比例值;
                注意:
                    transform: rotateX(45deg) rotateY(45deg);
                    transform: rotateY(45deg) rotateX(45deg);
                    先操作横轴,还是先操作纵轴结果是不同的;可以思考一下,先旋转横轴就是在横轴的基础上旋转Y轴;
                    先旋转Y轴就是在原来的基础上操作Y轴所以结果肯定不同;
                    
                
            skew
                transform: skewX(deg);                                          横轴倾斜角度
                transform: skewY(deg);                                          纵轴倾斜角度
                transform: skew(xdeg, ydeg);                                    
                
                注意: 
                    transform: skewX(-45deg) skewY(45deg);
                    transform: skew(-45deg, 45deg);
                    结果是不同的, 思考一下, 第一中是分为两步横轴倾斜-45deg的基础上再倾斜纵轴的45deg;
                    第二部则是X和Y轴同时进行,倾斜操纵;
                    目前skew倾斜属性没有Z轴的操作,  所以只有这两个参数;

            
            
            
            透视    
            perspective
                子元素上加: 
                    transfrom: perspective(500px);

                    给子元素单个设置, 可以每一个设置不同的值, 展示效果不同;
                    
                父元素上加:
                    perspective: 500px;

                    给所有子元素整体设置, 每一个设置的值都是相同的, 展示效果都相同;
                    如果给父元素添加transfrom: perspective(500px), 子元素是不会透视的;
                    
            三维空间:
                transfrom-style: preserve-3d;
                透视可以呈现的是元素的积淀, 但是没办法呈现三位空间, 所谓三位空间就是有Z轴参与的空间;
                所以如果操作元素的Z轴就必须添加这个三位的属性, 否则三维的效果是不会呈现的; 只会呈现X轴和y轴的二维效果;
                

            
            perspective-origin: left top;
                详见:main.perspective-origin;
                解释为平时c3动画都是操作物体在呈现动画, 这个属性则是规定物体不变, 人的视角改变;
                好比汽车之家的 旋转的车模型, 360deg旋转车来展现给我们, 这个属性则代表车不转了, 人围绕车转360deg看车是类似的;
                
            
            backface-visibility: hidden;
                属性定义当元素不正面向屏幕时是否可见;
            
