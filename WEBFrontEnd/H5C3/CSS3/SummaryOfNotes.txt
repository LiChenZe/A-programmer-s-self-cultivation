博学之, 审问之, 慎思之, 明辨之, 笃行之;
壹、贰、叁、肆、伍、陆、柒、捌、玖、拾;





壹.样式组件设计与导入技巧
    
    @import url();
    在css文件中依赖其他的css文件(引入css文件);
    这样就可以更细的划分某个模块的css, 比如在页面中引入的文件之引入了一个css文件, 而这个css文件中依赖了很多的css文件(menu.css, head.css, foot.css, main.css等..);
    如果页面中的哪个部位出现了问题, 我们就直接找css依赖的对应的部位css文件进行修改, 这样安全性高,也很清晰结构, 一目了然;
    
贰.vscode添加less支持
    vscode下载插件 Easy Less;
    插件功能: 在书写less文件保存之后, 会在同级目录中自动生成一份同名的css文件, 内容由less自动生成为css文件;



    
叁.选择器原理和常用选择器
    
    通配符选择          *
    标签选择器          tagName
    群组选择器          tagName, tagName
    兄弟选择器          tagName~tagName(所有后面的兄弟元素);
    兄弟选择器          tagName+tagName(紧邻后面的兄弟元素);
    类选择器            .
    ID选择器            #(唯一值,一般不作用于样式);
    结构选择器          div p选择div中的所有p元素;
    子元素选择器        > 只选择子级元素;不会选择子级下的元素;
    属性选择器          div[title][id]  既有title又有id的div元素, div[title="titleValue"]   title="titleValue"的div元素;
                       div[title^='titleValue'] title的属性值是以titleValue开始的div元素,
                       div[title$='titleValue'] title的属性值是以titleValue结束的div元素,
                       div[title*='titleValue'] title的属性值中有titleValue内容的div元素,
                       div[title~='titleValue'] title的属性值中有titleValue内容并且是独立的单词的div元素,
    伪类选择器          :link   默认时的状态
                        :visited    访问过的状态
                        :acive      点击时的状态
                        :hover      划过时的状态
                        :focus      获取到焦点时
                        :target     当前活动锚点触发元素(点击URL时候包含锚的id名字元素)
                        :root       最顶级的选择器,根元素(html);
                        :empty      内容为空的元素
                        等等...     自信查阅文档    https://www.runoob.com/css/css-pseudo-classes.html#table13
                        结构伪类选择器:                     :first-child            选中第一个元素
                                                            :first-of-type          选中同类型中的第一个元素
                                                            :last-child             选中最后一个元素
                                                            :last-of-type           选中同类型中的最后一个元素
                                                            :only-child             选中唯一的元素
                                                            :only-of-type           选中同类型的唯一元素
                                                            :nth-child(2)           选中是第2个的元素
                                                            :nth-child(2n)          选中偶数行
                                                            :nth-child(odd)         选中偶数行
                                                            :nth-child(2n-1)        选中奇数行
                                                            :nth-child(even)        选中奇数行
                                                                这个n其实是一个变量(当前是第几个,n就是几), 2n就是2*n, 所以就是偶数, 2n-1就是奇数来实现奇数行和偶数行;
                                                            :nth-child(-n+2)        选中前两个元素
                                                            :nth-of-type(2)         选中同类型的第二个元素;
                                                            :nth-last-child(2)      选中倒数第二个的元素;
                                                            :nth-last-of-type(2)    选中同类型的倒数第二个元素;
                                                            :not(p)                 排除p元素
                                                                                
                        表单选择器                          :disabled   选择被禁用的表单元素
                                                            :enabled    选中可用的表单元素
                                                            :checked    选中被选择的元素(radio, checkbox)
                                                            :optional   选中非必填的表单元素
                                                            :required   选中必填的表单元素
                                                            :valid      选中当验证有效时的表单元素
                                                            :invalid    选中验证无效时的表单元素
                        文本伪类操作                        ::first-letter              选中每个段落的第一个字;
                                                            ::first-line                选中每个段落的第一行;
                                                            ::after                     在元素之后添加内容(配合content: '内容',这个属性);
                                                            ::before                    在元素之前添加内容(配合content: '内容',这个属性);
                                                            






肆.样式权重的计算
    权重排名:
        important   无限大(无建议使用, 会破坏css的规则);
        行内样式    1000,
        ID:         0100,
        class:      0010,
        tagName:    0001,
        *           0000,
        样式继承    null
        css中的样式继承是内有权重的, 所以*的权限大于继承(改掉之前的思想误区);


伍.字体文本样式和排版模式

    font-family 这个属性可以设置多个字体, 中间用逗号分隔, 如果用户电脑上没有一个而字体, 就会展示逗号之后的下一个字体;
    
    <!-- 自定义字体或者图标 -->
    @font-face{
        <!-- 定义字体名字 -->
        font-family: 'leechenze';
        <!-- 定义字体来源url()字体路径, 和format()字体格式; -->
        src: url("C:/Windows/Fonts/楷体 常规") format("opentype"),
            url('C:/Windows/Fonts/webdings.ttf') format("opentype");
    }
    

    font-famiy: 'Courier New', Courier, monospace;
    font-size: 40px;
    line-height: 1.5em;
    font-weight: bolder;
    font-style: italic;

    简写方式如下:(中间使用空格分开, size和family属性值必须要有, 否则全不会生效), 然后行高加载字体大小后面使用/分割;
    
    font: bold italic 45px/1.5em 'Courier New', Courier, monospace;
    先后循序为(weight, style, size/lineHeight, family);
    


    text-transform: capitalize;                 文本的首字母大写;
    text-transform: lowercase;                  文本设置小写
    text-transform: uppercase;                  文本设置大写


    text-decoration: underline;                 添加下划线
    text-decoration: overline;                  添加上划线
    text-decoracion: line-through;              添加中划线
    text-decoration: none;                      删除线条样式
    

    text-shadow: #ddd 5px 5px 5px;              颜色, x轴偏移, y轴偏移, 模糊值;
    text-overflow: ellipsis;                    文本溢出显示省略号
    text-indent: 2em;                           首行文本缩进
    text-align: center;                         文本的对齐方式;
    vertical-align: 10px;                       内联元素的垂直对齐方式;

    white-space: pre;                           空白处理, 可以保留标签之前的空格, 等同于pre标签的功能;
    white-space: pre-wrap;                      空白处理, 保留空白和换行;
    white-space: pre-line;                      空白处理, 删除空白但保留换行;
    white-space: nowrap;                        空白处理, 空白处强制不换行
    

    letter-spacing: 2px;                        字符之间的间隔;
    word-spacing: 2px;                          单词之间的间隔;
    

    writing-mode: horizontal-tb;                排版模式: 水平排列(默认模式);
    writing-mode: vertical-rl;                  垂直排列(从右到左排列);
    writing-mode: vertical-lr;                  垂直排列(从左到右排列);
    
    
    




陆.尺寸使用规范和盒模型
    
    <!-- 盒模型: -->
    <article>
        <div>leechenze.com</div>
    </article>
    两个元素之间如果都有margin, 会涉及到边距合并, 也就是这两个元素之间的margin只会取一个, margin值比较大的元素来进行覆盖另一个margin值小的元素,
    也就是说俩元素之间margin值小的会被覆盖;

    


    border-style: double;               定义边框样式为双线;
                    none	            定义无边框。
                    dotted	            定义点状边框。在大多数浏览器中呈现为实线。
                    dashed	            定义虚线。在大多数浏览器中呈现为实线。
                    solid	            定义实线。
                    double	            定义双线。双线的宽度等于 border-width 的值。
                    groove	            定义 3D 凹槽边框。其效果取决于 border-color 的值。
                    ridge	            定义 3D 垄状边框。其效果取决于 border-color 的值。
                    inset	            定义 3D inset 边框。其效果取决于 border-color 的值。
                    outset	            定义 3D outset 边框。其效果取决于 border-color 的值。
    
    border-top-style:double;            定义顶部边框样式;
    
    border-width:10px;                  定义边框宽度;

    border-color: red;                  定义边框颜色;
    
    border-radius: 30px 30px 30px 30px; 定义边框角度:参数为(上右下左), 也可以设置百分比,50%就是一个圆形;
    
    border-top-left-radius              定义边框左上角
    border-top-right-radius             定义边框右上角
    border-bottom-left-radius           定义边框左下角
    border-bottom-right-radius          定义边框右下角
    
    border-spacing: 30px;               定义边框边距
    border-collapse: collapse;          合并边框(两个紧挨着的元素的边框合并为一个边框);
    
    
    outline-style: double;              定义轮廓样式;
    outline-width: 10px;                定义轮廓宽度;
    outline-color: red;                 定义轮廓颜色;
    outline: 1px solid #000;            轮廓线的简写形式;
    

    display: none;                      隐藏元素(隐藏元素空间位);
    display: block;                     设置元素为块级元素;
    display: inline-block;              设置元素为内联块元素(内联块元素可以设置宽高, 但是不会独占一行);
    display: inline;                    设置元素为内联元素;
    diaplay: flex;                      定义弹性盒;
    

    visibility: hidden;                 隐藏元素(不隐藏元素空间位);
    visibility: visible;                显示元素(显示元素);
    opacity: 0;                         设置元素的透明度为0, 取值为0-1, 0为透明, 1为不透明;
    

    overflow: scroll;                   溢出显示滚动条;
    overflow: hidden;                   溢出内容隐藏;
    

    min-width: 10%;                     定义最小宽度
    max-width: 10%;                     定义最大宽度
    
    width: -webkit-fill-available;      定义宽度填充可用空间;
    height: -weikit-fill-available;     定义高度填充可用空间;
    width: fit-content;                 定义元素宽度根据内容占据;
    height: fit-content;                定义元素高度根据内容占据;
    width: min-content;                 自适应内部元素为最小的内容区域
    width: max-content;                 自适应内部元素为最大的内容区域
    
    
    
    
    
    
    
    
    
    
    
柒.元素背景属性的使用
    
    background-color: rgba();                 定义背景颜色

    background-image: url(路径),url(路径);      定义背景图片(可以定义多个, 使用逗号分割, 定义多个时候, 其他设置也一样, 使用逗号来分割);
    
    background-clip: content-box;               规定内容区域背景;
    background-clip: padding-box;               规定content和padding区域背景;
    background-clip: border-box;                规定content, padding, border区域背景;
    
    background-repeat: no-repeat;               规定背景图片不重复;
    background-repeat: space;                   规定重复的背景图平均分布;
    
    background-attachment: fixed;               背景图固定在元素上;
    background-attachment: scroll;              背景图跟随元素滚动;
    
    background-position: center;                设置背景图片居中;
    background-position: 50% 50%;               设置背景图片居中(也可以以数值的方式进行设置);
    
    background-size: 100px auto;               设置背景图的大小, 后面的auto意为: 根据图片大小定义,设置宽度, 高度自动, 防止图片变形;
    background-size: contain;                   保证图片会完全显示;
    
    background: red url(src) no-repeat center   background多个属性的缩写形式, 参数依次为: color, image, repeat, position;
    

    box-shadow: 10px 10px 10px rgba(100, 100, 100, 1);
    规定盒子阴影, 参数分别为:  x轴方向, y轴方向, 模糊度, 阴影颜色;
    
    background: linear-gradient(45deg, red 50%, green 30%, blue 20%);
    background: linear-gradient(to top left, red 50%, green 30%, blue 20%);
    设置背景线性渐变色, linear-gradient的参数依次为: 渐变方向, 渐变色1, 渐变色2, 渐变色3;
    他们之间的参数由于逗号分割, 参数中还有多位, 就使用空格分割
    参数渐变色1,2,3 后面的50%, 30%, 20%分别是标识位, 表示每个颜色所占的面积比, 如果都是33.3%时候, 就没有渐变的效果了
    也就是说这三个标识位不把100占满了就会有渐变的效果;
    同理渐变色参数如果有两个的话, 每个是50%, 也不会有渐变效果;

    background: linear-gradient(45deg, red, 30% green, 70% blue);
    中间的这个百分比这个参数是: 中间阈值, 和标识位不同, 阈值是一个独立的参数, 阈值只写在两个渐变色参数之间
    表示的是: 头一个渐变色和后一个渐变色中间的临界值;
    
    background: radial-gradient(100px 100px, red 50%, green 30%, blue 20%);
    background: radial-gradient(at top left, red 50%, green 30%, blue 20%);
    background: radial-gradient(at 50% 50%, red 50%, green 30%, blue 20%);
    设置别进圆角渐变色, radial-gradient的参数依次为: 渐变方向, 渐变色1, 渐变色2, 渐变色3;
    
    background: repeating-linear-gradient(90deg, black 15px, red 30px);
    重复线性渐变, 参数和linear-gradient相同;
    
    background: repeating-radial-gradient(100px 100px, black, red 15px);
    重复圆角渐变, 参数和radial-gradient相同;
    
    


捌.数据表格设计与表格定义
    display: table;                 定义为块级表格元素;
            table-row-group	        此元素会作为一个或多个行的分组来显示（类似 <tbody>）。
            table-header-group	    此元素会作为一个或多个行的分组来显示（类似 <thead>）。
            table-footer-group	    此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。
            table-row	            此元素会作为一个表格行显示（类似 <tr>）。
            table-column	        此元素会作为一个单元格列显示（类似 <col>）
            table-cell	            此元素会作为一个表格单元格显示（类似 <td> 和 <th>）
            table-caption	        此元素会作为一个表格标题显示（类似 <caption>）
    caption-size: top;              定义标题位置;

    
    table标签下对于td,th的样式属性: 
        empty-cells: hide;                  隐藏没有内容的(空的)单元格;
    

    list-style-type: lower-roman;           设置列表样式为小写的罗马符,
    list-style-image: url(src);             设置列表样式为背景图片;
    list-style-image: linear-gradient();    设置列表样式为镜像渐变;
    list-style-image: radial-gradient();    设置列表样式为镜像圆角渐变;
    

    div::after                                 之后追加属性;
        content: "内容"                              content这个属性用来定义向前添加的内容;
        content: attr(data-link)                    attr()这个方法就是用来读取标签上的属性, 也可以读取自定义属性(data-link), 会读取这个元素(div)属性的值作为内容;
    div::before                                之前追加属性;
    







玖.布局方式和BFC

    浮动元素会脱离文档流对后面元素产生影响, 被浮动的元素不在占据原有的位置;
    文档流定义的块级元素进行进行竖着流动(排列), 行元素横着流动(排列);
    
    如果一个元素使用了浮动, 他会对后面的元素有影响, 而不会影响到前面的元素;
    行内元素在脱离文档流后可以设置宽高;
    


    清除浮动
        clear: left;                    清除左边浮动;
        clear: right;                   清除右边浮动;
        clear: both;                    清除两边浮动;
    
    
    第二种方式
        清除浮动clearfix(clearOne)
        这种方法也很好理解, 在浮动元素之后添加一个元素清除左右浮动, 父元素不能检测到浮动元素的宽高, 但是可以检测到添加清除浮动的元素的宽高;
    
    
    第三种方式
        使用after伪类, 在元素之后添加一个空的内容的元素(content: "";), 然后清除浮动: clear: both; 最后:设置display: bolck;或者display: table;
        和第二种方式其实是一样的, 只不过是使用after伪类添加了这个元素而已;


    第四种方式
        在父元素添加overflow: hidden, 即可清除浮动;
        使用overflow: hidden;或者overflow: scroll;或者overflow: auto;都是可以清除浮动的;
        原理: 使用overflow来触发BFC机制; BFC机制会使父级元素在计算高度时, 仍然不会忽视里面的浮动元素的浮动空间(元素原有占位), 这样即可达到了清除浮动的效果;
        使用overflow方法处理是兼容时, 应该是height: auto; overflow: hidden;
    
    
    
    环绕距离控制
    shape-ouside: border-box;                   定义文本碍着元素的边框;
                    margin-box;                 定义文本碍着元素的margin;
                    padding-box;                定义文本碍着元素的padding;
                    content-box;                定义文本碍着元素的content;
                    url();                      定义图片路径, 文本可以根据图片进行环绕, 但是图片必须是png格式的透明状态才可以, jpg或jpeg是不生效的;             

    定义元素形状
        clip-path: circle(50% at 50% 50%);              定义圆形, 参数为(大小 at 圆心x轴位置 圆心y轴位置);
        clip-path: ellipse(50% 50%);                    定义椭圆, 参数为(以x轴宽度的圆形 以y轴为高度的圆形)
        clip-path: polygon(x y, x y, x y, x y, x y)     定义多边形, 参数为(x y, x y, x y, x y, x y);
    
    定义文本根据元素形状环绕
        clip-path: circle(50% at 50% 50%)               定义元素形状为圆形;
        shape-ouside: circle(50% at 50% 50%);           定义文本环绕方式是根据元素形状环绕;
            需要注意: 为了保证环绕效果, clip-path和shape-outside必须是作用在同一个元素上, 且两个属性的值必须相同才会生效;

    










    

拾.元素定位方式
    
    position: relative:                 相对定位;
        元素相对定位之后会保留原来的位置;
        相对于文档
    position: absolute;                 绝对定位;
        元素绝对定位之后不会保留原来的位置;
        绝对定位, 默认相对于浏览器视口(文档)进行定位, 但是如果某一个祖先元素有定位属性(不包含为static的定位值), 则会根据最近的有定位属性的这个祖先元素进行定位(就近原则);
        使用定位设置尺寸大小, 当一个元素有固定狂傲时, 设置了left, 在设置right多少都是无效的; 但是如果不设固定宽高就会同时实现left值和right值;以此来设置宽高尺寸;
        absolute会根据超出高度的父元素中的内容进行滚动;
    position: fixed;                    固定定位;
        固定定位参考的是页面, 不根据任何有定位属性的父级元素;
    position: sticky;
    粘性定位, 结合relative和fixed两种功能为一体的特殊定位
    释义: 元素先按照普通文档流定位, 然后相对于flow root(BFC) 和 containing block(最近的祖先块级元素)进行定位;
    然后元素定位表现在, 在跨越特定阈值之前表现为相对定位, 超出这个阈值范围则为固定定位;
    这个阈值指的就是sticky定位元素的left, right, top, bottom值;
    也就是, sticky的定位元素在指定left,right, top,bottom这些值时,才会生效;
    z-index: 1;                         定位元素的层级覆盖(值越大则权限越高);


















拾壹.珊格系统布局结构

        父级属性:
            
            display: grid;                      声明珊格容器
            grid-template-cloumns: 50% 50%;     声明珊格布局纵轴排列方式;
            grid-template-rows: 50% 50%;        声明珊格布局横轴排列方式;
            grid-template-rows: repeat(2, 50%); 等同于grid-template-cloumns: 50% 50%;
                绘制两行, 每行占比50%;
            grid-template-rows: repeat(2, 100px 50px); 
                绘制两行, 第一行为100px, 第二行为50px;
            grid-template-rows: repeat(auto-fill,100px);
                每一行为100px, 剩余部分自动填充;
            grid-template-rows: repeat(3,1fr);
                绘制三行, 每一行等位等比占用, 1fr有点类似于弹性盒中的flex: 1;的意思;
            grid-template-rows: 1fr 2fr 3fr;
                绘制三行, 第一行占比1份, 第二行占两份, 第三行占三份;
            grid-template-rows: repeat(2, minmax(50, 100px));
                绘制两行, 每一行的最小值为50px, 最大值为100px;
                简写为:
            grid-template:  row/columns;
                
            grid-row-gap: 10px;                 简写为: row-gap;
                每行的间距为10px;
            grid-columns-gap: 10px;             简写为: columns-gap;
                每列的间距为10px;
            gap: 10px 10px;                     行间距为10px, 列间距为10px, 如果只有一个值则表示行和列都有10px的间距;
            
        
        子级属性:
            grid-row-start: ;                   选中横轴开始珊格线编号
            grid-row-end: ;                     选中横轴结束珊格线编号;
            grid-columns-start: ;               选中纵轴开始珊格线编号;
            grid-columns-end: ;                 选中纵轴结束珊格先编号;
            

            grid-template-rows: [r1-start] 100px [r1-end r2-start] 100px [r2-end r3-start] 100px [r3-end];
            grid-template-columns: [c1-start] 100px [c1-end c2-start] 100px [c2-end c3-start] 100px [c3-end];
            grid-columns-start: 命名名称;        也可使用命名名称来规定线的位置, 这个名称在grid-template-rows中的值之间用[]进行声明;

            以上的方式太过麻烦, 还有以下的形式:
            
            grid-template-rows: repeat(3, [r-start] 1fr [r-end]);
            grid-template-columns: repeat(3, [c-start] 1fr [c-end]);
            grid-column-start: 命名名称;           这种方式和上面的方式无异, 只不过是grid-template-rows: repeat(3, [r-start] 1fr [r-end])的改变;
            

            加行span的思维方式就应该是以珊格为基准而不是以珊格线为基准;

            grid-column-start: span 2;              横轴第一个珊格偏移两格;     
            grid-rows-start:span 2;                 纵轴第一个珊格偏移两格;

            grid-direction-start/end, 的简写形式如下:

            grid-row: start/end;                     
            grid-column: start/end;                          
            如果设置偏移量如下: 
            grid-row: start/span 3;                 等同于以下写法;    
                grid-row-start: start;
                grid-row-end: span 3;
            grid-column: start/span 3;              等同于以下写法;        
                grid-column-start: start;
                grid-column-end: span 3;


        以上方式都是通过珊格线进行定位, 以下使用珊格区域进行定位;

            
            
        父级元素:
            规定珊格布局的区域
            grid-template-areas: "header header" "nav main" "footer footer";
            grid-remplate-areas: '. .' '. .' 'footer footer';
                如果之前的两个不想是一体的话, 可以使用. .来进行占位; 占位是必须的, 否则就是给上面header和nav和main命名
                而不是给footer命名了, 给每个部位进行命名就是就是给他们划分区域而变成一组, 如果变成一组则必须命名而不能占位了;
                
                
                

        
        子级元素:
            grid-area: row-start/column-start/row-end/column-end;           
            grid-area: header;                      根据父级的grid-template-areas的值进行子元素的区域划分;
                那么如.xiaomiLayout的例子, 分为四块(header, nav, main, footer);
                每一块的系统都会默认对每一块珊格线进行命名, 这里用header为例:
                header的水平上边线      ==>         header-start
                header的垂直左边线      ==>         header-start
                header的水平下边线      ==>         header-end
                header的垂直右边线      ==>         header-end

                所以当对子元素进行珊格定位时可以:
                grid-area: header-start/header-start/header-end/header-end
                这里只是用header为例子, 当定位时肯定用其他元素进行定位:main-start或footer-start或nav-start等等;
            
        
        排列方向, 对齐方式,
            父级元素:
                grid-auto-flow: row;                规定布局流动方向为横向;
                grid-auto-flow: column;             规定布局流动方向为纵向;
                grid-auto-flow: dense;              强制填满布局中的预留空白区域;
                grid-auto-flow: row dense;          强制填满布局中的预留空白区域,并且为横向流动的布局;
                
                justify-content: space-between;     规定珊格横轴排列方式
                justify-content: space-around;
                justify-content: space-evenly;
                justify-content: start;
                justify-content: end;
                justify-content: center;
                
                align-content: space-between;       规定珊格纵轴排列方式;
                align-content: space-around;
                align-content: space-evenly;
                align-content: start;
                align-content: end;
                align-content: center;

                分清楚一点不论是弹性布局还是珊格布局, items和content区别在于前者是控制盒子内的子元素的属性, content是控制盒子本身的属性;
                
                justify-items: stretch;             规定珊格横轴子元素的排列方式;默认值, 拉抻;注意如果子元素设置了固定宽高,那么justify-items属性将不会生效,
                justify-items: start;
                justify-items: end;
                justify-items: center;
                justify-items: space-around;
                justify-items: space-evenly;
                justify-items: space-between;

                align-items: stretch;               规定珊格纵轴子元素的排列方式;默认值, 拉抻;注意如果子元素设置了固定宽高,那么align-items属性将不会生效;
                align-items: start;
                align-items: end;
                align-items: center;
                align-items: space-around;
                align-items: space-evenly;
                align-items: space-between;
                
                place-items: justify align;         为justity-items和align-items的简写方式;
                place-content: justify align;       为justify-content和align-content的简写方式;

            子级元素:

                justify-self: stretch;             规定珊格横轴子元素的排列方式;默认值, 拉抻;
                justify-self: start;
                justify-self: end;
                justify-self: center;

                align-self: stretch;               规定珊格纵轴子元素的排列方式;默认值, 拉抻;
                align-self: start;
                align-self: end;
                align-self: center;

                place-self: justify align;       为justify-self和align-self的简写方式;












拾贰.transform转换二维三维;
    
    transform:
            转换属性是针对块级元素, 行内元素不生效就转换为块级元素;

            transform-style: flat;                                              定义所有子元素是在2d平面呈现;
            transform-style: preserve-3d;                                       定义所有子元素是在3d空间呈现;
            transform-origin: x y z;                                            定义元素的基点位置, 多用于rotate,scale等...
                                                                                左边值:[left center right 0-999..%]
                                                                                右边值:[top center bottom 0-999..%]
                                                                                数值是百分比 0 - 99999% 无限大;
                            

            translate
                transform: translateX(50px);                                    规定横轴偏移可以是px也可是%, 正数向后偏移,负数向前偏移;
                transform: translateY(50px);                                    规定纵轴偏移可以是px也可是%, 正数向后偏移,负数向前偏移;
                transform: translateZ(50x);                                     规定Z轴偏移必须是px像素值, 因为Z轴设置百分比是没有参考的, 从平面穿过可以无限延伸
                                                                                所以不像是X,Y轴可以设置百分比,X,Y轴都是可以设置固定值的,Z轴则不然;
                transform: translateY(50px) translateY(50px);                   同时可以应用多个属性值;
                transform: translate(50px 50px);                                以上的简写方式;

                transform: translateY(50%) translateY(50%) translateZ(50px);    同时可以应用多个属性值;
                transform: translate3d(50%, 50%, 50px);                         以上的简写方式: 这是X轴,Y轴,Z轴的简写,translate3d;
            

            scale 
                transform: scaleX(2);                                           横轴放大两倍;
                transform: scaleY(2);                                           纵轴放大两倍;
                transform: scaleZ(1);                                           Z轴拉长或变短(放大或缩小);
                transform: scale(x, y);
                transform: scale3d(x, y, z);                           

            

            rotate
                transform: rotateX(45deg);                                      横轴旋转45deg;
                transform: rotateY(45deg);                                      纵轴旋转45deg;
                transform: rotateZ(90deg);                                      Z轴旋转90deg;
                transform: rotate3d(x, y, z, deg);                              旋转的3d参数不同, 四个参数前三个分别是轴向,最后一个是角度,
                                                                                比如transform: rotate3d(1, 1, 1, 90deg);
                                                                                并且注意xyz轴向添的不是具体值而是比例值;
                注意:
                    transform: rotateX(45deg) rotateY(45deg);
                    transform: rotateY(45deg) rotateX(45deg);
                    先操作横轴,还是先操作纵轴结果是不同的;可以思考一下,先旋转横轴就是在横轴的基础上旋转Y轴;
                    先旋转Y轴就是在原来的基础上操作Y轴所以结果肯定不同;
                    
                
            skew
                transform: skewX(deg);                                          横轴倾斜角度
                transform: skewY(deg);                                          纵轴倾斜角度
                transform: skew(xdeg, ydeg);                                    
                
                注意: 
                    transform: skewX(-45deg) skewY(45deg);
                    transform: skew(-45deg, 45deg);
                    结果是不同的, 思考一下, 第一中是分为两步横轴倾斜-45deg的基础上再倾斜纵轴的45deg;
                    第二部则是X和Y轴同时进行,倾斜操纵;
                    目前skew倾斜属性没有Z轴的操作,  所以只有这两个参数;

            
            
            
            透视    
            perspective
                子元素上加: 
                    transfrom: perspective(500px);

                    给子元素单个设置, 可以每一个设置不同的值, 展示效果不同;
                    
                父元素上加:
                    perspective: 500px;

                    给所有子元素整体设置, 每一个设置的值都是相同的, 展示效果都相同;
                    如果给父元素添加transfrom: perspective(500px), 子元素是不会透视的;
                    
            三维空间:
                transfrom-style: preserve-3d;
                透视可以呈现的是元素的积淀, 但是没办法呈现三位空间, 所谓三位空间就是有Z轴参与的空间;
                所以如果操作元素的Z轴就必须添加这个三位的属性, 否则三维的效果是不会呈现的; 只会呈现X轴和y轴的二维效果;
                

            
            perspective-origin: left top;
                详见:main.perspective-origin;
                解释为平时c3动画都是操作物体在呈现动画, 这个属性则是规定物体不变, 人的视角改变;
                好比汽车之家的 旋转的车模型, 360deg旋转车来展现给我们, 这个属性则代表车不转了, 人围绕车转360deg看车是类似的;
                
            
            backface-visibility: hidden;
                属性定义当元素不正面向屏幕时是否可见;
            

















拾叁.css过渡&动画
    transition
        C3的过渡,对于极少数的属性不生效,比如border-style等...
        其实每一个元素在hover时都会有一个过渡效果,只不过这个效果是以毫秒为单位时间太短,效果并不明显;
        这个效果在hover时可以继承, 也可以单另设置值, 比如transition在hover之前是2s, 在hover时
        可以设置为200ms; 那么当滑过时就会以200ms的时间展示动画, 但如果滑出时就还会以2s的时间呈现动画;

        transitionEnd事件可以被监听动画结束, 动画结束可以设置回掉函数规定结束之后对元素的操作;

        
        
        
                                            
        transition-property: property;                                      定义元素过渡属性, all为全部属性;
                                                                            通常这个属性很少用, 因为默认值就是all;
            transition-property: all;                                       全部属性具有过渡属性;
            transition-property: background-color, width, height;           背景色, 宽度, 高度,具有过渡属性;

            
            
        transition-duration: time;                                          定义元素过渡时间;
            transition-duration: 1s;                                        过渡时间为1秒;
            transition-duration: 500ms;                                     过渡时间为500毫秒;
            transition-duration: 1s, 2s;                                    奇数属性过渡时间为1s, 偶数过渡时间为2s;
            transition-duration: 1s, 2s, 3s;                                如果perproty的值多于duration时, duration的值就从前到后排列, 第四个值没有就是第一个值开始;
                                                                            如果duration的值多于property时, 多出来的duration值不会生效;
            
        transition-timing-function: cubic-bezier(startX, startY, endX, endY)    定义过渡过程为贝塞尔曲线;
                                                                                cubic-bezier()参数是开始滑动的x,y坐标和结束滑动时的x,y坐标;
            ease, linear, ease-in, ease-out, ease-in-out;                       系统定义的这几个值;
            
            transition-timing-function: steps(3, start);                            分三步走完动画, 开始就走;
                等同于
            transition-timing-function: step-start(3);

            transition-timing-function: steps(3, end);                              分三步走完动画, 当第一帧走完才会开始走;
                等同于
            transition-timing-function: step-end(3);
        
        
            transition-delay: time;                                                 动画延迟3秒在执行;
            transition-delay: time1, time2;                                         延迟属性也和duration一样会根据值的多少应用到property上面;
                                                                                    delay值多了不会生效, delay值少了就会根据property值的顺序进行排列;


        过渡属性综合设置, 值顺序如下: 
        transition: property timing-function duration delay;
            transition: all linear 2s 200ms;
            所有属性linear过程呈现时间2s延迟200ms;
        过渡属性综合每一个设置不同的值:
        transition: border-radius linear 1s 200ms,
                    width linear 1s 200ms,
                    height linear 1s 200ms,
                    background-color linear 1s 200ms;
        










拾肆.C3帧动画animate
    
    animate 帧动画使用@keyframes定义每一帧, 形式如下两种;
        方式一:
            @keyframes  name {
                from{
                    
                }
                to{
                    
                }
            }
        方式二: 
            @keyframes  name {
                0%{
                    
                }
                25%{
                    
                }
                50%{
                }
                75%{

                }
                100%{
                    
                }

                25%,75%{
                    25和75有相同的操作和一这样写入, 以上的样式不会被覆盖;
                }
            }

        之前在过渡中有些属性是不会产生过渡效果, 那么动画一样有些属性也是不会有动画效果的;
        没有中间值的属性是没有效果的: 比如width: auto; 但 widht: 100px;这种具体数值会有属性;
        
        
    animate:
        缩写形式如下:(组合定义);
        animation: name duration timing-function delay iteration-count direction fill-mode;
        
        animation-name: name,name,name;                                             一个元素可以应用多个帧动画;

        animation-delay:  time;                                                     规定延迟执行时间;

                                                                                    如果在帧动画中的多个动画有属性重叠时,那个动画在后,就会应用哪个, 会覆盖前面的帧动画;
        animation-duration: 1s, 2s, 3s;                                             值多少的规则会应用哪一个和transition同理;

        animation-fill-mode: forwards;                                              规定动画最后一帧回到100%帧状态的操作;
                                                                                    fill-mode 由 animation-iteration-count  这个属性决定
        animation-fill-mode: backwards;                                             规定动画从0%状态开始执行而不是初始状态;
        animation-fill-mode: both;                                                  forwards和backwards的结合;
                                                                                    即从0%状态开始,到100%结束并且停止在100%状态;                                          
                                                                                    也就是说和初始状态就没关系了, 只执行帧动画中的属性;
                                                                                    
        animation-iteration-count: infinite;                                        规定动画的执行次数;
                                                                                    应用多个动画时, 规则不变; 值对应animation-name的值以此往背后排列;
        animation-direction: normal;                                                规定动画从0到100%执行一次;
        animation-direction: reverse;                                               规定动画从100%到0%执行一次;
        animation-direciton: alternate;                                             先从0%到100%执行一次动画, 然后在从100%到0%执行一次;
        animation-direciton: alternate-reverse;                                     先从100%到0%执行一次动画, 然后在从0%到100%执行一次;
        
        
        animation-timing-function: ease;                                            规定动画方式(默认值);
        animation-timing-function: ease-in;
        animation-timing-function: ease-out;
        animation-timing-function: ease-in-out;
        animation-timing-function: linear;
        animation-timing-function: cubic-bezier(0,1.5,1,-0.5);                      规定动画方式为贝塞尔曲线(自定义);

        animation-timing-function: steps(4, start);                                 步进动画(走四步, 开始便走);
        animation-timing-function: steps(4, start);                                 步进动画(走四步, 第一帧走完之后便走);
        animation-timing-function: steps(1, start);                                 步进动画(走一步, 开始便走);
                            等同于: step-start;
        animation-timing-function: steps(1, start);                                 步进动画(走一步, 第一帧走完之后便走);
                            等同于: step-end;
        
        currentColor特性:
            border: 1px solid currentColor;                                         currentColor指代的是当前元素的color的值;
                                                                                    color是什么颜色, currentColor就是什么颜色;

        animation-play-state: paused;                                               暂停动画;
        animation-play-state: running;                                              运行动画;





















拾伍.flex弹性布局&盒模型

    padding
    border

    盒模型:
        content-box: padding, border, 盒子会变大(向内扩展);
        border-box: 盒模型,padding, border, 盒子模型不变大(向外扩展);
        

    
    calc(公式);
        css中的计算函数;
        
        calc(100px-2px)         ×
        calc(100px - 2px)       √
        
        要注意语法格式, 中间的空格;
        
        



    弹性盒:
        定义弹性盒:
        display: flex;
            在13年左右时, 弹性盒的定义用的是: display: -webkit-box;
            开发中使用webpack的postCss插件,添加前缀处理兼容;
            如果是弹性布局, 子元素不需要添加浮动了;
        
    
        父级属性;
            display: flex;
            
            定义水平排列方式;
            justify-content: center;                居中
                            flex-start;             居左
                            flex-end;               居右
                            space-between;          两端对齐
                            space-around            围绕分布(体操双手展开分布)
                            space-evenly            均匀分布



            定义垂直排列方式;
            align-items: center;                    垂直居中;
                        flex-start;                 顶部;
                        felx-end;                   底部;


            flex-direction: row;                    横向排列;
                            row-reverse             横向反转排列;
                            cloumn                  纵向排列
                            cloumn-reverse          纵向反转排列

            规定子元素是否在一行显示;
            flex-wrap: nowrap                       不换行显示(默认值);
                        wrap                        换行显示
                        wrap-reverse                反转换行显示;
                        

            多行时的垂直排列;
            align-content: center;                  居中排列
                            flex-start              顶部排列
                            flex-end                底部排列
                            space-between           两端对齐
                            space-around            围绕分布

            flex-direction和flex-wrap的简写
            flex-flow: 值包含flex-direction和flex-wrap的所有值(值可以写多个, 用空格分开);
            flex-flow: cloumn wrap;(意为: 纵向排列并且换行);    ==  flex-direction: cloumn; flex-wrap: wrap;
            




        子级属性:
            平分长度:
            flex: 1;                                1指的是一个系数,相当于把父元素的宽度分为两份, 每个子元素一份; 如果是二效果一样, 相当于父元素的宽度分为四份,每个子元素两份平分;
                                                    子元素在划分父元素宽度时, 先抛出固定宽度, 剩下的宽度就会加给具有flex属性值的子元素;
                                                    flex是flex-grow,flex-shrink,flex-basis三个属性值的缩写,值一定是1以上的数值才会生效;
                                                    深入解读flex这个缩写属性: https://zhuanlan.zhihu.com/p/39052660;

            
            定义子元素的放大比例(即换行之后的元素的宽度排行方式);
            flex-grow: 1;                           值同flexi相同, 必须是1以上的数值;
            

            子级元素自己的垂直排列方式(用来覆盖父级的align-items属性的);
            align-self: 
            
            
            规定子元素的顺序;
            order: 0;                               数值越小越靠前(默认值);    
    

















拾陆.media响应式媒体查询

        <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"> -->
        width = device-width：宽度等于当前设备的宽度
        initial-scale：初始的缩放比例（默认设置为1.0）
        minimum-scale：允许用户缩放到的最小比例（默认设置为1.0）
        maximum-scale：允许用户缩放到的最大比例（默认设置为1.0）
        user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）
        
        
        在css中一般都会分类很多设备, 比如: tv, tty, screen, print;
        但是随着新版本发布之后, 很多设备被废弃掉了, 没有处理这些设备的必要; 日常生活中常用的设备就只有screen;
        media的默认值就是all;
        

        嵌入式声明设备类型:
            <!-- <style media="all and (...) and (...)">
                h1 {
                    color: red;
                }
            </style>
            <style media="screen and (...) and (...)">
                h1 {
                    color: red;
                }
            </style>
            <style media="print and (...) and (...)">
                h1 {
                    color: green;
                }
            </style> -->


        外链式设置媒体类型:
            屏幕设备使用screen;
            <link rel="stylesheet" href="xxxxxxx/.screen.css" media="screen">
            打印机设备使用print;
            <link rel="stylesheet" href="xxxxxxx/print.css" media="print">
            公用的公公文件:
            <link rel="stylesheet" href="xxxxxxx/common.css" media="all">

        
        @import url()样式表中引入组件样式;
            @import url(./common.css) all;
            @import url(./screen.css) screen;
            @import url(./print.css) print;
            url() 之后的参数用来指定设备类型的;
        
        样式表中的声明媒体类型;
            @media screen and (max-width: 600px)
            
            
        








        media条件判断and:
            and 既 &;
            @media screen and (min-width: 768px)  and (max-width: 1360px){ ..code.. }
            如果有很多条件可以使用多个and 进行条件判断;
            screen and (...) and (...) and (...) and (...);
            一般情况下也就是使用两个判断条件;


        media条件判断,:
            , 既 or,||;
            @media screen and (orientation: landscape),screen and (min-width: 900px) { ...code... }
            如果屏幕是横屏时 或者 屏幕大于900px时;
            @media screen and (orientation: portrait),screen and (min-width: 900px) { ...code... }
            如果屏幕是竖屏时 或者 屏幕大于900px时;
            或判断同样也可以是多个判断条件, 规则如下:
            @media screen and (...) , screen and (...) , screen and (...);
            

        media条件判断not:
            not 既 !;
            @media not screen and (min-width: 320px) and (max-width: 768px) { ...code... }
            如果屏幕是320px - 768px 这个范围则不应用的一套样式;

        
        media条件判断only;
            @media only screen and (min-width: 320px) and (max-width: 768px) { ...code... }
            only用来指定某种特定的媒体类型
            很多时候是用来对那些不支持媒体特性但却支持媒体类型的设备

            
        
        常见的几种屏幕宽度设定;
            @media screen and (min-width: 1200px) {
                css-code;
            }
            @media screen and(min-width: 960px) and (max-width: 1199px) {
                    css-code;
            }
            @media screen and(min-width: 768px) and (max-width: 959px) {
                    css-code;
            }
            @media screen and(min-width: 480px) and (max-width: 767px) {
                    css-code;
            }
            @media screen and (max-width: 479px) {
                    css-code;
            }
        

        



















拾柒.圣杯布局&双飞翼布局

    三栏布局:
        圣杯布局:
            主题部分两边固定, 中间自适应,且要优先加载;

            <main class="grailLayout">
                <header>头部</header>
                <div class="center">主区域</div>
                <div class="left">左区域</div>
                <div class="right">右区域</div>
                <footer>底部</footer>
            </main>

            如上所示:
                因为主区域的内容需要优先加载;所以主区域要放在左右区域的前面;
                
            具体思路:
                将center,left,right外面包一层父元素用来清浮, 然后三个元素进行浮动, 这时可以避免浮动的乱版;
                然后再在wrapper父元素设置padding: 0 100px;  用来处理左右元素留有该有的空间;
                center进行设置width: 100%, 这时left,right就会跑到第二行;
                left设置margin-left: -100%; 就会回到原有的左边位置上;
                right设置margin-right: -100px; 就会回到原来右边位置;
                这时想要左右元素不覆盖到center元素上, 就是用定位属性
                left元素设置position: relative; left: 0;
                right元素设置position: relative; right: 0;
                此时即可使左右元素不会覆盖到center元素上, 并回到原位;

            
            
        双飞翼布局:
            主题部分两边固定, 中间自适应,且要优先加载;
            
            <main class="doubleWingsLayout">
                <header>头部</header>
                <div class="wrapper">
                    <div class="center">主区域</div>
                </div>
                <div class="left">左区域</div>
                <div class="right">右区域</div>
                <footer>底部</footer>
            </main>
    
            如上所示:
                因为主区域的内容需要优先加载;所以主区域要放在左右区域的前面;
                但和圣杯布局的异同就是wrapper只是包裹了center元素, 并没有包裹left和right元素;
                
                
            具体思路:
                将center外面包一层父元素用来和left,right一起浮动, 但是清浮要添加到footer元素上;
                然后再在center元素设置margin: 0 100px;  用来处理左右元素留有该有的空间;
                wrapper进行设置width: 100%, 这时left,right就会跑到第二行;
                left设置margin-left: -100%; 就会回到原有的左边位置上;
                right设置margin-right: -100px; 就会回到原来右边位置;
                此时即可使左右元素不会覆盖到center元素上, 并回到原位;




        圣杯和双飞翼布局的对比:
            圣杯布局:
                结构一目了然;  wrapper包裹的是center,left,right;
                样式上圣杯布局代码量比较多, 使用了相对定位进行实现三栏对称;
            双飞翼布局:
                结构不太直观;  wrapper包裹的只是center;
                样式上双飞翼布局代码量比较少, 没有使用定位实现三栏对称;
            
            总结:
                个人爱好更推荐使用圣杯: 只因为结构清晰明了, 所以清浮原理也变得容易理解, 使得这种布局结构比较稳定;
                双飞翼布局看个人喜好效果都相同;

