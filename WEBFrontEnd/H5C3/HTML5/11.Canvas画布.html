<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">
    <style>
        *{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body{
            text-align: center;
        }
        #canvas{
            display: block;
            box-shadow: 0px 0px 10px #000;
            margin: 50px auto;
            /* display: none; */
        }
    </style>
</head>
<body>

    <canvas width="800" height="600" id="canvas" style="display: block;">
        您的浏览器不支持Canvas!请升级或者更换浏览器进行浏览;
    </canvas>





    <!-- 刮刮卡 -->
        <!-- <style>
            body,html{
                margin: 0;
                text-align: left;
            }
            img{
                
            }
            #scraping-card{
                display: block;
                position: absolute;
                left: 0;
                top: 0;
                z-index: 1;
            }

        </style>
        <img src="../images/1.jpg" alt="">
        <canvas width="1024" height="711" id="scraping-card">
            您的浏览器不支持Canvas!请升级或者更换浏览器进行浏览;
        </canvas> -->
    
    
    



    <!-- 图像组合 globalCompositeOperation -->
        <!-- <style>
            body,html{
                margin: 0;
                text-align: center;
            }
            #globalCompositeOperation{
                display: block;
                box-shadow: 0px 0px 10px #000;
                margin: 50px auto;
            }

        </style>
        <canvas width="800" height="600" id="globalCompositeOperation">
            您的浏览器不支持Canvas!请升级或者更换浏览器进行浏览;
        </canvas> -->
    
    
    

    <!-- 水平全景滚动 -->
    <!-- <canvas width="1200" height="300" id="panorama">
        您的浏览器不支持Canvas!请升级或者更换浏览器进行浏览;
    </canvas> -->
        
        
    
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script>
        
        window.onload = function () {

            // 获取canvas元素
            var canvas = document.getElementById('canvas');
            // 创建canvas上下文;
            if(canvas.getContext){
                var ctx = canvas.getContext('2d');
            }else{
                alert('浏览器不支持canvas');
            }

            // 绘制填充矩形;
            // 注意顺序, fillStyle必须在fillRect声明之前声明, 否则不生效;
                // ctx.fillStyle = 'rgba(200, 0, 0, 0.5)';
                // ctx.fillRect(10,10,350,350);

                // ctx.fillStyle = 'rgba(0, 0, 200, 0.5)';
                // ctx.fillRect(30,30,350,350);
            

            // 绘制描边矩形;
            // 注意顺序, strokeStyle必须在strokeRect声明之前声明, 否则不生效;
                // ctx.strokeStyle = 'rgba(200, 0, 0, 0.5)';
                // ctx.strokeRect(10,10,350,350);

                // ctx.strokeStyle = 'rgba(0, 0, 200, 0.5)';
                // ctx.strokeRect(30,30,350,350);
            
            
            // 绘制中心空白的矩形;
                // ctx.fillRect(25, 25, 100, 100);
                // ctx.clearRect(45, 45, 60, 60);
                // ctx.strokeRect(50, 50, 50, 50);
            

            // 通过路径绘制图形;
                // 绘制三角形;
                    // ctx.beginPath();
                    // ctx.moveTo(100, 100);
                    // ctx.lineTo(150, 50);
                    // ctx.lineTo(150, 150);
                    // // ctx.lineTo(100, 100);
                    // ctx.closePath();
                    // ctx.stroke();
                    // // ctx.fill();
                

                // 双三角形
                    // // 填充三角形;
                    // ctx.beginPath();
                    // ctx.moveTo(25, 25);
                    // ctx.lineTo(105, 25);
                    // ctx.lineTo(25, 105);
                    // ctx.fill();

                    // // 描边三角形;
                    // ctx.moveTo(125, 125);
                    // ctx.lineTo(125, 45);
                    // ctx.lineTo(45, 125);
                    // ctx.closePath();
                    // ctx.stroke();
            

            // 绘制圆形
                // ctx.strokeStyle = 'orange';
                // ctx.lineWidth = 10;
                // ctx.arc(400, 300, 150, 0, Math.PI, false);
                // // ctx.arc(400, 300, 150, 0, Math.PI * 1.5, true);
                // ctx.stroke();



            // 循环绘制不规则圆;
                // for(var i = 0; i < 4; i++){
                //     for(var j = 0; j < 3; j++){

                //         var x = 25 + j * 100;
                //         var y = 25 + i * 100;
                //         var radius = 20;
                //         var startAngle = 0;
                //         var endAngle = Math.PI + (Math.PI * j) / 2;
                //         var anticlockwise = (i % 2) == 0 ? false : true;
                        
                //         ctx.beginPath();
                //         ctx.arc(x,y,radius,startAngle,endAngle,anticlockwise);
                //         ctx.stroke();

                //         if(i > 1) ctx.fill();
                        
                //     }
                // }


            

            // 绘制笑脸;
                // 当每一个圆绘制结束, 从新指定落笔点即可清除圆之间的连线;
                // ctx.beginPath();
                // ctx.arc(75, 75, 50, 0, Math.PI * 2);
                // ctx.moveTo(115, 75);
                // ctx.arc(75, 75, 40, 0, Math.PI);
                // ctx.moveTo(65, 65);
                // ctx.arc(60, 65, 5, 0, Math.PI * 2);
                // ctx.moveTo(95, 65);
                // ctx.arc(90, 65, 5, 0, Math.PI * 2);
                // ctx.stroke();
                

                // 没绘制好一个圆时, 结束一次路径也可实现;
                // ctx.beginPath();
                // ctx.arc(75, 75, 50, 0, Math.PI * 2);
                // ctx.stroke();
                // ctx.closePath();
                // ctx.beginPath();
                // ctx.arc(75, 75, 40, 0, Math.PI);
                // ctx.stroke();
                // ctx.closePath();
                // ctx.beginPath();
                // ctx.arc(60, 65, 5, 0, Math.PI * 2);
                // ctx.stroke();
                // ctx.closePath();
                // ctx.beginPath();
                // ctx.arc(90, 65, 5, 0, Math.PI * 2);
                // ctx.closePath();
                // ctx.stroke();



            
            // 线性渐变;
                // var linearGradients = ctx.createLinearGradient(20, 20, 50, 50);
                // linearGradients.addColorStop(.1, 'red');
                // linearGradients.addColorStop(.6, 'blue');
                // linearGradients.addColorStop(1, 'green');
                
                // var linearGradients2 = ctx.createLinearGradient(35, 35, 50, 50);

                // linearGradients2.addColorStop(.1,'green');
                // linearGradients2.addColorStop(.6,'blue');
                // linearGradients2.addColorStop(1,'red');
                
                // ctx.lineWidth = 5;
                // ctx.fillStyle = linearGradients;
                // ctx.fillRect(20,20,50,50);
                // ctx.strokeStyle = linearGradients2;
                // ctx.strokeRect(30,30,30,30);
                



            // 径向渐变;
                // var radialGradients = ctx.createRadialGradient(150,150,10,150,150,120);
                // radialGradients.addColorStop(0, 'red');
                // radialGradients.addColorStop(.3, 'blue');
                // radialGradients.addColorStop(1, 'green');
                

                // ctx.fillStyle =  radialGradients;
                // ctx.fillRect(50, 50, 100, 100);
                
                // ctx.arc(150, 150, 80, 0, Math.PI * 2, false);
                // ctx.fillStyle = radialGradients;
                // ctx.fill();
                
                


            // 绘制图片;
                // var img = new Image();
                // img.src = '../../images/1.jpg';
                
                // img.onload = function () {
                //     var pattern = ctx.createPattern(img, 'repeat');
                //     ctx.fillStyle = pattern;
                //     ctx.fillRect(0,0,800,600);
                // }
                
                // img.onload = function () {
                //     ctx.drawImage(this, 0, 0, 400, 300);
                //     ctx.drawImage(this, 0, 0, 400, 300, 200, 0, 200, 150);
                // }




                
            // 绘制文字以及阴影;
                // var linearGradients = ctx.createLinearGradient(100, 200, 600, 400);
                // linearGradients.addColorStop(0, 'red');
                // linearGradients.addColorStop(.5, 'blue');
                // linearGradients.addColorStop(1, 'green');
                // ctx.shadowColor = '#aaa';
                // ctx.shadowBlur = 10;
                // ctx.shadowOffsetX = 20;
                // ctx.shadowOffsetY = 20;
                
                // ctx.font = 'bold italic 150px arial';
                // ctx.fillStyle = linearGradients;
                // ctx.fillText('leecs', 100, 200);



            
            

            // 图片Clip
                // var img = new Image();
                // img.src = '../../images/1.jpg';
                
                // img.onload = function () {
                //     ctx.beginPath();
                //     ctx.arc(400, 300, 200, 0, Math.PI*2);
                //     ctx.clip();
                //     ctx.drawImage(this, -100, 0);
                // }
                

            

            // 涂鸦
                // canvas.onmousedown = function (event) {
                //     var ev = event || window.event;
                //     var x = ev.clientX - canvas.offsetLeft;
                //     var y = ev.clientY - canvas.offsetTop;

                //     ctx.strokeStyle = 'green';
                //     ctx.lineWidth = 10;
                //     ctx.beginPath();
                //     ctx.moveTo(x, y);

                //     canvas.onmousemove = function (event) {
                //         var ev = event || window.event;
                //         var x = ev.clientX - canvas.offsetLeft;
                //         var y = ev.clientY - canvas.offsetTop;
                //         ctx.lineTo(x, y);
                //         ctx.stroke();
                        
                //     }
                //     canvas.onmouseup = function () {
                //         canvas.onmousemove = null;
                //     }
                // }
            
            


            // 刮刮卡;
            
                // var canvas = document.getElementById('scraping-card');
                // // 创建canvas上下文;
                // if(canvas.getContext){
                //     var ctx = canvas.getContext('2d');
                // }else{
                //     alert('浏览器不支持canvas');
                // }
                
                // ctx.fillStyle = 'gray';
                // ctx.fillRect(0, 0, canvas.width, canvas.height);

                // // 定义新图像如何绘制到已有的图像上 = 只有源图像之外的目标图像部分会被显示并且为透明状态;
                // ctx.globalCompositeOperation = 'destination-out';

                // ctx.lineWidth = 30;
                // ctx.lineCap = 'round';
                // ctx.beginPath();
                
                // canvas.onmousedown = function (event) {
                //     var ev = event || window.event;
                //     var x = ev.clientX - canvas.offsetLeft;
                //     var y = ev.clientY - canvas.offsetTop;

                //     // ctx.strokeStyle = 'red';
                    
                //     ctx.moveTo(x, y);
                    
                //     canvas.onmousemove = function (event) {
                //         var ev = event || window.event;
                //         var x = ev.clientX - canvas.offsetLeft;
                //         var y = ev.clientY - canvas.offsetTop;

                //         ctx.lineTo(x,  y);
                //         ctx.stroke();
                        
                //     }
                    
                //     canvas.onmouseup = function() {
                //         canvas.onmousemove = null;
                //     }
                    
                // }
            








            // 图像组合;

                // var canvas = document.getElementById('globalCompositeOperation');
                // // 创建canvas上下文;
                // if(canvas.getContext){
                //     var ctx = canvas.getContext('2d');
                // }else{
                //     alert('浏览器不支持canvas');
                // }
            
                // // 目标对象
                // ctx.fillStyle = 'red';
                // ctx.fillRect(30, 30, 50, 50);
                
                // ctx.globalCompositeOperation = 'destination-out'
                
                // // 源对象
                // ctx.fillStyle = 'blue';
                // ctx.arc(80, 80, 30, 0, Math.PI * 2);
                // ctx.fill();
            
                
            
            


            // 矩形直线运动
                // // canvas动画原理:
                // // 1.绘制图像;
                // // 2.清除图像;
                // // 3.更新位置;
                // // 4.绘制图像;
                // // 5.2,3,4重复;

                // var x = 0,
                //     y = 0,
                //     width = 100,
                //     height = 100,
                //     speedX = 2,
                //     speedY = 2;

                
                // ctx.beginPath();
                // ctx.fillStyle = 'blue';
                // ctx.fillRect(x, y, width, height);
            
                // setInterval(function () {

                //     ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                //     x += speedX;
                //     if(x > canvas.width - width){
                //         speedX *= -1;
                //     }else if(x < 0) {
                //         speedX *= -1;
                //         // -2 * -1 == 2即可
                //     }

                //     y += speedY;
                //     if(y > canvas.height - height){
                //         speedY *= -1;
                //     }else if(y < 0) {
                //         speedY *= -1;
                //     }

                //     ctx.fillRect(x, y, width, height);
                    
                // },3);









            // 请求关键帧运动(面向过程)实现;

                // var x = 0,
                //     y = 0,
                //     width = 100,
                //     height = 100,
                //     speedX = 2,
                //     speedY = 2;

                
                // ctx.beginPath();
                // ctx.fillStyle = 'blue';
                // ctx.fillRect(x, y, width, height);
            


                // function move() {
                //     ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                //     x += speedX;
                //     if(x > canvas.width - width){
                //         speedX *= -1;
                //     }else if(x < 0) {
                //         speedX *= -1;
                //         // -2 * -1 == 2即可
                //     }

                //     y += speedY;
                //     if(y > canvas.height - height){
                //         speedY *= -1;
                //     }else if(y < 0) {
                //         speedY *= -1;
                //     }

                //     ctx.fillRect(x, y, width, height);

                //     window.requestAnimationFrame(move);
                // }
                // move();
                
                



                
                
            
            // 圆形碰撞反弹(面向对象)实现;
                
                // function Ball(x, y, r, speedX, speedY, color) {
                //     // 设置属性;
                //     this.x = x;
                //     this.y = y;
                //     this.r = r;
                //     this.speedX = speedX;
                //     this.speedY = speedY;
                //     this.color = color;
                    
                //     // 设置方法;
                //     this.draw = function () {
                //         ctx.beginPath();
                //         ctx.fillStyle = this.color;
                //         ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                //         ctx.fill();
                //     };
                    
                //     this.move = function () {
                //         this.x += this.speedX;
                //         if(this.x > canvas.width - this.r){
                //             this.speedX *= -1;
                //         }else if(this.x < this.r){
                //             this.speedX *= -1;
                //         }

                //         this.y += this.speedY;
                //         if(this.y > canvas.height - this.r){
                //             this.speedY *= -1;
                //         }else if(this.y < this.r){
                //             this.speedY *= -1;
                //         }
                //     };
                // }

                // var ball = new Ball(50, 50, 50, 2, 2, 'blue');

                // function start() {
                //     ctx.clearRect(0, 0, canvas.width, canvas.height);
                //     ball.draw();
                //     ball.move();
                //     window.requestAnimationFrame(start);
                // }
                // start();
                

                





                
            // 水平全景滚动
                
                // var canvas = document.getElementById('panorama');
                // if(canvas.getContext){
                //     var ctx = canvas.getContext('2d');
                // }else{
                //     alert('您的浏览器不支持canvas');
                // }

                // var x = 0;
                
                // function scrolling() {
                //     // 记录状态;
                //     ctx.save();
                //     ctx.clearRect(0, 0, canvas.width, canvas.height);
                //     ctx.translate(-x,0);
                //     ctx.drawImage(panoramaImg, 0, 0);
                //     ctx.drawImage(panoramaImg, canvas.width, 0);

                //     x++;

                //     if(x >= canvas.width){
                //         x = 0;
                //     }

                //     ctx.restore();
                //     window.requestAnimationFrame(scrolling);
                // }
                

                // var panoramaImg = new Image();
                // panoramaImg.src = './images/panorama.jpg';
                
                // panoramaImg.onload = function () {
                //     scrolling();
                // }
                
            

            // save&restore
                // ctx.beginPath();
                // ctx.fillStyle = 'blue';
                // ctx.fillRect(100, 100, 150, 150);
                // ctx.save();
                // ctx.closePath();
                

                // ctx.beginPath();
                // ctx.fillStyle = 'red';
                // ctx.save();
                // ctx.fillRect(100, 300, 150, 150);
                // ctx.closePath();

                // ctx.beginPath();
                // ctx.restore();
                // ctx.fillRect(300, 100, 150, 150);
                // ctx.closePath();
                
                // ctx.beginPath();
                // ctx.restore();
                // ctx.fillRect(300, 300, 150, 150);
                // ctx.closePath();
                

            







            // 矩形碰撞检测;
                // function Rect(x, y, width, height, color, speed) {
                //     this.x = x;
                //     this.y = y;
                //     this.width = width;
                //     this.height = height;
                //     this.color = color;
                //     this.speed = speed;
                // }

                // Rect.prototype.draw = function () {
                //     ctx.beginPath();
                //     ctx.fillStyle = this.color;
                //     ctx.fillRect(this.x, this.y, this.width, this.height);
                //     ctx.closePath();
                // }

                // Rect.prototype.move = function () {
                //     this.x += this.speed;
                //     if(this.x >= canvas.width - this.width){
                //         this.speed *= -1;
                //     }else if(this.x < 0) {
                //         this.speed *= -1;
                //     }
                // }
                

                // // 创建两个矩形;
                // var rect1 = new Rect(0, 100, 100, 100, 'red', 2);
                // var rect2 = new Rect(700, 100, 100, 100, 'blue', -2);


                // function animate() {
                //     // 清除画布;
                //     ctx.clearRect(0, 0, canvas.width, canvas.height);

                //     // 移动;
                //     rect1.draw();
                //     rect1.move();
                //     rect2.draw();
                //     rect2.move();

                //     // 检测
                //     if(isRectColl(rect1, rect2)){
                //         rect1.speed *= -1;
                //         rect2.speed *= -1;
                //     }
                    
                //     window.requestAnimationFrame(animate);
                // }

                // animate();


                // // 检测是否是碰撞
                // function isRectColl(rect1, rect2) {
                //     // 获取矩形的最小x和最大x;
                //     var min1 = rect1.x;
                //     var min2 = rect2.x;
                //     var max1 = rect1.x + rect1.width;
                //     var max2 = rect2.x + rect2.width;

                //     var min3 = Math.max(min1, min2);
                //     var max3 = Math.min(max1, max2);
                    
                //     if(min3 < max3) {
                //         return true;
                //     }else{
                //         return false;
                //     }
                // }
            











            // 圆形碰撞检测;
                // function Ball(x, y, r, color, speed) {
                //     this.x = x;
                //     this.y = y;
                //     this.r = r;
                //     this.color = color;
                //     this.speed = speed;
                // }

                // var ball1 = new Ball(50, 50, 50, 'blue', 2);
                // var ball2 = new Ball(750, 50, 50, 'green', 2);
                

                // Ball.prototype.draw = function () {
                //     ctx.beginPath();
                //     ctx.fillStyle = this.color;
                //     ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                //     ctx.fill();
                // }

                // Ball.prototype.move = function () {
                //     this.x += this.speed;
                //     if(this.x > canvas.width - this.r) {
                //         this.speed *= -1;
                //     }else if(this.x < this.r){
                //         this.speed *= -1;
                //     }
                // }
            

                // function animate() {

                //     ctx.clearRect(0, 0, canvas.width, canvas.height);

                //     if(isArcColl(ball1, ball2)){
                //         ball1.speed *= -1;                        
                //         ball2.speed *= -1;                        
                //     }
                    
                //     ball1.move();
                //     ball2.move();
                //     ball1.draw();
                //     ball2.draw();
                    
                //     window.requestAnimationFrame(animate);
                // }

                // animate();

                // function isArcColl(ball1, ball2) {
                //     var x1 = ball1.x;
                //     var y1 = ball1.y;
                //     var r1 = ball1.r;

                //     var x2 = ball2.x;
                //     var y2 = ball2.y;
                //     var r2 = ball2.r;
                    
                //     var dx = x1 - x2;
                //     var dy = y1 - y2;
                    
                //     var distance = Math.sqrt(dx * dx + dy * dy);
                    
                //     if(distance < r1 + r2){
                //         return true;
                //     }else {
                //         return false;
                //     }
                // }

            
        }
    </script>
    
    <section style="display: none;">
        canvas是H5新增的图形绘制技术;
        canvas标签之间的所有内容都不会展示到页面上, 全程都是通过JS和H5API控制的;
        所以如果有些低版本浏览器不支持时, canvas标签中的内容才会显示出来;

        canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成：

        var canvas = document.getElementById('canvas');     获取canvas元素;

        var ctx = canvas.getContext('2d');                  获取canvas元素的上下文并指定图形类型(2d or 3d);

        canvas是画布, ctx(声明的类型上下文)可以理解为画笔, 之后的一切操作都是通过ctx这个画笔实现的;
        
        fillRect(x, y, width, height)                       绘制填充矩形;
        fillStyle = 'color'                                 声明填充;
        strokeRect(x, y, width, height)                     绘制描边矩形;
        strokeStyle = 'color'                               声明描边;
        clearRect(x, y, width, height)                      清除矩形;
        lineWidth = number                                  定义画笔宽度;
        arc(x,y, 半径, 开始角度, 结束角度, 顺时针/逆时针)         绘制圆形, false为顺时针, true为逆时针, 默认false(顺时针);
        
        
        渐变对象:
            线性渐变:
                var linearGradients = ctx.createLinearGradient(x1,y1,x2,y2);              声明渐变类型(参数规定起点x轴y轴和终点x轴y轴);
                                                                                        渐变色的参数声明x和y轴的范围多大是规定死的, 会收到受应用到的绘制区域限制;
                                                                                        所以一般这个参数根据Rect(绘制区域)的参数定义;
                ctx.strokeStyle = linearGradients.addColorStop(0, color);                 声明渐变颜色(0-1之间的数值, color);

            径向渐变:
                var radialGradients = ctx.createRadialGradient(x1,y1,r1, x2,y2,r2);          声明渐变类型(参数规定一个圆的(x,y,半径)和第二个圆的(x,y,半径));
                                                                                             同样声明的区域如果超出应用的绘制区域会不显示, 受限制;
                radialGradients.addColorStop(0, 'red');                                      声明渐变颜色(0-1之间的数值, color);
                
                
        
        绘制图片:
            var pattern = ctx.createPattern(img, 'repeat');                                       有这个方法,可以用于指定图片;
            ctx.fillStyle = pattern;                                                              填充图片;
            以上做个了解, 绘制图片经常用的是drawImage()方法;
            ctx.drawImage(img, x, y, widht, height);                                              绘制图片(这些参数用于绘制img整个图片);              
            ctx.drawImage(img, x, y, widht, height, x, y, width, height);                         绘制图片(后面这些参数用来指定绘制出来img整个图片的某个部分);
            ctx.clip();                                                                           剪裁图片


        绘制文字:
            ctx.font = 'weight style size family'                                               声明文字颜色规格(加粗,斜体,..,..);
            ctx.fillText('文字内容', x, y);                                                     绘制填充文字(内容, x, y);
            ctx.shadowColor = 'red';                                                              绘制阴影颜色;
            ctx.shadowBlur = num;                                                                 绘制阴影聚焦程度;
            ctx.shadowOffsetX = num;                                                              绘制阴影X轴位置;
            ctx.shadowOffsetY = num;                                                              绘制阴影Y轴位置;
                

        图像组合重叠:
            ctx.globalCompositeOperation                                                          定义新图像如何绘制到已有的图像上

                目标图像:
                    destination-over;                                                             重叠区域:目标图像覆盖源对象;
                    destination-atop;                                                             只显示和源对象重叠的部分和源图像整个部分;
                    destination-in;                                                               只显示和源对象重叠的部分;
                    destination-out;                                                              只显示目标图像部分;源图像和重叠部分不限时

                源图像:
                    source-over;                                                                  重叠:源图像覆盖目标对象;
                    source-atop;                                                                  只显示和目标对象重叠的部分和目标图像整个部分;
                    source-in;                                                                    只显示和目标对象重叠的部分;
                    source-in;                                                                    只显示源图像部分;目标图像和重叠部分不限时


            
        window.requestAnimationFrame(move);
            系统会结合硬软件配置, 来自定指定一种动画, 相比定时器和延时器可以手动定义执行时间的方法比起来, 这个方法执行时不会失真;
        


        

        水平全景滚动:
            ctx.translate(x,y);                                                                     定义偏移量;
            ctx.save();                                                                             保存当前环境的状态包括(颜色, 宽高, 坐标);
            ctx.restore();                                                                          返回之前保存过的路径状态和属性;
                save和restore的存储方式是栈存储的方式(既先存储后取得, 后存储先取得);
                
        
        图形的基本元素就是路径, 无论是矩形,圆形,三角形都是有一条条路径组成的;
            1.创建其实点;                                       beginPath();
            2.使用画图命令画出路径;                               moveTo(), lineTo();
            3.路径绘制结束后闭合路径;                             closePath();
            4.通过描边或填充的方式绘制图形;                        stroke(), fill();
        
        
            beginPath()                                     路径开始声明;
            moveTo(x,y)                                     指定开始落笔点;
            lineTo(x,y);                                    指定过程落笔点;
            closePath();                                    路径闭合声明;
            stroke();                                       描边声明;
            fill();                                         填充声明;
            

        
            
        
        
            
    </section>
</body>
</html>