<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="content" style="height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;"></div>
<script>
    let num = 1;
    let content = document.getElementById('content');

    function count() {
        content.innerHTML = num++;
    };
    content.onmousemove = count;



    // 防抖: 就是触发事件后,在n秒内函数只执行一次, 如果在n秒内又出发了该事件, 则会重新计算函数执行时间;
        // 1.防抖函数非立即执行版本
        // 非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
            
            // function debounce(fn, wait) {
            //     var timer;
            //     return function () {
            //         var context = this,
            //             arg = arguments;
                    
            //         if(timer) clearTimeout(timer);

            //         timer = setTimeout(function() {
            //             fn.apply(context, arg);
            //         },500);
            //     }
            // }

            // content.onmousemove = debounce(count, 300);

            
        // 2.防抖函数立即执行版
        // 立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。
            
            // function debounce(fn, wait) {
            //     var timer;
            //     return function () {
            //         var context = this,
            //             arg = arguments,
            //             callNow = !timer;
                    
            //         if(timer) clearTimeout(timer);
            //         var callNow = !timer;
            //         timer = setTimeout(() => {
            //             timer = null;
            //         }, wait);
            //         console.log(callNow);
            //         if (callNow) fn.apply(context, arg)
                    
            //     }
            // }

            // content.onmousemove = debounce(count, 300);
            
                
        // 3.防抖函数封装立执行和非立执行;

            /**
            * @desc 函数防抖
            * @param func 函数
            * @param wait 延迟执行毫秒数
            * @param immediate true 表立即执行，false 表非立即执行
            */

            // function debounce(fn, wait, type){
            //     var timer;
            //     return function () {
            //         var context = this,
            //             arg = arguments;
                    
            //         if(timer) clearTimeout(timer);
                    
            //         if(type) {
            //             // 立即执行;
            //             var callNow = !timer;
            //             timer = setTimeout(function () {
            //                 timer = null;
            //             },wait);

            //             if(callNow) fn.apply(context, arg);
                        
            //         } else {
            //             // 非立即执行;
            //             timer = setTimeout(function () {
            //                 fn.apply(context, arg);
            //             },wait);
            //         }
            //     }
            // }

            // content.onmousemove = debounce(count, 300, true);
            
            
            
            
    
    
    // 节流: 就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率
        // 1.函数节流时间戳版(立执行):
        // 持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次
            // function throttle(fn, wait) {
            //     let previous = 0;
            //     return function () {
            //         let now = Date.now(),
            //             context = this,
            //             arg = arguments;

            //         if(now - previous > wait) {
            //             fn.apply(context, arg);
            //             previous = now;
            //         } 
            //     }
            // }
            
            // content.onmousemove = throttle(count, 1000);
    
        
        // 2.函数节流定时器版本(非立执行):
        // 在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，才会执行最后一次; 
            // function throttle(fn, wait) {
            //     let timer;
            //     return function () {
            //         let context = this,
            //             arg = arguments;
                    
            //         if(!timer) {
            //             timer = setTimeout(function () {
            //                 timer = null;
            //                 fn.apply(context, arg);
            //             },wait);
            //         }
            //     }
            // }
            
            // content.onmousemove = throttle(count, 1000);
        

        // 3.函数节流封装时间戳版和定时器版;
            /**
            * @desc 函数节流
            * @param func 函数
            * @param wait 延迟执行毫秒数
            * @param type true 表时间戳版，false 表定时器版
            */

            // function throttle(func, wait ,type) {
            //     if(type){
            //         var previous = 0;
            //     } else {
            //         var timeout;
            //     }
            //     return function() {
            //         let context = this;
            //         let args = arguments;
            //         console.log(previous);
            //         if(type){
            //             let now = Date.now();
            //             if (now - previous > wait) {
            //                 func.apply(context, args);
            //                 previous = now;
            //             }
            //         } else {
            //             if (!timeout) {
            //                 timeout = setTimeout(() => {
            //                     timeout = null;
            //                     func.apply(context, args)
            //                 }, wait)
            //             }
            //         }
            //     }
            // }
            
            // content.onmousemove = throttle(count, 500, true);









        
</script>
</body>

</html>