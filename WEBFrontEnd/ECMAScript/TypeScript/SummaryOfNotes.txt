博学之, 审问之, 慎思之, 明辨之, 笃行之;
壹、贰、叁、肆、伍、陆、柒、捌、玖、拾;



壹.TS的安装/介绍/开发工具;
    TypeScript介绍:
        1.TypeScript 是由微软开发的一款开源的编程语言。

        2.TypeScript 是 Javascript 的超集，遵循最新的 ES6、Es5 规范。TypeScript 扩展了 JavaScript 的语法。

        3.TypeScript 更像后端 java、C#这样的面向对象语言，可以让 js 开发大型企业项目。 
        
        4.谷歌也在大力支持 Typescript 的推广，谷歌的 angular2.x+就是基于 Typescript 语法。 

        5.最新的 Vue 、React 也可以集成 TypeScript。

        6.Nodejs 框架 Nestjs、midway 中用的就是 TypeScript 语法。

    TypeScript安装和编译;
        
        npm install -g typescript
        tsc -v
        
        浏览器不能识别TS就先ES6那样, 需要编译识别;
        解析编译ts文件命令:
        tsc index.ts
        编译成功后就会在同级目录下生成index.js文件;
        


        tsc --init
        生成stconfig.json文件进行配置文件中的 outDir就是输出目录, 配置为./js/
        当编译完成之后就会输出js文件夹下的同名js文件;
        然后, terminal > run task > typescript > tsc:watch选择
        此时, 当保存ts文件后, 就会自动编译到outDir的指定路径下;
        

        













贰.TS中的数据类型;
    
    TypeScript为了使编写的代码更规范, 更利于维护, 增加了类型校验, 在TypeScript中主要给我们以下数据类型;
        布尔类型(boolean)
        数字类型(number)
        字符串类型(string)
        数组类型(array)
        元组类型(tuple)
        枚举类型(enum)
        任意类型(any)
        null和undefined
        void类型
        never类型

        
    布尔类型(boolean)
        true
        false

        var flag:boolean = true;
        被定义为boolean则 flag只能是布尔类型的值, 否则会报错
        flag = 'asdf'   报错;
        flag = false    可以;

        
        
    数字类型(number)
        var num:number = 123;

    字符串类型(string)
        var str:string = 'hello world';
    
    数组类型(array)
        TypeScript中定义的数组中不可以包含多个数据类型: 比如:
        ['asdf', 123, false, null, undefined]这种在TS中是不允许的;
        TS只支持两种方式定义数组;
            1.第一个定义数组方式;
                let arr:number[] = [1,2,3,5,6];
                这样定义arr中只能存放number类型, 如果放置string同样报错;
            
                let arr:string[] = ['trump', 'obama', 'clinton', 'lincoln', 'george'];
                和num同理, 声明数组中是什么类型就是什么类型, 否则将会报错;
            
            2.第二种定义数组方式;
                
                let arr:Array<number> = [1,2,3,44,5555,88];
                这种定义的方式是一种泛型定义;

                let arr:Array<string> = ['trump', 'obama', 'clinton', 'lincoln', 'george'];
                同理;

    元组类型(tuple) 属于数组的一种;
        let arr:[string, number, boolean] = ['123', 3.1415926, true];
        所谓的元组就是可以给数组中的每一位分别指定是什么类型;

    
    枚举类型(enum)
        enum flag1 {
            success = 1,
            error = -1,
        }
        var f:flag1 = flag1.success;
        console.log(f);
        此时输出为1;

        enum color {red, blue, orange};
        var result1:color = color.red;
        var result2:color = color.blue;
        var result3:color = color.orange;
        console.log(result1, result2, result3);
        如果在枚举中没有指定个具体值, 将会指向索引;
        此时输出为 (0, 1, 2);
    
        enum color {red, blue=5, orange};
        var result1:color = color.red;
        var result2:color = color.blue;
        var result3:color = color.orange;
        console.log(result1, result2, result3);
        如果在枚举中声明了某一个值的具体值, 那么其后面的值,将会根据它的值往后类推;
        比如设置blue为5; 此时orange就是6, 不再是索引值2;
        输出为: (0, 5, 6);
        
        
        
        
        
    任意类型(any)
        var any:any = 'asdf';
        var num1:any = 123;
        var flag2:any = false;
        任意类型最好理解, 可以将声明的值赋值为任何类型, 好比JS中的值声明;
        获取一个DOM对象时指定any 不会警告语法错误;
        
    
    null和undefined

        var num:number;
        console.log(num);
        
        var num2:number | undefined;
        console.log(num2);
        
        之前版本TS声明变量如果指定类型但是不指定值, 那么默认类型就是undefined, 此时同样有语法错误;
        我们可以在指定类型时, 做个或条件比如: var num2:number | undefined;
        那么即使num2没有声明值也就是为undefined也不会有语法错误;


    
    void类型
        表示一个没有返回值(返回任何类型)的一个函数;
        function run():void {
            console.log('run');
        }
        run();


        如果函数有返回值可以在()后面声明返回值类型, 当然不声明也不会有警告错误;
        var num4 = function num4():number {
            return 123;
        }
    

    
    never类型

        never类型: 其他类型(包括null 和 undefined类型);
        代表从不会出现的值, 这意味着声明never变量只能被never类型所赋值;
    
            var never:never;
            
            never = (() => {
                throw new Error('error');
            })();
        
        匿名自执行函数就属于不会出现的值;



















叁.TS中的函数
    ES函数的定义:
        函数声明:
            function test() {
                return 'run';
            }
        匿名函数:
            var test = function () {
                
            }

    
    TS中函数定义:
        函数声明:
        TS中的函数声明就是在()后加上一个指定函数返回类型的值;
            function fun():string {
                return '123';
            }

        匿名函数
            var fun = function ():number{
                return 123;
            }


    TS中定义方法传参;
        TS定义函数不仅要指定返回值的类型, 还要指定参数的类型;
        function getInfo(name:string, age:number):string{
            return '${name} --- ${age}';
        }

        var getInfo1 = function (name:string, age:number):string{
            return `${name} --- ${age}`;
        }
        alert(getInfo('张三', 20));




    可选参数;
        ES5中的实参和形参可以不同, 但是TS中必须相同, 如果不同就需要配置可选参数;
        执行时如果不传age会有语法错误, 那么此时就需要指定age这个参数为可选参数 age后面加个问好即可(age?:number);
        同时还需注意可选参数必须配置到最后面, 如下示例name就不能成为可选参数; 只能age这个最后位的形参可以是可选参数;
        function getInfo2(name:string, age?:number):string{
            if(age){
                return `${name} --- ${age}`;
            }else{
                return `${name} --- 年龄保密`;
            }
        }
        console.log(getInfo2('张三'));






    默认参数;
        ES5中无法设置默认参数, TS中必须设置默认参数;
        默认参数就是可在形参中指定一个值, 指定后实参可以不传, 而使用默认指定的值
        function getInfo3(name:string, age:number=20):string{
            if(age){
                return `${name} --- ${age}`;
            }else{
                return `${name} --- 年龄保密`;
            }
        }
        console.log(getInfo3('张三'));





    剩余参数(三点运算符);

        三点运算符
        function sum(...result:number[]):number {
            var sum = 0;

            result.forEach(function (item, ind) {
                sum += item;
            })
            return sum;
        }
        console.log(sum(1,2,3,4))

        剩余参数
        function sum1(a:number, b:number,...result:number[]):number {
            var sum = a + b;

            result.forEach(function (item, ind) {
                sum += item;
            })
            return sum;
        }
        console.log(sum1(1,2,3,4))





    函数重载;
        JavaScript是一个面向过程的语言, 是没有重载的概念;
        Java中的重载: 指的是两个或者两个以上同名函数, 但他们的参数不同, 这时就会出现函数重载的情况;
        Typescript中的重载: 通过为同一个函数提供多个参数类型定义来实现多种功能的目的;
            白话就是: 同名的函数传入不同得到参数来实现得到不同的结果;
            但是JS中如果出现同名的函数, 后面的会将前面的同名函数覆盖掉;
        TS为了兼容JS, 所以TS重载的写法与Java有区别; 
        
    
        以下是函数重载;
        function getInfo4(name:string):string;
        function getInfo4(age:number):number;
        执行时的实参只读重载函数的形参类型声明, 实际函数体的形参类型声明不会在执行时应该用到;
        也就是说, 函数体是any, 但是函数重载限定是string或number, 那么就只能是重载函数限定的string和number两个参数类型,
        函数体的any不会对执行时传入的实参生效, :any限定的是重载函数的形参类型声明;
        
        function getInfo4(str:any):any{
            if(typeof str == 'string'){
                return `我叫:${str}`;
            }else{
                return `我的年龄是:${str}`;
            }
        }
        
        console.log(getInfo4('张三'));
        console.log(getInfo4(20));
        
        传入true就会报错, 因为在重载的方法中,没有声明参数为boolean的函数;
        console.log(getInfo4(true));





    箭头函数;
        箭头函数中的this指向上下文;
        setTimeout(function () {
            console.log('ES5');
        },1000);


        setTimeout(():any => {
            console.log('Arrow');
        },1000);

        














肆.ES中的类;
    请看04章节, 回顾ES中的类, 为TS中的类学习做个铺垫;















伍.TS中的类
    类的定义
        class Person {
            公共属性;
            public name:string;
            构造函数;
            constructor(name:string) {
                this.name = name;
            }

            实例方法
            run() {
                return `实例方法输出: ${this.name}在运动`;
            }
            
        }





    继承

        class Animal {
            声明的公共属性可以省略public关键字;
            public name:string;
            name:string;
            constructor(name:string) {
                this.name = name;
            }


            eat() {
                return `Animal 的eat方法`;
            }
        }


        class Dog extends Animal{
            继承必须添加super关键字;
            constructor(name:string) {
                super步骤会将name的操作继承过来: this.name = name;
                super(name);
            }
            eat() {
                return `${this.name}吃杂粮`;
            }
        }

        console.log(new Dog('jerry').eat());







    静态属性, 静态方法

        定义Person类;
        class Person {
            公共属性;
            public name:string;
            构造函数;
            constructor(name:string) {
                this.name = name;
            }

            实例方法
            run() {
                return `实例方法输出: ${this.name}在运动`;
            }
            eat() {
                return `实例方法输出: ${this.name}在吃饭`;
            }

            静态属性;
            static age:number = 30;
            static petname:string = 'nixon';
            静态方法;
            静态方法中无法直接调用类中的属性, 静态方法中只能调用静态的属性;
            static print() {
                return `静态方法输出: ${Person.petname}的年龄是${Person.age}`;
            }
            
        }

        
        var person = new Person('hilarie');
        实例方法调用;
        console.log(person.run());
        静态方法调用;
        console.log(Person.print());

    

    
        
        

    抽象类, 
        抽象类概念: 他是提供其他类继承的基类, 不能直接被实例化;
        用abstract关键字定义抽象类和抽象方法, 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现;
        abstract抽象方法只能放在抽象类中, 抽象类和抽象方法用来定义标准;

        抽象类Animal 要求他的子类必须包含eat方法, 如果不实现抽象类中的抽象方法就会报错;
        abstract class Animal{

            public name:string;
            constructor(name:string) {
                this.name = name;
            }

            这个抽象方法不包含具体实现(就是没有花括号{}函数体);
            必须在派生类中实现, 否则将会报错;
            abstract eat():any;
            
        }

        抽象类不能直接实例化: Cannot create an instance of an abstract class;
        var animal = new Animal('father');
        

        class Dog extends Animal{
            constructor(name:string) {
                super(name);
            }

            因为继承的是Animal这个抽象类, 所以eat这个抽象方法必须要实现;
            eat() {
                return `${this.name}吃粮食`;
            }

            run因为不是抽象方法, 所以也可不实现这个方法, 但是抽象类中定义的抽象方法一定要实现
            run() {
                return `抽象类中定义的抽象方法一定要实现`;
            }
            
        }

        console.log(new Dog('John').eat());
    
    
    
    
    
    
    

    继承多态;

        多态概念: 父类定义的方法不去实现, 让继承他的子类去实现, 每一个子类有不同的实现;
        多态属于继承, 是继承的一种表现;
        class Animal {

            声明的公共属性可以省略public关键字;
            public name:string;
            name:string;
            constructor(name:string) {
                this.name = name;
            }


            在父类中具体是什么动物, 吃什么, 都不明确;
            所以让继承Animal父类的Dog和Cat实现定义具体是什么动物, 吃的是什么;
            eat() {
                return `Animal 的eat方法`;
            }
        }


        class Dog extends Animal{

            继承必须添加super关键字;
            constructor(name:string) {
                super步骤会将name的操作继承过来: this.name = name;
                super(name);
            }
            
            eat() {
                return `${this.name}吃杂粮`;
            }
            
        }


        class Cat extends Animal{
            constructor(name:string) {
                super(name);
            }

            eat():string {
                return `${this.name}吃老鼠`;
            }
        }

        console.log(new Dog('jerry').eat());
        console.log(new Cat('tom').eat())
    
    

        












陆.TS中的属性类接口;

    TS中的接口类型如下:

        1.属性类接口;

        2.函数类型接口;

        3.可索引接口;

        4.类类型接口;

        5.接口扩展;



    接口的作用:  在面向对象编程中, 接口是一种规范的定义, 它定义了行为和动作的规范, 在程序设计中, 接口起到了一种限制和规范的作用;
    TS中的接口类似于Java, 同时还增加了更灵活的接口类型; 包括属性, 函数, 可索引和类等;
    接口也是定义标准的, 只不过比起抽象类的范围更加广泛;

    属性类接口;

        属性接口 就是对JSON的约束;
        function printLabel(labelInfo:{label:string}):void {
            console.log('printLabel');        
        }

        错误, 因为形参中规定的JSON的键是label;
        printLabel({name: '张三'});
        正确;
        printLabel({label: '张三'});





        对批量方法传入参数进行约束;
        接口: 行为和动作的规范, 对批量方法的约束;
        interface关键字定义接口;

        定义属性接口, 定义的键值中一定是以分号结尾, 并不是JOSN中的逗号结尾;
        一旦接口中定义了, 就是一定要还传入的, 除非用?可选参数来指定当前属性为可选的, 在应用中就可以不传入;
        interface FullName {
            firstName:string;
            secondName?:string;
        }
        
        function printName(name:FullName):void {
            传入的name这个形参必须是对象, 对象中必须有 firstName 和 secondName, 并且必须是string类型;
            这个name必须是:FullName, 就相当label必须是:string, 而这个FullName接口是自己定义的, string是系统定义的;
            console.log(`${name.firstName} === ${name.secondName}`);
            并且, 如果不安装接口定义的内容走, 比如加了一个age, 虽然实参的对象有age属性, 但是还是会报错,
            所以, 声明接口就必须要严格按照接口声明的内容走;
            console.log(`${name.firstName} === ${name.secondName} === ${name.age}`);
        }

        这样写age会报错;
        printName({
            firstName: '张',
            secondName: '三',
            age: 20,
        })
        所以推荐以下写法, 可以避免这种错误;
        var obj = {
            firstName: '张',
            secondName: '三',
            age: 20,
        };
        printName(obj);

    














柒.函数类型接口;
    函数类型接口: 对方法传入的参数, 以及返回值进行约束, 并且可批量约束(就是可以对多个方法进行约束);

    加密的函数类型接口:

    interface encrypt{
        传入两个参数分别是key和value都是string类型, 并且返回的也是string类型;
        (key:string, value:string):string;
    }

    var md5:encrypt = function (key:string, value:string):string {
        return key + value;
    }

    console.log(md5('name', 'zhangsan'));

    var sha1:encrypt = function (key:string,value:string):string {
        return key + '===' + value;
    }
    console.log(sha1('name', 'leecs'))













