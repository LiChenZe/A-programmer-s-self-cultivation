博学之, 审问之, 慎思之, 明辨之, 笃行之;
壹、贰、叁、肆、伍、陆、柒、捌、玖、拾;

壹.JavaScript浏览器发展史

    web发展史
        Mosaic, 是互联网历史上第一个获普遍使用和能够显示图片的网页浏览器. 于1993年问世;
        
        1994年4月, 马克.安德森和Silicon Graphics (简称为SGI, 中译为'视算科技'和'硅图') 
        公司的创始人 吉姆.克拉克(jim Clark) 在美国加州设立了"Mosaic Communication Corporation".
        Mosaic 公司成立后,由于伊利诺大学拥有Mosaic的商标权,且伊利诺大学已将技术转让给 'Say Glass'公司,
        开发团队必须彻底撰写浏览器程式码,且浏览器名称更改为 'Netscape Navigator', 公司名字于1994年11月改名为 'Netscape Communication Corporation'.
        此后沿用至今,中译为'网景'.微软的Internet Explorer'以及 'Mozilla firefox'等等,其早期版本皆以Mosaic为基础开发.
        微软随后买下 'Spy Glass'公司的技术开发出'Internet Explorer' 浏览器, 而mozill firefox 则是网景通讯家开放源代码后所衍生出的版本;
        
        现在很多大型浏览器的源头都是 Mosaic的基础上开发的 可以理解为是他们的第一个版本 第一个雏形;
    
    JavaScript 发展史
        JavaScript作为Netspace Navigator 浏览器的一部分首次出现在1996年. 
        他的设计初衷是改善网页的用户体验;

        作者是: Brendan Eich
        
        期初: JavaScript被命名为 LiveScript, 后来因为和Sun公司合作,因市场宣传需要改名为 JavaScript.
        后来Sun公司被Oracle公司收购, JavaScript版权归Oracle所有;
        
        浏览器组成:
            1.shell部分:
                (外壳) 部分 就是用户能操作的部分被称为shell(外壳部分);
                包括: 文件,修改,试图,历史记录,书签,窗口,帮助,设置等等...

            2.内核部分:
                渲染引擎(语法规则和渲染);

                JS引擎(JavaScript的渲染);

                    JS的特点:
                        1.JavaScript 是一种解释性语言;
                            系统只认识机械码  所以js代码需要编译成机械码来供浏览器解析;
                            编译语言:(java先通篇翻译,翻译完了的结果为一个class文件,然后解析整个文件);
                                c,c++,
                                优点:
                                    通篇编译就会快
                                不足:
                                    因为是整篇解析所以移植性不好(不跨平台{windows下面编译的.exe 文件在linux下不能用});


                            java 既不是解释性语言也不是编译性语言;
                            .java文件通过一个javac的指令编译成.class文件在通过java虚拟机jvm解释执行;
                            .java ==> javac ==> 编译 ==> .class ==> jvm ==> 解释执行;

                            
                            解释性语言:(读取一行,翻译一行,执行一行,不生成特定的文件);
                                JavaScript,python,PHP,
                                优点:
                                    因为是解释性语言,不需要生成编译文件所以能够跨平台;
                                不足:
                                    浏览器解析因为是一行一行的读取,所以会稍微慢一点;

                        2.JS引擎是单线程,同步.
                            JS执行队列:
                            task1,1ms <== task2,1ms <== task3,1.ms <== task4,1ms <== task5,1ms;
                            轮转时间片;
                        
                    JS引擎发展历史:
                        2001年发布IE6,首次实现对js引擎的优化和分离;
                        
                        2008年谷歌发布最新浏览器chrome,他是采用优化后的JavaScript的引擎,引擎代号v8,
                        因能直接把JavaScript转换成010100101二进制的机械码来执行,进而以速度快而闻名
                        
                        后来firefox也推出了具备强大功能的JS引擎;

                        firefox 3.5 TraceMonkey(对频繁操作的代码做了路径优化);
                        
                        firefox 4.0 leagerMonkey

                        ECMA(European Computer Manufacturers Association)欧洲计算机制造商协会;
                            ECMA ==== 标准 为了取得技术优势,微软推出了JScript,CEnvi推出ScriptEase,
                            与JavaScript同样可在浏览器上运行;为了统一规格;JavaScript兼容于ECMA标准,
                            因为也成为ECMAScript.更专业的称呼;
                            
                            JavaScript 经历了很长时间的变化,刚开始很简陋,后来推出了DOM,和BOM部分;
                                ECMAScript
                                    是JS最原始的一些东西;
                                DOM
                                    操作文档元素的html,css;
                                BOM
                                    操作浏览器的;
                            
                其他模块
                    
                浏览器内核:
                    主流浏览器:(在市场上有一定的市场份额,必须有独立研发的内核);
                        IE:                             Trident
                        Chrome:                         WebKit/Blink
                        FireFox:                        Gecko
                        Opera:                          Presto
                        Safari:                         Webkit


贰.JS介绍,入门,js引入,变量,值类型,运算符;
    1.引入方式: 
        1.页面内嵌
            <script type='text/javascript'> type='tpl' 这样的script可以当一个库存来用;后期有方式能把他取出来;
                Code.....
            </script>
        2.外部引入
            <script type='text/javascript' src='location'></script>
            如果外部引入的方式那么在标签内写代码不会执行的;
        tip:
            为了符合web标准(w3c)标准中的一项, 结构,样式,行为相分离,通常会采用外部引入的js文件;
        
        3.JS注释:
            行注释:    // 
            段落注释:  /** */
        
    html和css 不能叫做编程语言:编程语言特点:有变量,函数,有数据解构,可以进行计算;
    html和css 属于计算机脚本语言;计算机语言的一个小门类;
    
    2.命名规则:
        1.变量名必须一以英文字母,_,$开头;
        2.变量名可以包括英文字母,_,$,数字;
        3.不可以使用系统的关键字,保留字作为变量名;
            关键字:(指在语言中有特定的含义,成为语法中的一部分)
                break,else,new,var,case,finally,return,void,catch,for,switch,while,default,with,this,
                if,throw,delete,in,try,do,instanceof,typeof,function,continue...
            保留字:(指这些字在以后可能会得到应用);
                abstract,enum,int,short,boolean,export,interface,static,byte,extends,long,super,
                char,final,native,synchronized,class,float,package,throws,const,goto,private,transent,
                debugger,implements,protected,volatile.......
    
    3.值,数据类型;分为两大类型;
        1.原始值(分为五大类);
            Number,Boolean,String,Undefined,Null;
                undefined
                    var a = undefined;
                    如果var a; 没有赋值的话就会打印undefined 这是个系统的默认值; 告诉开发者 声明了a但是没有定义没有赋值;
                    var a = null;
                null
                    null 和 undefined 是不一样的 null是一种占位的; 
                    比如: 写一个方法,把这个方法赋值到一个变量fn里面; 忽然有一天这个变量fn里面不应该装这个方法了, 是删不掉的
                    可以用123覆盖等等.. 但是最好使用fn = null 来覆盖掉; 一个空值来覆盖以便以后在利用; 
                String:
                    var str = '123';
                    str[0] 结果是1 能取出来;
                    因为JavaScript中字符串的底层也是基于数组的;
                Boolean:

                Number:
                
        2.引用值
            Array,Object,function...date,RegExp;
        
        原始值和引用值解释:
            原始值:(A值赋到B值里面去,更改A值后B值不会改变); 
                原始值是存在栈内存中的;
            引用值:(arr值赋到arr1值里面去,更改arr值,arr1值跟着变更);
                引用值是存在堆内存中的;
        




        原始值是存在栈内存中的,栈内存中的值是拷贝的关系;拷贝,拷贝,拷贝重要的事情说三遍...;

            var a = 10;
            var b = a;
            a = 20;            
            a 栈内存 ==> 10;
            b 栈内存 ==> a栈内存 ==> 10;
            a 栈内存 ==> 20;
            b 栈内存 ==> 10;
            a 的值 第一次是10, b 的值 是 a 的值;
            那么b 是 10; a 再次赋值成为20; 这个时候b还是10;
            
                        stack(栈内存)                                  heap(堆内存);
                a       20                                       1001                                             
                b       10                                       1002    
                1009    文本                                     1003    
                1008                                             1004    
                1007                                             1005    
                1006                                             1006    
                1005                                             1007    
                1004                                             1008    
                1003                                             1009    
                1002                                             1010    
                1001                                             1011    
                

            



        引用值是存在堆内存中的,栈内存中是拷贝关系;但是拷贝的堆内存的地址;
            
            var arr = [1,2];
            var arr1 = arr;
            arr.push(3);
            arr存储在栈内存中时候浏览器解析时,解析到是引用值时,
            会把变量名arr放到栈内存中; 把值放到堆内存中;
            arr和arr 变量的栈内存指向的是同一个堆内存空间;
            所以说arr 变化的时候堆内存的地址是不变的;arr1也就还指向堆内存的那个地址;
            改变的仍然还是栈内存;
            
            var arr = [1,2];
            var arr1 = arr;
            arr = [1,3];
            这个时候这个arr1就是[1,2],因为这是重新赋值 开启了一个新的堆内存;
            arr 栈内存 ==> heap(1001) ==> [1,2];
            arr1 栈内存 ==> heap(1001) ==> [1,2];
            arr 栈内存 ==> heap(1002) ==> [1,3];
            arr1 栈内存 ==> heap(1001) ==> [1,2];
            
                stack(栈内存)                                             heap(堆内存);
                    arr     heap(1001)                              1001    [1,2,3]                                             
                    arr1    heap(1001)                              1002    
                    1009    文本                                     1003    
                    1008                                             1004    
                    1007                                             1005    
                    1006                                             1006    
                    1005                                             1007    
                    1004                                             1008    
                    1003                                             1009    
                    1002                                             1010    
                    1001                                             1011  



            总结: 
                引用值和原始值的不同是赋值形式的不同;
                原始值有个特点叫做: 栈内存中不可改变的原始值;(栈内存的值只要存进去就不会改变了)
                
                如果var num = 100; 栈内存会有一个变量num 存储一个100;
                num1 = num 的时候; num1 就是num 的值 100;
                num = 200 的时候真正的就会开启一个新的内存空间 这个空间就是 200
                而原来 等于 100 的空间命名就不是num了 就是野空间(1010)了 但是这个1010的栈内存空间的值 还都存在 还是num遗留的100;
                这就是 不可改变的原始值; 

            
    4.基本语法: 
        JS语句基本规则;
            语句后面要用分号结束;
                浏览器解析可并不会看一行执行一行 他是看分号
                一个分号表示一段代码的结束;
                以下除外:
                    function fn(){}
                    for(){}
                    if(){}
                    函数,for循环,if判断这些可以不需要加分号;
            
            js语法错误会引发后续代码终止执行,但不会影响其他代码块;   
                错误分成两种:
                    1.低级错误(语法解析错误);(SyntaxError);
                        JS解释性语言 读一行执行一行;
                        但是在进行解释执行之前 他会通篇的扫描语法错误;
                        如果大体扫描有低级错误(语法错误); 那么程序就一行都不会执行;
                        还没到解释执行的部分就会终止;
                    2.逻辑错误(标准错误,情有可原);(ReferenceError);
                        在这个逻辑的引用错误之前都会执行
                        但是解释一行执行一行的时候读取到这行的错误的时候;
                        前面的代码能够正常执行,这个引用错误之后的代码就都不会执行了;
                    3.不会影响其他的代码块
                        就是指其他的外链的(script src指定的js) 都还会执行;
            书写格式要规范, '= - * / +' 加减乘除赋值判断等等操作都要有空格;
            


    5.JS运算符:
        1.'+';
            第一点作用数学运算,
            第二点作用字符串连接;
            任何数据类型加上字符串都等于字符串;

            运算时完全符合数学的运算规则,从左到右开始计算
            var a = 1 + 1 + 'a' + 1 + 1;
            结果是 2a11;
            
        2.'-', '*', '/', '%', '=', '()';
            var a = 0 / 0; 
            结果是 NaN;
            
            var a = 1 / 0;
            结果是Infinity;

            var a = -1 / 0;
            结果是-Infinity;

            var a = 1 / -0;
            结果是-Infinity;

            var a = 1 % 0;
            结果是NaN;

            var a = 5 % 2;
            结果是1;(五除以二商二余一);

            var a = 5 % 3;
            结果是2;(五除以三商一余二);

            var a = 4 % 6;
            结果是0;(四除以六商零余四);
            
            () 表示括号  优先级最高
            =  表示赋值; 优先级最弱;
            == 表示相等;
            === 表示全等;
        
        3.'++', '--', '+=', '-=', '/=', '*=', '%=';

            var a = 10;
            var b = 10;
            a = b + 1; 可以简化为 a++;
            a++ 等于 a = a + 1;
            a-- 等于 a = a - 1;
            
            a++ 和 a-- 的++和--可以放到前面也可以放到后面;(++a可以,a++也可以);
            
            a++ 和 ++a 的区别在于:
            ++在后 先执行语句后加加;      docuemnt.write(a++)  结果a是10;
            ++在前 先加加后执行语句;      document.write(++a)  结果a是11;
            
            
            a += 10 等于 a = a + 10;
            a -= 10 等于 a = a - 10;
            a *= 10 等于 a = a * 10;
            a /= 10 等于 a = a / 10;
            a %= 10 等于 a = a % 10;
            
            
            var a = 123;
            var b = 234;
            
            请替换AB的值;
            
            第一种方式
            var c = a;
            a = b;
            b = c;
            
            第二种方式;
            a = a + b;
            b = a - b;
            a = a - b;

叁.JS运算符,条件,循环语句;
    JS 任何运算符都是为了求结果; 包括'&&', '||', '!';
    比较运算符: 
        '<' 小于
        '>' 大于
            字符串对比的是阿斯克码(ASCII);
        '=='    等于   (NaN这个非数不等于任何东西包括自己)
        '==='   全等
        '<='    小等于
        '>='    大等于
        '!='    非等
    逻辑运算符:
        '&&'    与运算符    (顺口溜: 全真才为真,有一个假就为假是一个片面的意思 以下解答);
            var a = 1 && 2;
            与运算符一定会返回结果的; 
            与运算符会先看第一个表达式转换成布尔值的结果, 如果结果为真, 就会看 && 后面的表达式转换成布尔值的结果;
            如果 && 前后的某一个值转换为布尔值为false的时候, 就会将其会转换为false的值返回,
            如果 && 后面的值转换成布尔值都是true的时候, 就会返回最后一个 && 后的值;
            && 遇见转换成布尔为false的值就会被返回其值,否则就一直往后看
            
            扩展: 除了以下的六个值, 其他值转换为布尔都得true;
            undefined, null, NaN, '', 0, false      ==>     false
            
            不用返回值, 就可以当一种短路语句使用; 
            2 > 1 && document.write('leecs');   (如果 二大于一 就执行 后面的语句);

            判断有没有data 有就执行后面的语句;(工作中大量这样的写法);
            data && fn(data);   (见第三章);
            function fn(param){
                document.write(param.name + '的年龄是' + param.age);
            }

            var num = 1 & 3;    结果是1;
            这种成单的 & 运算符 比较的是进制数;
            
            
        '||'    或运算符    (全假才为家,有一个真就为真);
            或运算符和与运算符规则相反; 
            与运算符遇到false就返回;一直没有就返回最后一位;
            而或运算符遇到布尔值为true的就会返回,如果没有true 就会一直向后查找转换成布尔为true的值
            如果没有true就会返回最后一位布尔为false的值;
        '!'     非运算符
            ! 就是否的意思;
            ! 有个功能就是: 不论是什么数据类型的值前面加上 ! 就会把这个东西转换成布尔值再取反;
            
            !! 可以直接代替Boolean() 进行转换为布尔值;
        
        ',' 逗号操作符
            var a = (2,3);      返回3;
            var a = (1,2,34,5,6,7,8,9,0,+1,-1);         返回-1;
            逗号操作符, 始终会返回, 最后一位的结果, 如果有加减乘除运算就运算完成结果返回;
            
                var a = (
                    function f() {
                        return '1';
                    },
                    function j() {
                        return 2;
                    }
                ());
                console.log(f);
                
                逗号操作符返回最后一位, 结果就是:
                    
                var a = function j () {
                            return 2;
                        }();
                console.log(f);

        
    条件语句:
        if() else if (){}: 条件语句;
            
            if 后面的中括号里的条件 不管是值还是一个表达式 都会转换成 布尔值;
            这个布尔值如果是true 就会执行 {} 里面的语句; 如果为false 就不会执行;
            
            if(条件){
                
            }

            if条件判断有一个条件叫做互斥性 : 满足一个条件就不会往后看了;
            既然条件都具有了互斥性 全是 if() 就会浪费性能;所以 else if 是最好的写法;
            
            if(条件){
                这样写是省效率的;
            }else if(条件){
                这样写是省效率的;
            }

            但是如果条件和条件之间有交叉点的时候 就不能用 else if 
            else if满足的条件 必须是条件和条件之间是互斥的 不满足了条件1 就一定能满足条件2 才适用else if;
            除了 这个if (条件) 以外的情况 else 后面直接一个花括号判断 就是除了条件以外的任何情况;
            
            if(1 < 2) {document.write('sss')}
            和短路语句互相转换为:
            1 < 2 && document.write('sss');

        
        for() 循环语句
            for(var i = 0; i < 10; i++){document.write('sss')}
            
            解析:
                第一步: 先var i = 0;  (这一步只会执行一次!!!);
                第二步: if(i < 10){ document.write('sss') };
                第三部: i++;   ==>     i = 1;
                第四步: if(i < 10){ document.write('sss') };
                第五步: i++;   ==>     i = 2;
                第六步: if(i < 10){ document.write('sss') };
                第七步: i++    ==>     i = 3;
                第八步: ..............
                第N步: i++    ==>     i == 10;
                第N+1步: if(i < 10){ document.write('sss') };
                这个时候i 已经是 10了 所以条件 i < 10 已经不成立了就会终止执行;
                也就是说 for() 循环体 会执行到 if的条件 不成立 就会停止;
                再进一步地说 for() 就是一个条件判断; 相当于if() 但是有本质的区别;
                
            for循环也可以这样写
                第一种:
                    var i = 0;
                    for(; i < 10; ){    (i < 10; 之前的; 是必须加的 不加会有语法错误);
                        document.write('ss');
                        i++;
                    }

                第二种:
                    var i = 0;
                    var count = 0;
                    for(; i ; ){
                        document.write('ss');
                        count++;
                        if(count == 10){
                            i = 0;
                        }
                    }


            for() 循环每次都会执行循环体里面的东西,所以可以抓取里面的很多东西;
            思维拓展:
            
            var i = 100;
            for (; i--;){   for() 中如果到了0 就自动不执行了; 所以不需要一个出口规则;
                document.write(i);
            }
            
            
        while() 
            for(; ;) 里面不写东西就是while循环;
            while循环就是for循环的简化版;

            以下的例子 for循环和while循环是全等的;
                var i = 0;
                
                for(; i < 10;){
                    console.log(i);
                }
                
                while(i < 10){
                    console.log(i);
                }

            while() 中是条件判断如果成立就会无限循环;
            如果while(true){
                如果条件成立的话 就会一直循环和for() 是一样的; 
            }

            
        do while循环
            do{}花括号里面的代码要执行的时候就得要看while()里面的条件是否成立;
            如果while的条件开始就是false do{}的代码也要至少执行一次;
            
            do{
                document.write('ss');
            }while(true);
        

肆.条件语句补充,初始引用值;
    试题补充
        1.计算2的n次幂,n可输入,n为自然数;
            var n = parseInt(window.prompt('input')),i = 0,mul = 1;
            while(i < n){
                console.log(2 ** n);
                i ++;
            }
            
            while(i < n){
                console.log(mul *= 2);
                i++;
            }
        2.计算n的阶乘,n可输入;
            var n = parseInt(window.prompt('input')),i = 1,mul = 1;
            
            while(i <= n){
                mul *= i;
                i++;
                console.log(mul);
            }

        3.著名的斐波那契数列 计算出第n项;

            f    s   t
            1    1   2   3   5   8   13  21
                 f   s   t
            var n = parseInt(window.prompt('input')),
                first = 1,
                second = 1,
                third,
                i = 0,
                mul = 1;
            if(n >= 3){
                while(i < n - 2){
                    third = first + second;
                    first = second;
                    second = third;                
                    console.log(third);
                    i++;
                }
            }else{
                console.log(1);
            }
        

        4.编写一个程序, 输入一个三位数的正整数, 输出是反向输出, 比如输入: 456, 输出: 654;
        
        5.输入a,b,c,三个数中最大的是数;
            var a = parseInt(window.prompt('input')),
                b = parseInt(window.prompt('input')),
                c = parseInt(window.prompt('input'));
            
            if(a > b){
                if(a > c){
                    console.log(a);
                }else{
                    console.log(c);
                }
            }else{
                if(b > c){
                    console.log(b);
                }else{
                    console.log(c);
                }
            }
        6.打印出100以内的质数;
            var mul = 0;
            for(var i = 1; i <= 100; i ++){

                for(var n = 1; n <= i; n++){
                    if(i % n == 0){
                        mul++;
                    }
                }
                if(mul == 2){
                    console.log(i);
                }
                mul = 0;
            }



    1.switch case();
        if() 里面放的是条件判断;
        switch() 里面放的是条件;  case后面放的是判断; 这个判断可以是任何数据类型; Boolean,string,number,[]....等等;
        case的判断只能相对于switch中的条件而言进行匹配  判断; 不能对比加减等任何操作;
        
            var n = parseInt(window.prompt('input'));
            switch (n){
                case 1:
                    console.log('a');
                case 2:
                    console.log('b');
                case 3:
                    console.log('c');
            }

        但是有switch 有个特点;
        如果这个n是1的话 case 2和3的情况也会被执行;
        也就是说他会继续往后执行; 不管情况会不会被匹配;
        (不匹配执行,匹配了后面的都执行);
        
        避免这种情况的方法就是加上 break 用来和switch 语句一起使用;
        意思就是 如果符合我这个条件打断 不往后执行了;



            var date = (window.prompt('input'));

            switch (date) {
                case 'monday':
                    console.log('working');
                    break;
                case 'tuesday':
                    console.log('working');
                    break;
                case 'wednesday':
                    console.log('working');
                    break;
                case 'thursday':
                    console.log('working');
                    break;
                case 'friday':
                    console.log('working');
                    break;
                case '周六':
                    console.log('relaxing');
                    break;
                case '周日':
                    console.log('relaxing');
                    break;
            }

        以下是switch的特性用处 匹配往下走,直到遇到break为止;
        
            switch (date) {
                case 'monday':
                case 'tuesday':
                case 'wednesday':
                case 'thursday':
                case 'friday':
                    console.log('working');
                    break;
                case '周六':
                case '周日':
                    console.log('relaxing');
                    break;
            }

    2.default
        请使用 default 关键词来规定匹配不存在时做的事情
        相当于if语句中的else
        switch 中如果没有case的匹配那么就将跳入default中;
    
    3.break
        break标准的定义叫终止循环;
        switch 姑且也算成一种循环;当然还有其他的两种 for(), while();

        break就是配合所有循环语句使用的;
        当有一些循环里面想让他在特定条件下停止循环就是用break;
        而且break除了循环外 不能在他处使用 根本就不能写到循环外面;
        for(var i = 0; i < 100; i++){
            if(i == 20){
                break;
            }
        }

        while(i < 100){
            if (i == 20){
                break;
            }
            i++;
        }
    
    4.continue
        continue 就是继续往下面执行的意思;
        (终止本次循环, 继续下次循环);
        
            for(var i = 0; i < 100; i++){
                if(i % 7 == 0 && i % 10 == 7){
                    
                }else{
                    console.log(i);
                }
            }
        
        等同于
        
            for(var i = 0; i < 100; i++){
                if(i % 7 == 0 && i % 10 == 7){
                    continue;   (这里就是记住if里面的条件判断 将其跳出了, 不打印的意思);
                }
                console.log(i);
            }
    5.初始引用值
        1.数组;
            [1, '1', true, [1], {name:'leecs'}, undefined, null]
            存放很多东西的一个集合
            [1,2,3,4,5,6][0]            是取第零位的值;
            [1,2,3,4,5,6][0] = 10;      更改数组第零位的值, 或添加数组的第零位为10;
            [1,2,3,4,5,6].length;       数组的一个属性,表示数组的长度;
            
        2.对象;
            {name : 'leecs', age : 30, live : 'girl'};
            存放数据的一个容器;
            他的格式就是属性名, 属性值, 键值对的格式, 键值对之间用逗号隔开;
            属性名就叫做键(key), 属性值就叫做(value);
            属性名可以加引号,也可以不加; 属性名就是数据(属性值)的一个名称;
            属性值就是存放的数据, 任何数据类型都可以包括数组, 对象;
            所以说对象存放真正有用的是属性值(数据);
            属性名只是方便找到这个属性值; 取值赋值等操作用的;
            
            var leecs = {
                lastName:'lee',
                age:30,
                sex:undefined,
                wife:null,
                father:'lee大爷',
                handsome:true,
            }

            leecs.name                  对象取值;
            leecs.lastName = 'leecz'    对象赋值;
            leecs.name = 'leecz'        对象重新定义属性值;

    6.编程形式的区别;        
        1.面向过程
            面向过程的语言是最早出现的一种语言 比如C就是面向过程的典型语言
            面向过程就是机械的想法 第一步, 第二步, 第三步.... 完成;
            会按照逻辑化思维把这个步骤拆分成几个步骤分段执行;
        2.面向对象
            面向对象比较人性化的思维
            比如Java, C++, 包括JavaScript都算是一种面向对象的语言;
                其实刚开始的JavaScript 是一种面向过程的语言;
                后来倾向面向对象方向发展, 现在是一种半面向过程, 半面向对象的一种写法;
                所以JavaScript继面向过程也面向对象;
            
        
伍.typeof,类型转换;
    1.typeof() 返回数据类型
        typeof能识别的六个值:
        Nmber, String, Boolean, Object, Undefined, Function.

        null 是唯一一个原始值typeof检测成为引用值Object的数据类型;
        这涉及到一个浏览器的历史遗留问题, null最早的时候是给Object占位用的;

        如果一个变量a 没有定义在访问的时候 一定会报错没有定义;
        但是typeof(a) 不会报错 会返回undefined;
        typeof() 检测任何未定义的变量都会返回undefined;

        typeof() 的返回结果都是String类型的;
        
        typeof(typeof(undefined));
        
        
    2.类型转换
        1.显示类型转换
            Number();               转换成Number类型的
                除了纯数字字符串以外, 其他字符串都会转换成NaN, 包括数字字母组合的字符串;
                true                1
                false               0
                null                0
                undefined           NaN
            parseInt(num,radix{2-36})     主要功能将小数转换为整数, 也有类型转换;
                
                parseInt 会从纯数字位数开始看如果到了第N位不是数字了 就会截断 返回前面的数字为; 
                所以parseInt 遇见.这种小数就会截断 返回前面的数字; 如果开始就是非数字那么就会返回NaN;
            
                第二个参数是一个基数,进制数  表示将数字以多少进制为基数转换成为十进制的数字;
                parseInt和Number类型转换有点不同, 除了纯数字和纯数字字符串以外,识别任何东西都为NaN;
                true                NaN
                false               NaN
                null                NaN
                undefined            NaN              
            parseFloat(num)     解析一个字符串转换为整数或者浮点数 也有类型转换
                Int和Float 的不同之处:
                parseFloat 会从数字位开始看, 看到除了第一个.以外的非数字位截断
                但是parseFloat 遇见第二个.开始的这种小数就会截断 返回前面的数字; 如果开始就是非数字那么就会返回NaN;
                true                NaN
                false               NaN
                null                NaN
                undefined            NaN              
            String()            将任何一个东西转换成字符串;
            Boolean()           将里面的东西转换成布尔值;
                除了以下的六个值转换布尔得false, 其他值转换为布尔都得true;
                undefined, null, NaN, '', 0, false
            toString(radix{2-36});          和String()除了用法和一个参数,都是一样的;
                参数: 以十进制为基底,转换成目标进制(radix);
                    '123'.toString(8)
                    以是进制数为基底转换成8进制数字

                    将一个二进制的数字转换成是十六进制的数字
                        二进制     ==>     十进制     ==>     十六进制;
                        var num = 10101010,
                            text = parseInt(num,2),
                            result = text.toString(16);
                            
                将任何东西以调用的形式转换成字符串; 除了Undefined和null 其他都可以调用toString()方法;
            
        2.隐式类型转换
            隐式类型转化内部隐式调用的都是显示的方法;
            isNaN();            判断是否是非数;返回Boolean; 隐式类型转换为Number数据类型;
                调用的是Number() 的方法;
                将isNaN的参数隐式的放到Number()里面去 得出来的结果近和NaN对比;
                如果相等就是true 否则就是false;
                isNaN('abc')    ==>     Number('abc')   ==>     NaN     ==>     isNaN(NaN);   ==>     true;
            ++, --               加加      隐式类型转换为Number类型的;
                    var a = '123';
                    在++ 之前就会有将变量a 调用Number()方法, 转换为数字类型在加一;
                    a ++;       结果是124;

                    减减的隐式类型转换是一样的;
            
            +, -(一元正负运算);
                这不叫加减这叫正负运算符; 调用隐式Number;
                +'123'          调用Number();
                -'123'          调用Number();
            +(加号);
                当加号两侧有一个是String的时候 他就会调用String() 方法;
                var a = 1 + '1';        调用String()方法;
            -, *, /, %,(加减乘除);
                都调用Number()方法;
            &&, ||, !(与或非);
                !隐式类型转换为Booelan();
                &&, ||其实是返回显示类型转换为true或者false 的结果 所以间接性的也有隐式类型转换;
            <, >, <=, >=(大于小于);
                var a = '1' < 2;
                如果字符串和数字比较, 就会转换成Number; 调用Number()方法;
            ==, !=,
                var a = 1 == '1';
                隐式类型转换 调用String(), Boolean(), Number()等方法; 
                将他们转换为相同的数据类型 进行对比较
                != 就是不等于非等 ==取反用法一样;
            
            好玩的:
                2 > 1 > 3   ==>     true > 3    ==>     1 > 3;
                多层对比的时候就会挨个对比, 在进行 大于小于 的类型转换 在进行下面的比对;
                
                undefined > 0
                undefined < 0
                undefined == 0
                null > 0
                null < 0
                null == 0;
                以上的结果都是false;
                undefined 和 null 和零比对都是false;
                
                但是 undefined 和 null 是相等的;
                undefined == null;
                这是隐式类型转换中最特殊的没有规则;系统这么定义的;
                
                NaN == NaN
                只要NaN自己都不等于他就不会等于任何东西
            
            隐式类型转换对于开发是很不利的, 有可能会造成工作上的误差;
            === !== (全等) 不会发生隐式类型转换;

                全等会对比地址指针;
                必须视觉看上去完全一样 并且 如果是变量那么堆栈内存指向要相同,才可以;


陆.函数,初始作用域;
    =======================================================================================
    函数认识:
        if (1 > 0) {
            document.write('a');
            document.write('b');
            document.write('c');
        }

        if (2 > 0) {
            document.write('a');
            document.write('b');
            document.write('c');
        }

        if (3 > 0) {
            document.write('a');
            document.write('b');
            document.write('c');
        }

        耦合代码(耦合度太高的冗余代码);
        编程讲究一个原则是: 高内聚, 弱耦合;
        意思就是把相同功能的代码抽取出来放到一个黑匣子里面, 当每次使用的时候调用这个黑匣子就可以了
        JS中的这个提高效率的黑匣子就是函数;

        function test() {
            document.write('a');
            document.write('b');
            document.write('c');
        }

        test();
        test();
        test();
        这个函数被调用几次就会被重复执行几次;
        
        if (1 > 0) {
            test();
        }

        if (2 > 0) {
            test();
        }

        if (3 > 0) {
            test();
        }

        其实函数也是个引用值
        变量中存储的是数据
        函数中存储的是很多功能语句;
        

    =======================================================================================
    
    练习:
        1.写一个函数, 实现n的阶乘;
            
        2.写一个函数, 实现斐波那契数列;

        3.写一个函数,输入数字,并逆转成汉字形式输出;
    
    
    
    1.正式进入函数课程
        function test () {};
        其实函数和变量没有太大区别, 函数就是另一种类型的变量;
        函数和数组, 对象差不多都是引用值; 他在栈内存里面存储地址;
        test 就是函数名称;
        函数名称规则和变量一样的;只能以$, _, 字母开头;
        而函数名称如果是多个单词组成 遵守开发规范;
        开发规范如果多个单词拼接的变量(函数)名称 必须符合一个原则叫做小驼峰命名法的原则;
        小驼峰命名原则:第一个单词首字母小写往后单词的首字母都大写;(theFirstName);
        
        1.定义
            1.函数声明
                函数有个属性叫做name 函数test.name  是test;
                    function test () {};
            2.函数表达式: (表达式就是忽略他的名字的);
                命名和匿名表达式除了 函数的name 属性指向不同以外 其他没什么区别;
                所以以后但凡是说函数表达式都是说匿名的函数表达式;
                    1,命名表达式;
                        函数有个属性叫做name 命名函数表达式test.name  是test1;
                        命名表达式后面的test1 名字根本就没有什么用;
                            var test = function test1 () {};
                    2.匿名表达式
                        命名函数表达式test.name  还是test;
                            var test = function () {};
        2.组成形式
            1.函数名称
                关键字 function
                函数名 test
                圆括号 ()
                花括号 {};
            2.参数
                参数才是真正让函数变得多功能, 多样化, 有了灵活性;

                    arguments: 函数中隐式的实参列表;
                    arguments.length    表示实参列表的长度;
                    函数名.length         表示形参列表的长度;
                    
                    function test(a,b,c){
                        a = 10
                        console.log(arguments[0]);          10
                        arguments[0] = 10;
                        console.log(a);             10
                        他们的结果是想映射的; 但是a和arguments[0] 不是同一个变量; 他们只是映射规则;
                    }
                    test(1,2,3);

                    function test (a,b){
                        b = 2;
                        console.log(argument[1]);
                        此时这个arguments[1] 中还是undefined;
                        实参列表出生的时候有几个他就有几个;
                        这个时候的B就单纯的当作变量使用了,他跟实参不映射;

                        只有形参和实参位数相等的情况下他们才会有映射的规则;
                        不相等的形实参他们不是相映射的关系的;

                        多出的形参即使在函数体中赋值, 实参列表也不会有这个形参的值;
                    }
                    test(1);
                    
                    
                    如果形参多实参少 那么形参就会对应按着位置去匹配实参中相对应的值;(并且不报错);
                    如果实参多形参少 那么打印对应位 灭有的形参就是undefined 就相当于var 一个形参没有赋值;    
                        1.形参
                            function test (a,b) {
                                参数a,b,就相当于在函数体里面var了一个a和b 没有值;
                                var a,b;
                            }
                            根据实参 就相当于 a 的值为1, b的值为2;
                        2.实参
                            test(1,2);
            3.return
                `.终止函数
                    return 在函数的最后终止这个程序;
                    如果一个函数编写完成后没有加上return, 系统会默认隐式在最后面加上一个return 值为undefined;
                    return 之后的所有语句就将不会再执行;
                2.返回值;
                    return 的本意其实就是将他的值返回到函数外部;
                    return 之后加上一个值 就将会被返回;
                    而且即使是返回值来使用他也同样会将程序终止 之后的代码就将不会在执行;

    2.函数作用域

        练习:
            1.要求输入一串低于十位的数字, 输出这串数的中文大写;
            
            eg: input: 10000      output:壹万;
            eg: input: 1001010      output:壹佰万壹仟零壹拾;
    
        1.作用域定义:变量(变量作用域又称为上下文) 和函数生效(能被访问)的区域;
            函数体中就是局部作用域;
            局部作用域里面可以访问外面的变量;
                var a = 10;
                全局变量a;
                function test () {
                    var b = 10;
                    局部变量b;
                }


                最里层局部作用域优先级最高,它可以访问任何外面的局部变量或者全局变量;
                而外面的不能访问里面的任何一个局部变量;
                var a = 123;
                function test(){
                    var b = 123;
                    function demo(){
                        var c = 234;
                        console.log(a);
                        console.log(b);
                    }
                }


                一个局部变量就相当于一个房间, 同级的局部作用域是不可以访问同级的局部作用域中的变量的;
                彼此独立的之间不可以相互访问;
                function test(){
                    var a = 10;
                }
                function demo(){
                    var b = 20;
                }

柒.递归预编译;
    
    1.递归;
        写一个函数实现n的阶乘;
            
            function mul(n) {
                
                if(n == 1 || n == 0){
                    return 1;
                }
                
                return n * mul(n - 1);
                
            }
            
            这样的一个过程就叫做递归;
            递归底层的规律是先被执行的最后被执行完毕;
            有递归就先写return, 然后把后面的规律写上就完事了;
            递归的劣势就是慢, 特别复杂的程序不能用递归;因为他返回的公式是调用他自身的一个逻辑;
            他就得等候层层嵌套的这个公式执行完毕; 这个过程就慢;
            递归必要注意的两点
                1.找规律
                    n * mul(n - 1);
                2.找出口
                    n == 1 || n == 0;


            mul(5 - 1);在程序中是先执行, 但是最后才一步步返回时最后才执行完;
            mul(5)  ==>     5 * mul(5-1);               5 * (4 * (3 * (2 * 1)))

            mul(4)  ==>     4 * mul(4-1);               4 * (3 * (2 * 1))

            mul(3)  ==>     3 * mul(3-1);               3 * (2 * 1)
                    
            mul(2)  ==>     2 * mul(2-1);               执行到mul(1) 返回1 那么2 * mul(1) 现在就是 2 * 1; 然后这个2 * 1 
                                                        3 * mul(3 - 1) 的返回结果就是这一步的 2 * 1;
            mul(1)  ==>     1;                      
        

        写一个函数, 实现斐波那契数列;
            
            f    s   t
            1    1   2   3   5   8   13  21  34  55;
                f   s   t
            规律就是第3位是 第一位和第二位的和;
            fb(n) == fn(n - 1) + fn(n - 2);
            function fb(n){

                if(n == 1 || n == 2){
                    return 1;
                }
                
                return fb(n - 1) + fb(n - 2);
            }

            一定得有一个写的过程;
            fb(5)   ==>   fb(5 - 1) + fb(5 - 2);            第一步  (3 + 2 == 5)
                fb(4)   ==>   fb(4 - 1) + fb(4 - 2);            第二部  (2 + 1 == 3)
                    fb(3)   ==>   fb(3 - 1) + fb(3 - 2);            第三步  (1 + 1 == 2) 
                        fb(2)   ==>     1           第四步
                        fb(1)   ==>     1           第四步
                    fb(2)   ==>   1             第三步
                fb(3)   ==>   fb(3 - 1) + fb(3 - 2);            第二步  (1 + 1 == 2)
                    fb(2)   ==>   1             第三步
                    fb(1)   ==>   1             第三步
                        
                        
                        
                        
    2.预编译
        JS执行的过程, JS是单线程, JS是解释性语言(翻译一句,执行一句);
        JS运行三部曲
            1.语法分析
                就是在读取JavaScript代码块一行一行解释执行之前, 会对整个代码块进行一个通篇的语法扫描, 这个过程就叫做语法分析;
            2.预编译
                通篇扫描完之后回执行一个过程, 叫做预编译
                预编译前奏
                    1.函数声明整体提升
                        不管test(),执行符写到哪里, 系统都会隐式的把这个函数体提升到逻辑的最前面
                        其实不管在代码块的哪处调用test方法其实本质上都是在test函数体下面调用的;
                        test();
                        function test(){
                            console.log('a');
                        }
                    2.变量 声明提升,但是赋值不提升;
                        console.log(a);
                        var a = 123;
                        这一步叫做变量声明赋值; 提升的只是变量声明的a; 而赋的值123 并不会像函数那样整体提升;
                    3.implyGlobal 暗示全局变量: 即任何变量,如果变量未声明就赋值, 此变量就为全局对象window所有;
                        a = 10 等同于 window.a = 10;
                        如果为声明就使用就会报错, 但是如果未声明就赋值就会生成一个暗示全局变量;
                        这个暗示全局变量就归属window所有了;就相当于window这个对象的a属性是10, window.a = 10;
                    4.一切声明的全局变量, 全是window的属性;
                        var a = 123     ==>     window.a = 123;
                        window 就是全局(全局的域);
                        如果在全局访问console.log(a) 就是访问的window.a;
                        
                        function test(){
                            var a = b = 123;
                        }
                        test();
                        console.log(b);  结果是123;
                        先后顺序是 先把123赋给b, 在声明a, 再把b赋给a;
                        这样连续赋值就导致b未经声明就赋值, 那么这个未经声明就赋值的b就是一个暗示全局变量, 归window所有;
                        console.log(a);
                        结果是undefined; 因为这是局部的变量, 在局部声明就不能归window所有;只有全局才能归window所有;
                局部预编译四部曲,和全局预编译三部曲;
                    
                        GO对象当定义script标签的时候就生成了
                        但是AO对象在函数执行前期才会生成;
                
                    1.函数体系中的预编译(局部预编译)     即是AO;
                        预编译发生在函数执行的前一刻 他创建了AO对象; Activation Object 翻译过来:(执行期上下文 or 局部的域);
                        1.创建AO对象;
                        2.找形参和变量声明,将变量和形参名作为AO属性名, 值为undefined;
                        3.将实参和形参相统一;
                        4.在函数体里面找到函数声明, 将函数名变为AO的属性名, 值赋予函数体;
                            
                            1.创建AO对象;
                                AO = {
                                    
                                }
                            2.找形参和变量声明,将变量和形参名作为AO属性名, 值为undefined; 
                                (这一步就是变量声明提升, 局部域形参提升, 函数整体提升的一个过程);
                                AO = {
                                    a : undefined,
                                    b : undefined,
                                    
                                }
                            3.将实参和形参相统一;
                                AO = {
                                    a : 1,
                                    b : undefined,
                                    
                                }
                            4.在函数体里面找到函数声明,值赋予函数体;
                                a原来的1值, 但是现在被覆盖了; 第四步的优先级是最高的;
                                AO = {
                                    a : function a () {},
                                    b : undefined,
                                    d : function d () {},
                                }
                            
                                function fn(a){
                                    console.log(a);         
                                        AO = {
                                            a : function a () {},
                                            b : undefined,
                                            d : function d () {},
                                        }
                                    var a = 123;            此时的a变成123
                                    console.log(a);         
                                        AO = {
                                            a : 123,
                                            b : undefined,
                                            d : function d () {},
                                        }
                                    function a () {}            第二部函数整体提升已经提升上去了, 所以这步就不用看了;
                                    console.log(a);         
                                        AO = {
                                            a : 123,
                                            b : undefined,
                                            d : function d () {},
                                        }
                                    var b = function (){}           b此时是一个函数;        
                                    console.log(b);         
                                        AO = {
                                            a : 123,
                                            b : function () {},
                                            d : function d () {},
                                        }
                                    function d () {}
                                }
                                fn(1);
                            

                        习题;
                        
                            function test (a, b) {
                                console.log(a);         1
                                c = 0;
                                var c;
                                a = 3;
                                b = 2;
                                console.log(b);         2
                                function b () {}
                                function d () {}
                                console.log(b);         2
                            }
                            test(1);

                            function test (a, b) {
                                console.log(a);             function a () {};
                                console.log(b);             undefined;
                                var b = 234;                
                                console.log(b);             234;
                                a = 123;
                                console.log(a);             123;
                                function a () {}
                                var a;
                                b = 234;
                                var b = function () {};
                                console.log(a);              123; 
                                console.log(b);              function () {};
                            }
                            test(1);


                            console.log(test);          function test () {};
                            function test () {
                                console.log(test);          function test () {};
                                var test = 234;
                                console.log(test);          234;
                                function test () {

                                }
                            }
                            test(1);
                            var test = 123;
                                
                                AO 和 GO 的链式关系 GOAO都有一个函数
                                如果AO有test 就使用AO的 如果没有就去GO上找test();
                                如下解析:
                                    console.log(test);          function test () {};
                                    function test () {
                                        console.log(test);          undefined;
                                        var test = 234;
                                        console.log(test);          234;
                                    }
                                    test(1);

                                    testAO里面什么也没有 他只能上GO去找global;
                                    console.log(test);          function test () {...};
                                    function test () {
                                        console.log(test);          function test () {...}
                                    }
                                    test(1);
                            
                            
                            
                            global = 100;
                            console.log(global);                100
                            function fn () {
                                console.log(global);            undefined
                                global = 200;
                                console.log(global);            200;
                                var global = 300;
                            }
                            fn();
                            var global;

                            

                            
                            if 条件不成立 但是预编译变量声明提升会打破这个规则, 会把var b拿出来, 但是不执行 b = 123这个步骤;
                            function test () {
                                console.log(b);         undefined;
                                if(a){
                                    var b  = 123;
                                }
                                c = 234;
                                console.log(c);         234;
                            }
                            var a;
                            test();
                            a = 10;
                            console.log(c);             234;
                            

                            function bar () {
                                return foo;
                                foo = 10;
                                function foo () {
                                    
                                }
                                var foo = 11;
                            }
                            console.log(bar());          function foo(){};


                            console.log(bar());          11;
                            function bar(){
                                foo = 10;
                                function foo () {

                                }
                                var foo = 11;
                                return foo;
                            }

                            

                            a = 100;
                            function demo (e) {
                                function e () {}
                                arguments[0] = 2;
                                console.log(e);         2
                                if(a){
                                    var b = 123;
                                    function c() {
                                        现在if中定义的函数声明是语法不通过的(谷歌内核不认识), 所以函数c是拿不出来的; 但是过去可以;
                                        就是if 条件不成立 不执行if中的语句 但是变量声明b 可以打破规则提升,但是不能赋值;
                                        而function 17年可以提升像变量声明那样打破规则提升, 但是17年之后不可以函数整体提升了;
                                        所以以后 if 中不允许声明function;
                                    }
                                }
                                var c;
                                a = 10;
                                var a;
                                console.log(b);     undefined;
                                f = 123;
                                console.log(c);     function c () {};
                                console.log(a);     10;
                            }
                            var a;
                            demo(1);
                            console.log(a);     100;
                            console.log(f);     123;



                            var str = false + 1;
                            console.log(str);               1;
                            var demo = false == 1;
                            console.log(demo);              false;
                            if (typeof(a) && -true + (+undefined) + '') {           'undefined' && -1 + NaN + ''
                                console.log('基础扎实');
                            }
                            if(11 + '11' * 2 == 33){                    11 + 22 == 33 先算乘除;
                                console.log('基础扎实');
                            }
                            !!" " + !!"" - !!false || console.log('可以打印吗');         true + false - false || console.log('可以打印吗');
                                                                                        1 + 0 - 0 || 前面是对的就不会往后看了;
                            
                            
                            (window.foo || (window.foo = 'bar'));
                            () 优先级最高, 所以先计算window.foo == 'bar'; 返回'bar';
                            (window.foo || 'bar')    ==>     (undefined || 'bar')    ==> 'bar';
                            如果不加里面的括号(window.foo || window.foo = 'bar'); 都会报错
                            || 是或运算符; 也是一个运算符;
                            因为 || 优先级比 = 优先级高 就先计算 window.foo || window.foo了;
                        
                    函数体系外的预编译(全局预编译);
                        1.创建GO对象; 所说的这个GO 就是window; 就是这个script的标签;
                        2.找变量声明,将变量名作为AO属性名, 值为undefined;
                        3.在全局找函数声明, 将函数名变为GO的属性名, 值赋予函数体;
                        var a = 123;
                        function a () {};
                        
                        再回过头来看全局变量和暗示全局变量归属window所有的问题;
                        function test(){
                            var a = b = 123;
                        }
                        test();
                        以下解读:
                        AO = {
                            a : undefined,
                        }
                        GO = {
                            test : function test () {},
                            b : 123
                        }
                        在执行test 的时候会生成一个test的AO对象;
                        但是testAO对象对 b 可无动于衷啊 b在AO对象中也不是变量声明, 也不是形参;更不是函数;
                        testAO 只能定义var 后面的a 值为undefined; 并不能在AO定义b
                        而这个b就是一个暗示全局变量;(所有未声明就赋值的东西都会形成一个暗示全局变量);
                        
            3.解释执行
                最后才会解释一行执行一行....这样, 也就是说在解释执行js代码块之前还有两步, 第一步叫做语法分析, 第二步叫做预编译, 第三步才会到解释执行的时候;
                







捌.作用域,作用域链精讲;

        作用域链精解;
            作用域属于一个函数;
            一个函数产生了一样的作用域;
            一切为对象的东西都有是属性, 那么这个东西是对象的话, 这个东西一定有属性, 三段论;
            函数也是个特殊对象, 它叫特殊类对象, 它的属性fn.name, fn.prototype, fn.length...等都是可以用的属性;
            特殊类对象还有一些属性是访问不了的, 比如说:this.[[scope]] 翻译过来就是域, 区域的意思, 计算机专业术语叫做域,
            this.[[scope]] 里面就是存储的就是由这个函数产生的作用域, 很复杂的结构;
            但是类对象的这个[[scope]]属性是隐式的, 也就是说不能拿出来用;
            系统会通过内部的一些原理定期的调用这个[[scopes]], 但是系统不会让开发者使用, 但是这个东西全是存在的;
            一个函数下的狗构造函数(constructor)下 最后一项可以看到这个属性, 以及其中的方法;
            

            [[scopes]] 官方解释:
                每个JavaScript函数都是一个对象, 对象中有些属性我们可以访问, 但是有些不可以, 这些属性仅供JavaScript引擎存取, [[scopes]]就是其中一个;
                [[scope]] 指的就是我们所说的作用域, 其中存储了运行期上下去的集合;
                执行期上下文:(就是AO, GO)
                    当函数执行前一刻, 会创建一个成为执行期上下文的内部对象, 一个执行期上下文定义了一个函数执行时的环境,
                    函数每次执行时对应的执行上下文都是第一无二的, 所以多次调用一个函数会导致创建多个执行期上下文,
                    当函数执行完毕, 它所产生的执行期上下文即被销毁
                查找变量
                    在哪个函数中查找变量, 就上哪个函数的作用域链的顶端依次向下查找;
            作用域链:
                [[scope]] 中所存储的执行期上下文对象的集合, 这个集合程链式链接, 我们把这种链式链接叫做作用域链;



            a函数被定义的时候, 就有自己的属性和方法了, 这个时候他就有a.[[scope]], 存储作用域的;
            定义的时候就存储了一位东西, 这个东西是GO; 在形象的说: 他所在环境的哪个执行期上下文, 
            而他所在的环境是全局的, 所以他存的是GO;
            a被执行的时候, a.[[scope]]的第零位放的是AO了, 第一位放的是GO了
            当在a里面变量查找的时候, 他会在 a 作用域链的顶端依次向下查找
            紧接着 由于 a 函数的执行又产生了b函数的定义, 那么b函数此时的执行期上下文就是 a 函数的AO, 
            他的作用域链就是 a 的AO, 和GO; 也就是b的定义就是 a 的执行;
            而 b 的执行又生成了b自己的AO, 放到了自己作用域链的最顶端 放到了第零位;
            所以在 b 中变量查找的时候就会依次查找第零位 b 的A0,第一位 a 的AO, 和第二位全局GO;
                function a () {
                    function b () {
                        var b = 234;
                    }
                    var a = 123;
                    b();
                }
                var global = 100;
                a();


                
                b函数的改变的 a = 0 操作的AO 和 a函数的AO 是就是一个AO;
                function a () {
                    function b () {
                        var b = 234;
                        a = 0;
                    }
                    var a = 123;
                    b();
                    console.log(a);             0;
                }
                var global = 100;
                a();
                
                

                function a () {
                    function b () {
                        var b = 234;
                    }
                    var a = 123;
                    b();
                }
                var global = 100;
                a();
                
                
            这里如果
            
            第一步 a.定义(defined)
                a.[[scope]]  ==>         0 : GO {
                                             this : window,
                                             window : (object),
                                             document : (object),
                                             a : function a () {},
                                             global : 100,
                                         };
            第二步 a.执行(doing)
                a.[[scope]]  ==>         0 : a.AO {
                                             this : window,
                                             arguments : [],
                                             a : 123,
                                             b : function b () {},
                                         };
                                         1 : GO {
                                             this : window,
                                             window : (object),
                                             document : (object),
                                             a : function a () {},
                                             global : 100,
                                         };    
            第三步 b.定义(doing)
                b.[[scope]]  ==>         0 : a.AO {
                                             this : window,
                                             arguments : [],
                                             a : 123,
                                             b : function b () {},
                                         };
                                         1 : GO {
                                             this : window,
                                             window : (object),
                                             document : (object),
                                             a : function a () {},
                                             global : 100,
                                         };
            第四步 b.执行(doing);
                b.[[scope]]  ==>         0 : b.AO {
                                             this : window,
                                             arguments : [],
                                             b : 234,  
                                         }
                                         1 : a.AO {
                                             this : window,
                                             arguments : [],
                                             a : 123,
                                             b : function b () {},
                                         };
                                         2 : GO {
                                             this : window,
                                             window : (object),
                                             document : (object),
                                             a : function a () {},
                                             global : 100,
                                         };
            第五步b的执行完毕是最后一步, 也就导致a的执行完毕, a的执行完毕, a的执行期上下文销毁, 此时b的定义和执行时期的[[scope]] 就全部没了;
                

                习题
                
                function a () {
                    function b () {
                        function c () {
                            
                        }
                        c();
                    }
                    b();
                }
                a();
                
                a.defined    ==>     0 : Go
                a.doing      ==>     0 : a.AO
                                     1 : GO
                b.defined    ==>     0 : a.AO
                                     1 : GO
                b.doing      ==>     0 : b.AO
                                     1 : a.AO
                                     2 : GO
                c.defined    ==>     0 : b.AO
                                     1 : a.AO
                                     2 : GO
                c.doing      ==>     0 : c.AO
                                     1 : b.AO
                                     2 : a.AO
                                     3 : GO
                而且还要明白 其中的所有的a函数产生的AO, b函数产生的AO, 还是c函数产生的AO, 包括全局GO, 都是一个人 只不过是互相借用了一下而已;
                写完这章表就明白, 在任何一个函数里面, 想访问一个变量的话, 就找它的作用域链;
                假如如果a函数中查找变量那就看a函数执行时产生的作用域链;
                假如如果b函数中查找变量那就看b函数执行时产生的作用域链;
                假如如果c函数中查找变量那就看c函数执行时产生的作用域链;
                列这张章表出来就一目了然, 为什么最里的局部函数就能访问外面所有的, 而最外部的函数只能访问全局GO的; 是因为作用域链;
                    
                    
玖.立即执行函数;
    
    0.铺垫
        a执行完把执行上下文销毁, a的执行期上下文中产生了b, a执行完了销毁b
        但是销毁之前b被保存在了外部, a的执行就是将b函数的引用赋给demo;
        a这个时候销毁执行期上下文, demo执行, b定义的地点是a.AO, 但是要在外部执行b函数(demo);
        那么现在从视觉来看console.log(aaa);好像是不成立的, 但是根据作用域链的图解是实际上可以执行的;
        这个过程就叫做闭包, 
        抽象的来说: 但凡内部的函数保存到了外部, 就一定会形成闭包;
        b函数被保存到外部以后, a函数执行完毕销毁, b.[[scope]] 仍然还会有a.AO的执行上下文;

            function a() {
                function b() {
                    var bbb = 234;
                    console.log(aaa);
                }
                var aaa = 123;
                return b;
            }

            var global = 100,
                demo = a();
            demo();

            a doing    ==>     0 : a.AO {
                                         this : window,
                                         arguments : [],
                                         aaa : 123,
                                         b : function b () {....};
                                     }
                                 1 : GO {
                                         this : window,
                                         window : (object),
                                         document : (object),
                                         a : function a () {....},
                                         global : 100,
                                         demo : function b () {....},
                                     }
            b defiend      ==>     0 : a.AO {
                                         this : window,
                                         arguments : [],
                                         aaa : 123,
                                         b : function b () {....};
                                     }
                                 1 : GO {
                                         this : window,
                                         window : (object),
                                         document : (object),
                                         a : function a () {....},
                                         global : 100,
                                         demo : function b () {....},
                                     }
            b doing        ==>   0 : b.AO {
                                         this : window,
                                         arguments : [],
                                         bbb : 234,
                                     }
                                 1 : a.AO {
                                         this : window,
                                         arguments : [],
                                         aaa : 123,
                                         b : function b () {....};
                                     }
                                 2 : GO {
                                         this : window,
                                         window : (object),
                                         document : (object),
                                         a : function a () {....},
                                         global : 100,
                                         demo : function b () {....},
                                     }

            
        闭包的小应用;
        
            function a () {
                var num = 100;
                function b () {
                    num ++;             
                    console.log(num);
                }
                return b;
            }
            
            var demo = a();
            demo();                     101
            demo();                     102
            

            详情请见以下图解;
            a doing    ==>     0 : a.AO {
                                         this : window,
                                         arguments : [],
                                         num : 100,
                                         b : function b () {....};
                                     }
                                 1 : GO {
                                         this : window,
                                         window : (object),
                                         document : (object),
                                         a : function a () {....},
                                         demo : function b () {....},
                                     }
            b defiend      ==>     0 : a.AO {
                                         this : window,
                                         arguments : [],
                                         num : 100,
                                         b : function b () {....};
                                     }
                                 1 : GO {
                                         this : window,
                                         window : (object),
                                         document : (object),
                                         a : function a () {....},
                                         global : 100,
                                         demo : function b () {....},
                                     }
            b doing        ==>   0 : b.AO {
                                         this : window,
                                         arguments : [],
                                     }
                                 1 : a.AO {
                                         this : window,
                                         arguments : [],
                                         num : 100,                              从这里开始 num + 1  那么a.AO的num就成了101, 下次在执行num++ 仍然是从101开始计算++的;
                                         b : function b () {....};
                                     }
                                 2 : GO {
                                         this : window,
                                         window : (object),
                                         document : (object),
                                         a : function a () {....},
                                         demo : function b () {....},
                                     }




        1.闭包
            当内部函数被保存到外部时, 将会生成闭包, 闭包会导致原有作用域链不释放, 造成内存泄漏(内存占用);
            闭包的作用:
                1.实现共有变量
                    1.闭包函数实现累加器;
                        function add () {
                            var count = 0;
                            function demo () {
                                count ++;
                                console.log(count);
                            }
                            return demo();
                        }
                        var counter = add();s
                        counter();
                        counter();
                        counter();
                        
                        调用几次就累加几次;
                    
                2.可以做缓存(存储结构);
                    缓存是外部不可见的, 但是他确实有存储结构;
                    eater;
                        第二种方法;
                        function test () {
                            var num = 100;
                            function a () {
                                num ++;
                                console.log(num);
                            }
                            function b () {
                                num --;
                                console.log(num);
                            }
                            return [a,b];
                        }
                        
                        var myArr = test();
                        myArr[0]();
                        myArr[1]();


                        第二种方法;
                        function test () {
                            var num = 100;
                            function a () {
                                num ++;
                                console.log(num);
                                function b () {
                                    num --;
                                    console.log(num);
                                }
                                b();
                            }
                            return a;
                        }
                        
                        var myArr = test();
                        myArr();
                        
                        function eater () {
                            var food = '';
                            对象里面可以有属性可以有方法, 这个方法其实就是函数的另一种表示形式;
                            var obj = {
                                eat : function () {
                                    console.log('i am eating  ' + food);
                                    food = '';
                                },
                                push : function (myFood) {
                                    food = myFood;
                                }
                            }
                            return obj;
                        }
                        
                        var implement = eater();
                        由于food 是一个obj中的eat和push的作用域链上共有的一个变量一个属性; 同时他们也可以操作food;
                        而eat中的food 就相当于一个隐式的存储结构一样, 虽然没表现出来, 但是food在这里是作为一个存储结构来使用的;
                        implement.push('banans');
                        implement.eat();
                        
                        
                3.可以实现封装, 属性私有化;
                    在闭包应用中var一个变量; 对于leecs对象来说会形成一个私有的属性;
                    只有对象自己通过自己的方法可以操作, 在外部查看leecs.prepareWife(私有属性)查看为undefined;
                    因为他不是对象的东西, 但是他是这个对象和原有空间形成闭包时var的私有属性; 
                    function Leecs(name, wife) {
                        这个prepareWife 就是私有化变量;
                        var prepareWife = '小张';
                        this.name = name;
                        this.wife = wife;
                        this.divorce = function () {
                            this.wife = prepareWife;
                        };
                        this.chagePrepareWife = function (target) {
                            this.prepareWife = target;
                        }
                        this.sayPrepareWife = function () {
                            console.log(prepareWife);
                        }
                    }

                    var leecs = new Leecs('leecs', '小刘');
                    

                    
                4.模块化开发, 防止污染全局变量;
                    
            
            
        2.立即执行函数
            
            如果页面中有太多函数;这些函数如果不等到JavaScript执行完; 那这些函数永远都不会得到释放;
            一直在等待被调用, 等待被调用就会占内存空间;
            很多时候不想让这么多的内存空间被占用; 因为会浪费效率;
            有些函数从定义到执行完毕就只执行了一次; 不会得到多次调用;
            页面中这种函数比比皆是, 到处都有
            如果想让一个只会执行一次的函数执行完毕就销毁, 不要占用内存空间;
            那么就用立即执行函数; 主要针对初始化功能的函数 function init () {}; 页面初始化的等等, 但是除了这些, 其他的都是处理数据的立即执行函数都是需要返回值的, 详情见后
            立即执行函数是JavaScript提供的唯一一个能立即销毁函数的东西, 函数体(函数引用)不被保存; 其他函数都不能手动销毁; 
            立即执行函数 匿名函数, 形式如下:
                (function () {
                    var a = 123;
                    var b = 234;
                    console.log(a + b);
                }());
                这个函数写完就再也找不到了 马上执行, 马上销毁;
                
                (function abc () {
                    即使是个命名函数 在执行完毕后也不会找到; abc 没有的;
                }());
            
            立即执行函数和普通函数没有任何区别; 除了执行完毕就被释放; 
            函数能有的东西立即执行函数都能有
            比如说参数;
                (function (a, b, c) {
                    console.log(a + b + c * 2);
                }(10, 10, 10));
            比如说返回值;
                var num = (function (a, b, c) {
                    return a + b + c * 2;
                }(10, 10, 10));
            比如说arguments
                (function (a, b, c) {
                    console.log(arguments);
                }(10, 10, 10));
            立即执行函数内部也会经历预编译的环节, 执行期上下文;
                (function (d, e, f) {
                    console.log(a);
                    console.log(b);
                    console.log(c);
                    console.log(d);
                    console.log(e);
                    console.log(f);
                    var a = 10;
                    var b = function () {}
                    function c () {};
                }(1, 2, 3));

                预编译如下;
                    AO : {
                        a : undefined,
                        b : undefined,
                        c : function c () {}
                        d : 1,
                        e : 2,
                        f : 3,
                    }
                
            

            拓展: 立即执行函数其实并不是铭文规定的语法;
            其实是开发者试验经验积累出来的一条新的发现;
                立即执行函数的写法;
                    1. (function () {})();       W3C推荐的规范写法;
                    2. (function () {}());
                    只有表达式才能被执行符号执行; 但是函数声明并不是表达式;
                    所以说 function test () {...}() 是不能被执行的; 因为他是函数声明;
                    同理函数表达式就能执行
                    var test = function () {...}(); 就一定可以被执行, 因为他是函数表达式;
                    var test = function () {console.log('ss')}();
                    另外, 能被执行符号执行的表达式, 这个函数的名字就会被自动忽略;
                    比如 var test = function () {}(); 此时打印 test引用 他就是undefined;
                    也就是说能被执行符号执行的表达式, 基本上就成了立即执行函数;
                    比如: 能够有转换成数字表达式的 正负 +/-运算符;
                        + function test () {console.log('aaa')}() 
                        一个表达式被执行之后, 他就会自动忽略这个函数的名字;
                        也就演变成了 + function () {console.log('aaa')}();
                    同样由此可以演变出很多种类型的立即执行函数;
                        - function () {console.log('ss')}();
                        非号
                        ! function () {console.log('sss')}();
                        或, 和 两个符号前面必须要加东西的; 不然语法解析不会通过;
                        '' || function () {console.log('ssss')}();
                        ' ' && function () {console.log('sssss')}();
                    



                    以下是阿里巴巴题库的一道面试题;
                        function test (a, b, c, d) {
                            console.log(a + b + c + d);
                        }(1, 2, 3, 4);
                    其实这样是不报错的 因为立即执行函数是由参数的; 而且实参写入执行符号() 里面的时候 就不会被当成 执行符号了
                    那么JavaScript引擎就会将这种语法识别为:
                        第一句    
                        function test (a, b, c, d) {
                            console.log(a + b + c + d);
                        }
                        第二句   因为逗号(,)就是一种正常语法;
                        (1, 2, 3, 4);
                



拾.闭包
    闭包 (闭包就是能够读取其他函数内部变量的函数, “定义在一个函数内部的函数“, 在本质上, 闭包是将函数内部和函数外部连接起来的桥梁.)
        函数内部的函数存在的时间竟然比外部的函数获得时间还长(生命周期发生混乱); 正常是里面的函数存在的时间比外面地函数短, 因为必须等到外部函数执行才能执行到它 而闭包则不然;
        
        function test() {
            var arr = [];
            for (let i = 0; i < 10; i++) {
                debugger;
                当前的i 随着for循环的变化都会变化; 但是后面的函数不会在意其中写了些什么代码, 因为根本在这一步就不会读到着个函数; 需要等到执行才可以读到函数里面的代码; 可是在外面执行的时候for循环已经结束了; 再回去读取i已经变成了最后一次执行的结果 : 10;
                arr[i] = function () {
                    document.write(i + ' ');
                }



                在循环中把一个函数引用赋给当前arr的索引位
                可是当前函数体并不是现在执行; 所以说每次循环到document.write(i + '');的时候这个i并没有被系统读到;
                等到arr的每一位得到执行的时候才会被执行到函数体中的每一位 i ; 才会被系统读到函数体中的每一位i;
            }
            i 在这里已经变成了10;
            console.log(i);
            return arr;
        }

        var myArr = test();

        for (var j = 0; j < 10; j++) {
            myArr[j]()
            在这里arr的每一位执行: 这个时候才会读到函数体中的内容是什么; 可是这个时候i 已经循环完毕都变成了10; 所以就打印了十遍10;
        }


        使用闭包实现
            第一种方法;
            function test() {
                var arr = [];
                for (var i = 0; i < 10; i++){
                    arr[i] = (function (param) {
                        return param;
                    }(i));
                }
                return arr;
            }
            var myArr = test();
            console.log(myArr);
        
            
        
            第二种方法;
            function test() {
                var arr = [];
                for (var i = 0; i < 10; i++){
                    (function (param) {
                        arr[param] = function () {
                            return param;
                        }
                    }(i))
                }
                return arr;
            }
            var myArr = test();
            for (var i = 0; i < 10; i++) {
                console.log(myArr[i]());
            }


            
            第三种方法;
            function test() {
                var arr = [];
                for(var i = 0; i < 10; i++){
                    function loop(param) {
                        arr[param] = function () {
                            return param;
                        }
                    }
                    loop(i);
                }
                return arr;
            }

            for (var i = 0; i < 10; i++){
                console.log(test()[i]());
            }
            
            
            
            
            
            

            
            


        习题:
            使用JS.addEventListener, 在每个li元素绑定一个点击事件
                var liCollection = document.getElementsByTagName('li');
                for (var i = 0; i < liCollection.length; i++){
                    (function (param) {
                        liCollection[i].onclick = function () {
                            console.log(param);
                        }
                    }(i));
                }
            


                var liCollection = document.getElementsByTagName('li'),i;
                for(var i = 0; i < liCollection.length; i++){
                    liCollection[i].index = i;
                    liCollection[i].onclick = function () {
                        console.log(this.index);
                    }
                }



                这样写也行, 但是未点击时就会触发立执行函数;
                var liCollection = document.getElementsByTagName('li'),i;
                for(var i = 0; i < liCollection.length; i++){
                    liCollection[i].onclick = (function (param) {
                        console.log(param);
                    }(i));
                }



                var liCollection = document.getElementsByTagName('li'),i;
                for(var i = 0; i < liCollection.length; i++){
                    function loop(param) {
                        liCollection[param].onclick = function () {
                            console.log(param);
                        }
                    }
                    loop(i);
                }
                


                var liCollection = document.getElementsByTagName('li'),i;
                for(var i = 0; i < liCollection.length; i++){
                    var loop = function (param) {
                        liCollection[param].onclick = function () {
                            console.log(param);
                        }
                    }(i);
                }
                


            写一个方法求一个字符串的字节长度;
                
                方法一
                var str = 'Hello 世界!'
                function stringSize(param){
                    var count = 0;
                    for (var i = 0; i < param.length; i++){
                        if(param.charCodeAt(i) > 255){
                            count += 2;
                        } else if (param.charCodeAt(i) <= 255) {
                            count ++;
                        }
                    }
                    console.log(count);
                }


                方法二
                var str = 'Hello 世界!'
                function stringSize(param){
                    var count = param.length;
                    for (var i = 0; i < param.length; i++){
                        if(param.charCodeAt(i) > 255){
                            count ++;
                        }
                    }
                    console.log(count);
                    return count;
                }


            写出来一下程序的执行结果;
                逗号操作符, 返回后面的函数之后就形成了 var f = function j () {}();
                var a = (
                    function f() {
                        return '1';
                    },
                    function j() {
                        return 2;
                    }
                ());
                console.log(f);
                
                逗号操作符返回最后一位, 结果就是:
                var a = function j () {return 2;}();
                console.log(f);
            
            写出来以下程序的执行结果

                if后面的括号中是条件判断 会隐式类型转换 类型转换function并不是 为false的六个值, 就能够往下执行;
                但是括号会把里面的函数变成表达式的; 变成函数表达式了就不是函数定义了;
                就好像()立即执行函数的括号一样 变成表达式了, 这个函数名称 f 自然也就消失了;
                好比(function f() { console.log(f)}());
                var a = (function f() { console.log(f)}());   a 是undefined
                但是 f 消失了之后, 如果被typeof检测的话就会返回字符串的undefined;
                所以最后的结果是 1undefined;
                
                var x = 1;
                
                if (function f() {}) {
                    x += typeof f;
                }
                console.log(x);
    


拾壹.对象, 包装类;
    
    对象;
        1.用已学的知识点, 概述心中的对象;
            对象是一种基础的变量类型;

                
            var leecs = {
                name : 'lee',
                age : 30,
                sex : 'male',
                health : 100,
                smoke : function () {
                    console.log('I am smoking! cool!!');
                    leecs.health --;
                    this.health --;
                },
                drink : function () {
                    console.log('I am drink');
                    leecs.health ++;
                    this.health ++;
                }
            }

                
            
        2.属性的增, 删, 改, 查;
            如果访问一个对象没有的属性的时候就会返回undefined, 而并不会报错;
                    
                this, 指代当前对象, 对当前对象的一个引用;
                增
                    leecs.wife = '小王';
                删
                    delete leecs.wife;
                改
                    leecs.wife = '小乔';
                查
                    leecs.name;
                
                
                
        3.创建对象的方法;
            1.字面量
                var obj = {};      plainObject(对象字面量\对象直接量);
                    
            2.构造函数
                1.系统自带   
                    new Object();Array();Number();Boolean();String();Date();
                    var obj = new Object();
                2.自定义
                    function Person() {};
                    构造函数和函数没有任何区别; 
                    但是想要构造出一个对象来 就需要一个 new 操作符;
                    new 后面的函数就会生成一个自定义的对象; 和new Object() 没有任何区别; 增删改查操作 等等都无异;
                    但是由于构造函数和普通函数没有任何区别;
                    所以为了区分构造函数和普通函数, 在书写构造函数的时候就需要遵守一个(墨守成规的)原则 : 遵循大驼峰式命名规则;
                        大驼峰 : TheFirstName
                        小驼峰 : theFirstName

                        function Car() {
                            this.name = 'BWM';
                            this.height = '1400';
                            this.lang = '4900';
                            this.weight = 1000;
                            磨损值;
                            this.health = 100;
                            this.run = function () {
                                这个时候就只能用this了;
                                car和car1 都没有构造出来  他的实例对象都是未知的;
                                this.health --;
                            }
                        }

                        var car = new Car();
                        var car1 = new Car();
                        car.run(); 
                        car.health值为99  car1.health并不会改变; 也就是说一个构造函数生成的不同的实例对象,虽然是通过调用共同的构造函数中的方法, 
                        但是他们的值各自是各自的; 完全是两个实例对象, 根本不会相互影响;
                            
                        实现一个工厂模式的造车方式 比如需要一个客户需要自己选配颜色;
                            function Car(color) {
                                this.color = color;
                                this.name = 'BWM';
                                this.height = '1400';
                                this.lang = '4900';
                                this.weight = 1000;
                                磨损值;
                                this.health = 100;
                                this.run = function () {
                                    这个时候就只能用this了;
                                    car和car1 都没有构造出来  他的实例对象都是未知的;
                                    this.health --;
                                }
                            }

                            var car = new Car('green');
                            var car1 = new Car('blue');

                        一个学校里的学生除了入学年纪相同, 其他的各不相同;
                            function Student(name, age, sex) {
                                this.name = name;
                                this.age = age;
                                this.sex = sex;
                                this.grade = '2017';
                            }
                            var student = new Student('张三', 18, 'male');
                            console.log(student);
                            

                    构造函数内部原理
                        1.在函数体最前面, 隐式的加上this = {};
                        2.执行this.xxx = xxx;
                        3.隐式的返回this; (但是如果显示的显示一个空对象) 那么构造出来就是一个空对象; 并且返回原始值不生效; 只要有new了就不会返回原始值;
                            当一个函数调用了new操作符时, 就会隐式的发生这三个步骤; 完成函数构造的步骤;
                                
                            function Student(name, age, sex) {
                                隐式的var this = {};
                                this.name = name;
                                this.age = age;
                                this.sex = sex;
                                this.grade = '2017';
                                隐式的 return this;
                            }
                            var student = new Student('张三', 18, 'male');
                                
                            Student.AO = {
                                this : {
                                    name : 'leecs',
                                    age : age,
                                    ....
                                },
                            }
                                
                                
                                
                            function Person(name, height) {
                                var that = {
                                        
                                };
                                that.name = name;
                                that.height = height;
                                that.say = function () {
                                    console.log(that.say);
                                }
                                return that;
                            }
                                
                            var person = new Person('leecs', 196);
                            
            3.Object.create(原型)方法;  
                


            

    包装类;
        new String();
        new Boolean();
        new Number();

        ECMASscript中数字是原始值, 原始值是没有属性和方法的;
            
        数字分为两种数字;
            数字;
            var num = 123;
            构造函数数字
            var num = new Number(123);
            构造函数数字甚至可以有自己的属性和方法; 但是数字并没有属性和方法;
            构造函数数字进行了加减乘除运算时, 他的结果依旧会变成一个普通数字;

        字符串, 布尔等原始值的构造函数都是同理;
        但是一个str 会有length是属性; 下面解答;
            包装类的过程;
            var num = 4;
            在原始值调用属性的时候; 会隐式的发生以下的一个过程;
            new Number(4).len = 3;   delete;
            会新建一个数字对象, 让这个对象的len = 3, 然后在delete 销毁;
            num.len = 3;
            当再次访问的时候就会重新创建一次;
            new Number(4).len  这次访问的len 并非上次delete销毁的len 所以应该是undefined;
                
                
            引用值数组length 改变会有一个截断的功能;
            var arr = [1,2,3,4,5]
            arr.length = 2;
            console.log(arr);
            原始值字符串的length改变 经历的是包装类的过程; 所以并不会截断;

            var str = 'abcd';
            str.length = 2;
            new String(abcd).length = 2, delete;
            console.log(str);
            console.log(str.length);
            再次访问他的长度的时候, 因为系统的字符串构造函数是有length这个属性的 所以访问的就应该是new String(abcd).length;

            

        习题

            console的打印结果是什么;
            var str = 'abc';
            str += 1;
            var test = typeof str;                  string
            if(test.length == 6) {                  
                test.sign = 'typefo的返回结果可能为String';
                new String(string).sign = xxx;    delete;
            }
            console.log(test.sign);                  undefined
            new String(string).sign               


            分析下面的JavaScript代码块
            function Employee(name,code) {
                this.name = 'leecs';
                this.code = 'A001';
            }
            newemp = new Employee('zhangming', 'A002');
            console.log('雇员姓名:' + newemp.name);
            console.log('雇员姓名:' + newemp.code);
            输出 leecs A001; 因为形参列表的参数在函数引用中并没有使用;
                
                

            输出以下代码的执行结果;
            function Person(name, age, sex) {
                var a = 0;
                this.name = name;
                this.age = age;
                this.sex = sex;
                function sss() {
                    a ++;
                    console.log(a);             
                }
                this.say = sss;
            }
                
            var person = new Person();
            person.say();                   1;
            person.say();                   2;
            var person1 = new Person();
            person1.say();                  1;
            person和person1 的构造函数的产生的AO对象没有关联; 因为构造函数Person 执行完毕就销毁了;  person1的构造函数是一个全新的;



            var x = 1, y = z = 0;
            function add(n) {
                return n = n + 1;
            }
            y = add(x);
            function add(n) {
                return n = n + 3;
            }
            z = add(x);
                
            console.log(x);         1
            console.log(y);         4
            console.log(z);         4

                
                

            
            
            
            
            
拾贰.原型,原型链,call,apply
    1.原型
        1.定义:原型就是function对象的一个属性,他定义了构造函数制造出的对象的公共祖先;通过该构造函数产生的对象,可以继承该原型的属性和方法;原型也是对象;
        2.利用原型特点和概念, 可以提供共有的属性;
        3.对象如何查看原型, ==> 隐式属性 ==> __proto__;
        4.对象如何查看对象的构造函数 ==> constructor;
            
            1.定义:原型就是function对象的一个属性,他定义了构造函数制造出的对象的公共祖先;通过该构造函数产生的对象,可以继承该原型的属性和方法;原型也是对象;

                Person.prototype         ==>     原型; 定义的时候已经定义好了;
                Person.prototype = {};   他就是构造函数的公共祖先; 原型也是对象;

                Person.prototype = {
                    name : 'lee',
                    say : function () {
                        
                    },
                }
                第二种方法写入到原型
                Person.prototype.name = 'lee',
                Person.prototype.say = function () {}                    
                
                
                function Person() {
                    
                }
                var person = new Person();
                console.log(person.name);
                var person1 = new Person();
                虽然Person构造函数没有name但是person实例对象有 因为构造函数Person的原型有name这个属性;
                但凡是通过同一个构造函数构造出来的实例对象, 都会继承Person.prototype(原型)上的任何属性;
                

                
                
                
                
                
                

            
            2.利用原型特点和概念, 可以提供共有的属性;
                
                1
                Person.prototype = {
                    name : 'lee',
                    say : function () {
                        return 'Person.prototype';
                    }
                }
                
                function Person() {
                    this.name = 'ji';
                    this.say = function () {
                        return 'Person';
                    }
                }
                var person = new Person();
                console.log(person.name);
                console.log(person.say());
                
                2
                Person.prototype = {
                    lastName : 'lee',
                    say : function () {
                        return 'Person.prototype.say';
                    }
                }
                
                function Person(name, age, sex) {
                    this.name = name;
                    this.age = age;
                    this.sex = sex;
                    this.say = function () {
                        return 'Person.say';
                    }
                }
                var person = new Person('leecs', 30, 'male');
                console.log(person.name);
                console.log(person.lastName);
                console.log(person.say());
                同理如果有的自己身上有name属性就用自己的属性, 如果没有就去原型上面找name属性;
                这就属于一个正常的对象应该访问的一系列的特性; 有自己的属性, 也有原型提供的;
                

                3.工厂模式 (根据原型特点和概念, 提供共有的属性)
                function Car(color, owner) {
                    this.owner = owner;
                    this.color = color;
                this.carName = 'BWM';
                this.lang = '4900';
                }
                Car.prototype.carName = 'BWN';
                Car.prototype.lang = '4900';
                var car = new Car('red', 'leecs');
                如上代码Car.carName, lang这些代码每一次执行都需要执行一边; 会造成代码的冗余; 浪费效率;
                那么这些冗余的多次调用的方法只需要放到原型上 每次Car() 构造函数执行的时候去原型上面获取属性, 不需要执行一次创建一次, 执行一次创建一次;
                所以在实际开发中把这些共有的属性或者方法, 提取出来放到原型上面; 有效减少代码冗余;
                
                原型的增删改查;(构造函数构造出来的实例对象是万万不能对原型的属性方法进行增删改查的);
                Person.prototype.lastName = 'lee';
                function Person(name) {
                    this.name = name;
                }
                var person = new Person('cs');
                增
                    person.lastName = 'james';
                    是给自己的构造函数添加了一个lastName属性; 而并不是把原型的同名属性改变; 除非Person.prototype.lastName = xxx 这么来改;
                    访问的话自己有了也就用自己的了 那么访问的就并不是原型上面的了;
                删
                    删除自己构造函数的属性;
                    delete person.name;
                    console.log(person.name);
                    删除原型的属性;
                    delete Person.prototype.lastName; 
                    delete person.lastName 虽然它没有lastName属性用的是原型的, 但是这样删除是删除不了原型的方法的;
                






            3.对象如何查看原型, ==> 隐式属性 ==> __proto__;
                
                实力对象.prototype是访问不了的, 只能构造函数.prototype; 来访问原型;
                其实__proto__就是让实例对象能够直接访问到构造函数上的原型的一个隐式的属性;
                Person.prototype === person.__proto__;
                
                __proto__有什么用途, 是哪里来的?
                    其实在new执行第一步的时候 隐式的 var this = {}, 这个this 并不是空对象, 里面就有__proto__的属性, 指向的就是Person.prototype;
                    当访问实例对象属性的时候, 如果没有, 就会沿着 __proto__ 的指向 Person.prototype上 去查找原型上有没有需要的属性; 
                    __proto__ 相当于一个连接的关系, 把原型和自己链接在一起了; 能拿原型上的属性的根本原因就是因为这个__proto__;
                    并且实例对象的原型也可以手动更改指向;
                    var obj = {name : 'leecs'};
                    
                    Person.prototype = {
                    var this = {
                            __proto__ : Person.prototype;
                    };
                        name : 'abc',
                    }
                    function Person() {
                        
                    }
                    var person = new Person();
                    person.__proto__ = obj;
                    console.log(person.name);           通过原型的修改会更改为leecs 因为原型指向为obj 走的就是obj里的name;
                    
                    
                
                function Person() {
                var this = {
                    __proto__ : Person.prototype,   
                }
                __proto__ 指向的空间还是name 为 sunny 的原型对象;
                那么现在 Person.prototype的空间换成name为cherry的原型对象 __proto__的指向还是name为sunny的空间; 
                所以person.name就应该是沿着__proto__找到第一个原型对象上的name属性为sunny;
                Person.prototype.name 这种方法改变改的还是原来name为sunny的原型对象的方法;
                而Person.prototype = {name : 'cherry'} 就是代表重写了这个原型对象;
                以上所说都是在实例对象构造出来之后在重写Person.prototype
                但是Person.prototype在实例对象构造出来之前重写就是代表Person.prototype是覆盖了;
                __proto__就会读取最下面定义的Person.prototype;
                结论原型对象重写的方式只有在 实例对象生成之前才重写才会以覆盖的方式生效, 否则放后面不会在对实例对象有影响;
                }
                Person.prototype = {
                    name : 'sunny'
                }
                var person = new Person();
                Person.prototype = {
                    name : 'cherry',
                }

                console.log(person.name);
                打印是sunny;

                以上和以下情况类似;
                var obj = {name : 'abc'};
                var obj1 = obj;
                obj = {name : 'b'};
                
                
            
            
            
                
            4.对象如何查看对象的构造函数 ==> constructor;
                在原型的内部, 系统默认的一个属性叫做constructor; 
                constructor是构造器的意思, 一个实例对象调用constructor返回的是这个实例对象的构造函数;
                这个constructor就是构造函数的原型上的一个属性; 是浅色的(浅色就代表系统默认的, 隐式的属性或方法);

                function Person() {
                    
                }
                Car.prototype.constructor = Person;
                function Car() {
                    
                }
                var car = new Car();
                console.log(car.constructor);
                
                以上实例说明可以改变, 原型上的constructor可以手动改变它;
            
                    一个函数的构造函数就是它本身;
                    function test() {}
                    console.log(test.constructor);
    
    
    


    2.原型链
        1.如何构成原型链?
            如下吧原型上面加上多个原型, 把原型练成链, 访问顺序和作用域链一样(近水楼台先得月), 这种叫做原型链;连接点是__proto__;
            Grand.prototype.__proto__ === Object.prototype;
            Object.prototype是所有对象的最终原型;
            
            Grand.prototype = {
                lastName : 'lee',
            }
            function Grand() {
                
            }
            var grand = new Grand();
            
            Father.prototype = grand;
            function Father() {
                this.name = 'cs';
            }
            var father = new Father();
            
            Son.prototype = father;
            function Son() {
                this.hobbit = 'somke';
            }
            var son = new Son();

            console.log(son.hobbit);        自己构造的属性;
            console.log(son.name);          父亲构造的属性;
            console.log(son.lastName);      爷爷构造的属性;
            
            所以son的原型上面有Object原型上的所有方法;
            console.log(son.toString());

        
    
    
        2.原型链上属性的增删改查
            
        
            Grand.prototype = {
                lastName : 'lee',
            }
            function Grand() {
                
            }
            var grand = new Grand();
            
            Father.prototype = grand;
            function Father() {
                this.name = 'cs';
                this.fortune = {
                    card1 : 'visa',
                };
                this.num = 100;
            }
            var father = new Father();
                
            Son.prototype = father;
            function Son() {
                this.hobbit = 'somke';
            }
            var son = new Son();
            console.log(son.fortune);
            son.fortune = 200;
            给自身加fortune属性; 和father身上的不冲突;
            son.fortune.card2 = 'master';
            这种属于son调用了father的fortune属性 在他的基础上进行增删改查;
            就相当于引用值自己的修改 fortune.card2 = xxx; 同理覆盖是不行的;
            son.num ++;
            son.num = son.num + 1; son.num取的是father的num 100; 但是加一赋完值就变成自己的属性了;
            
            



            
            Person.prototype = {
                name : 'a',
                sayName : function () {
                    console.log(this.name);
                    谁调用的sayName方法this就指向谁;
                }
            }
            function Person() {
                this.name = 'b';
            }
            var person = new Person();
            console.log(person.sayName());          b 
            
            
            
            
            
            
            Person.prototype = {
                height : 100,
            }
            function Person() {
                this.eat = function () {
                    this.height ++; 
                }
            }
            var person = new Person();
            console.log(person.eat());          b 
            
            
            

            
            
            
            
            
        
        
        3.绝大多数对象的最终都会继承自 Object.prototype;
            function Person() {}
            我们说这是一个构造函数, 他有一个默认的prototype 就是一个对象字面量;
            所以对象字面量的原型就应该是Object.prototype 所以Person.prototype是原型链的终端毋庸置疑;

            var obj = {};
            var obj1 = new Object();
            这种构造出来的obj实例对象并不相等; 但是{} 会隐式的 发生一个 new Object();的步骤;
            但是一般都是采用字面量的形式定义声明一个对象; 太麻烦了还没什么用好处;
            还不能在Object('asdf') 括号里面直接添加属性; 加上的字符串都成为一个个属性为 0:a, 1:s, 2:d, 3:f 的单个字符值;
            console.log(obj.__proto__ === Object.prototype);
            console.log(obj.constructor);
            
            
        
        
        
        
        
        4.Object.create(原型);
            Object.create(原型);更加灵活的一种创建原型的方法;
            var obj = {name : 'sunny', age : 123};
            var obj1 = Object.create(obj);
            
            
            Person.prototype.name = 'sunny';
            function Person() {
                this.property = 'property';
            }
            var person = Object.create(Person.prototype);
                person.__proto__ == Person.prototype;
            var person1 = Object.create(new Person());
                person1.__proto__ == new Person();
            
            
            那么是不是所有的对象都是最终继承字这个对象?; 并不是, 因为有Object.create();s
                var obj = Object.create() 
                参数可以不是一个对象(包括引用值数组), 就必须是个null 不能添加为别的参数(包括空);
                var obj = Object.create(null);
                如果一个通过create(null) 参数为null 构造出来的对象就没有原型(一个真正的空对象);No properties;
                obj.__proto__ = {name : 'leecs', age : 12};
                console.log(obj.name);
                obj.name = 'sunny';
                console.log(obj.name);
                如果手动加__proto__, 是没有继承特性的; 所以原型是一个隐式的内部属性, 手动添加的系统并不会读, 也就没有继承特点;
                
                参数可以不是一个对象(包括引用值数组), 就必须是个null 不能添加为别的参数(包括空);
                var obj = Object.create([1,2,3,4]);
                console.log(obj.__proto__); 数组也是对象; 所以create([1,2,3])就是一个数组;



            toString();
                undefined和null没有toString()方法;
                因为这两个值是原始值, 也不是原型,也不是对象, 也没有包装类的过程
                
                各个属性值调用toString(); 返回的结果都是不同的;
                var boolean = true.toString();
                返回一个字符串'true';
                var number = 123; number.toString();
                返回一个'123';
                不能123.toString(); 数学计算中.的优先级是最高的; 会把这个点识别成数字的浮点型; 123.tostring()自然就是语法错误了;
                var object = {}; object.toString();
                返回一个'[object object]';
                因为object 的toString是调用的Object.prototype上面的toString();方法;
                因为他的__proto__指向的就是 Object.prototype, 他就是终端, toString()就是它原型上的方法;
                
                num的toString();方法;
                var num = 123;
                num.toString();
                隐式的 new Number(num).toString(); 
                num的原型是Number.prototype;         Number.prototype.__proto__ == Object.prototype;
                但是Number.prototype对象上就有一个toString();方法;      console.log(Number.toString());     自然自己原型对象上有就用自己的, 就不会用Object原型终端身上的了;
                Number原型上的toString()是重写过的; 就是相同名字, 不同功能的一个方法;
                

                    obj终端身上的方法;
                    Object.prototype = {
                        toString : function () {
                            ....
                        }
                    }
                    
                    Nubmer的原型; (它的身上的原型还是继承自Object的这个终端原型的);
                    Number.prototype = {
                        toString : function () {
                            return 'changed';
                        }
                    }
                    function Number() {
                        
                    }
                    var num = 123;
                    var num = new Number(123);
                    console.log(num.toString());            重写后结果changed;
                    

                重写toString()方法的数据类型函数;
                    Array.Prototype.toString();
                    Number.Prototype.toString();
                    Boolean.Prototype.toString();
                    String.Prototype.toString();
                
                    document.write() 往页面输出东西的时候其实会调用隐式的Object.原型.toString()方法;
                    var obj = {};
                    document.write(obj);    其实打印的是obj.toString().的结果;
                    

                    证明它用的是toStirng()的方法;
                    var obj = {};
                    obj.toString = function () {
                        return 'leecs';
                    }
                    document.write(obj);        此时打印就是leecs;
                    
                    
                
                
                
        一个小BUG;
            0.14 * 100;         14.00000000000002;
            JavaScript 并不处理数据 所以设计者设计的时候存在一定的精度偏差
            可计算的范围:
            小数点前面16位数字, 小数点后16位数字;
                
                
                
    2.call/apply
        1.作用, 改变this指向;
        2.区别, 传参形式的不同;
            1.call
                function Person(name,age) {
                    this.name = name;
                    this.age = age;
                }
                var person = new Person('lee', 100);
                var obj = {};
                
                任何一个函数执行都会真正的隐式调用.call(), 方法();
                所以 Person()  就等于 Person.call();
                Person.call();
                
                call真正高深的用途在于参数;
                Person.call(obj,'leesx', 100);
                call 会让Person函数中的所有的this 指向 obj;
                call第一个参数改变this指向, 第二位以后的参数会当作实参传到形参中去;
                这时候.call()的第一个参数是谁, person中的this就是谁; 借助person的属性制造自己的属性;
                console.log(obj);

                

            

                function Person(name, age, sex) {
                    this.name = name;
                    this.age = age;
                    this.sex = sex;
                }
                
                function Student(name, age, sex, tel, grade) {
                    Person.call(this, name, age, sex);
                就相当于: 
                this.name = name;
                this.age = age;
                this.sex = sex;
                这第三步骤拷到这里来了;
                    this.tel = tel;
                    this.grade = grade;
                }
                
                var student = new Student('sunny', 100, 'male', 186, 2017);
                
                

                
                比如一个车间, 模块化生产汽车, 生产轮子, 座椅...等等模块;
                function Wheel(wheelSize, style) {
                    this.wheelSize = wheelSize;
                    this.style = style;
                    
                }
                function Sit(c, color) {
                    this.c = c;
                    this.color = color;
                }
                function Model(height, width, lang) {
                    this.height = height;
                    this.widht = width;
                    this.lang = lang;
                }
                现在车间什么都不做, 每个部门所造的东西拼到一起; 就形成一个大的工厂;
                function Car(wheelSize, style, c, color, height, width, lang) {
                    Wheel.call(this, wheelSize, style);
                    Sit.call(this, c, color);
                    Model.call(this, height, width, lang);
                }
                var car = new Car(100, '花里胡哨', '真皮座椅', '红色', 1900, 2000, 4900);
                console.log(car);
                
            2.apply;
                .apply(this, [1, 2, 3, 4, 5]);
                只是一个传参形式的不同;(传进去一个arguments数组);
                apply传参形式的好处, 可以直接将一个数组作为参数传递进去;而且call就没有这种好处;
                
                function Wheel(wheelSize, style) {
                    this.wheelSize = wheelSize;
                    this.style = style;
                    
                }
                function Sit(c, color) {
                    this.c = c;
                    this.color = color;
                }
                function Model(height, width, lang) {
                    this.height = height;
                    this.widht = width;
                    this.lang = lang;
                }

                function Car(wheelSize, style, c, color, height, width, lang) {
                    Wheel.apply(this, [wheelSize, style]);
                    Sit.apply(this, [c, color]);
                    Model.apply(this, [height, width, lang]);
                }
                var car = new Car(100, '花里胡哨', '真皮座椅', '红色', 1900, 2000, 4900);
                console.log(car);



拾叁.继承模式, 命名空间, 对象枚举;
    1.继承模式;
            1.继承发展史;
                1.传统形式 ==> 原型链;
                    过多的继承了没用的属性;
                    
                    Grand.prototype = {
                        lastName : 'lee',
                    }
                    function Grand() {
                        
                    }
                    var grand = new Grand();
                    
                    Father.prototype = grand;
                    function Father() {
                        this.name = 'cs';
                    }
                    var father = new Father();
                    
                    Son.prototype = father;
                    function Son() {
                        this.hobbit = 'somke';
                    }
                    var son = new Son();
                    
                    这种grand继承到son 有一个矛盾就是不需要的属性也继承来了; 效率极差, 很快废弃使用;
                    实际开发是根本不可能用到的这个方法;
                    
                    
                2.借用构造函数;
                    不能继承借用构造函数的原型;
                    每次构造函数都要多走一个函数;
                
                    实际这种关系并非是继承的关系; 只是借用其他函数的属性方法实现自己的功能; 但是也是继承发展史的一个环节;
                    function Person(name, age, sex) {
                        this.name = name;
                        this.age = age;
                        this.sex = sex;
                    }

                    function Student(name, age, sex, grade) {
                        Person.call(this, name, age, sex);
                        console.log(this);
                    }
                    Student();
                    
                    
                    
                3.共享原型;
                    不能随便改动自己的原型; 但是这是现在开发应用的一个雏形;

                    就是让两个构造函数继承于同一个原型; 现在在原型的概念上衍生了一个新的用法, 多个构造函数共用了同一个原型对象;
                    Father.prototype.lastName = 'lee';
                    function Father() {
                    }
                    function Daughter() {
                    }
                    共享原型不足; 女儿sex改成woman, 父亲的sex也同样改成woman;
                    daughter和father所操作的原型是同一个; 所以daughter是不能操作原型的;
                    想给daughter加一个自己的属性; 但是因为共用一个原型, 影响了father的属性;
                    
                    Daughter.prototype.sex = 'woman';
                    
                    interit(Daughter,Father);
                    先继承后构造实力对象

                    var father = new Father();
                    var daughter = new Daughter();

                    封装成一个函数;
                    function interit(Target, Origin) {
                        参数为两个构造函数; 需要Target继承Origin;
                        Target.prototype = Origin.prototype;
                    }
                    
                    
                    
                4.圣杯模式; ( 最完美的继承模式 )
                    就是利用了一个构造函数F() 作为中间件;
                    其实和同样还是共享模式, 解决了共享模式不能操作自己原型属性的不足;
                    function interit(Target, Origin){
                        function F() {};
                        F.prototype = Origin.prototype;
                        Target.prototype = new F();
                        但是有一个问题 原型中的构造函数指向发生了混乱;
                        daughter.__proto__   ==>     new F().__proto__   ==>     Father.prototype    constructor    ===     Father();
                        矫正daughter的构造函数指向;
                        Target.prototype.constructor = Target;
                        定义一个继承关系中真正继承自谁的方法;
                        Target.prototype.primitiveObject = Origin.prototype;
                    }
                    
                    Father.prototype.lastName = 'lee';
                    function Father() {
                    }
                    function Daughter() {
                    }
                    interit(Daughter, Father);
                    var father = new Father();
                    var daughter = new Daughter();

                    console.log(daughter.constructor);


                    深入改善封装圣杯模式;
                        var interit = (function (){
                            var F = function () {};
                            return function (Target, Origin) {
                                F.prototype = Origin.prototype;
                                Target.prototype = F.prototype;
                                console.log(Target.prototype);
                                Target.prototype.constructor = Target;
                                Target.prototype.primitiveObject = Origin.prototype;
                            }
                        }());

                        
                        Person.prototype.lastName = 'lee';
                        function Person() {
                        }
                        function Son() {
                        }
                        interit(Son, Person);
                        var person = new Person();
                        var son = new Son();
                        console.log(son.lastName);
                        console.log(son.primitiveObject);
        
            
    2.命名空间;
        管理变量, 防止污染全局, 适用于模块化开发;
            在JS多年前, 曾经用这种方式模拟命名空间;
            var org = {
                departmentO : {
                    leecs : {
                        name : 'abc',
                    },
                    wufutu : {
                        
                    }
                },
                departmentT : {
                    maodun : {
                        
                    },
                    muertai : {
                        
                    }
                }
            }

            var leecs = org.departmentO.leecs;
            console.log(leecs);

            现在真正的解决办法是webPack, gulp, grunt..等同步化开发的构建工具包管理器;
            
            var init = (function () {
                var name = 'abc';

                function callName() {
                    console.log(name);
                }
                return function () {
                    callName();
                }
                
            }())
            
            
        jQuery是一个非常强大的JavaScript方法库, jQuery强大的链式调用是因为底层的return this;

        属性表示方法;
            obj.name == obj['name'], 是等同的;
            obj.name    隐式转换为       obj['name'];
            obj[name] name不加引号就会被系统当成一个变量;
            
            
    3.对象枚举;(对象遍历);
        1.for...in...
            var obj = {
                name : 'leecs',
                age : 123,
                sex : 'male',
                height : 196,
                weight : 75,
            }
            for...in...循环, 这个对象有几个属性就会有遍历几圈;
            他在循环每一圈的时候, 会将这个对象的属性名放到这个prop变量中去;
            
            for(var prop in obj) {
                console.log(prop);
            }
            
            以下实例;
                第一个;
                var obj = {
                    a : 123,
                    b : 234,
                    c : 345,
                },
                key;
                for(key in obj) {
                    obj[key] ++;
                }
                console.log(obj);
                

                第二个
                var obj = {
                    a : 123,
                    b : 234,
                    c : 345,
                    key : 20,
                },
                key;
                for(key in obj) {
                    obj[key] ++;
                    obj.key   会打印三个undefined, 因为隐式转会就会成为 obj['key'] 而obj并没有key这个属性;
                    所以只能boj[key]这么写;
                }
        
        
        2.hasOwnProperty();
            var obj = {
                name : 'leecs',
                age : 123,
                sex : 'male',
                height : 196,
                weight : 75,
                __proto__ : {
                    lastName : 'lee',
                }
            },
            key;
            obj.__proto__ === Object.prototype; __proto__ 地址指向;
            Object.prototype.abc = '123';
            for(key in obj) {
                console.log(obj[key]);
                现在原型上的方法也被遍历了, 但是原型上的顶级原型 Object.prototype这个对象的方法是不会打印的
                但是如果Object.prototype原型上如果是手动设的也会被打印的;
                因为顶级的方法是系统自带的, 遍历只会打印手动设的值;
                如果不遍历原型上的方法, Object身上有个方法: obj.hasOwnProperty();
                hasOwnProperty() 就是判断这个属性是不是obj自己的属性, 返回布尔类型值;
                如果是他自己的那么就返回true, 如果是原型上的就会返回false;
                
                if(obj.hasOwnProperty(key)){
                    console.log(obj[key]);
                }

                if(!obj.hasOwnProperty(key)){
                    console.log(obj[key]);
                }
            }

            
        3.in
            判断一个属性是否是属于某个对象的;
            var obj = {
                name : 'leecs',
                age : 123,
                sex : 'male',
                height : 196,
                weight : 75,
                __proto__ : {
                    lastName : 'lee',
                }
            };

            console.log('name' in obj);
            console.log('age' in obj);
            
        4.instanceof
            A instanceof B
            判断A是否是B构造函数构造出来的;
            其实是看对象 A 的原型链上是否有 B 的原型;
            function Person() {}
            var person = new Person();
            console.log(person instanceof Person);
            
            
            A instanceof B
            其实是看对象 A 的原型链上是否有 B 的原型;
            with(console) {
                log(person instanceof Person);
                log(person instanceof Object);
                log([] instanceof Array);
                log({} instanceof Object);
            }
    
    
            解释如下:
            Object.prototype.toString.call([]);
            Object.prototype.toString是一个函数引用;
            而.call()勇于改变this指向; 哪个函数调用call 哪个函数的this就是call()的第一个参数的this;
            就相当于把 function toString() {} 这个方法的this 全部指向了一个[]
            那么这个方法返回的结果就是识别this 的数据类型 返回字符串 "[object Array]";

            Object.prototype.toString = function () {
                new Array();
                new Number();
                new String();
                每个JavaScript内置的构造函数都是重写过的
                Object.prototype.toString() 原始对象上的toString();
                返回的是一个判断当前对象类型的字符串值;
                识别this
                返回this数据类型的相应结果;
                
            }


    
        判断array的三种方法;
            判断[].的构造函数是否是 function Array() {};
            [].constructor == Array;
            判断[].的原型链上是否有Array;
            [] instanceof Array
            通过Object的原型上的toString的方法this指向一个数组 看返回结果是什么;
            Object.prototype.toString.call([]);
            







            
            
            

拾肆.this深度解析
    习题
        第一题
        var x = 1, y = z = 0;
        function add(n) {
            return n = n + 1;
        }

        y = add(x);    -2
            
        function add(n) {
            return n = n - 3;
        }
                
        z = add(x);    -2




        第二题
        function foo() {
        bar.apply(null,argumnets);
        等同于
        bar(arguments);
        }
        function bar() {
            console.log(arguments);
        }

        foo(1,2,3,4,5);
            



            
        if后面的括号中是条件判断 会隐式类型转换 类型转换function并不是 为false的六个值, 就能够往下执行;
        但是括号会把里面的函数变成表达式的; 变成函数表达式了就不是函数定义了;
        就好像()立即执行函数的括号一样 变成表达式了, 这个函数名称 f 自然也就消失了;
        好比(function f() { console.log(f)}());
        var a = (function f() { console.log(f)}());   a 是undefined
        但是 f 消失了之后, 如果被typeof检测的话就会返回字符串的undefined;
        所以最后的结果是 1undefined;
        var x = 1;
        if(function f(){}){
            x = typeof f;
        }
        typeof(x);         1undefined;
            
            

            
            
            
            
    1.进制数
        满足一个数, 它从各位变成十位之后, 就叫进制;
        十进制数就是满十, 就向前进一位, 十分位就是1, 个分位就是0;
        十六进制就是满十六, 向前进一位, 十分位就是1, 个分位就是0; 
        十进制(9, 10, 11, 12, 13, 14, 15) === (9, 10, 11, 12, 13, 14, 15);
            
            
        十六进制中10不叫作十, 叫做十六进制的一零;
        十六进制的 1f === 16 + 15 === 31;(十分位的1代表十六, 个分位的f代表十五);
        十六进制 (9, a, b, c, d, e, f, 10) === (9, 10, 11, 12, 13, 14, 15, 16);
                

        二进制(就是满二进一, 个分位满二了, 十分位就会变成1, 10 === 2, 11 === 3);
            


        计算进制数规律;
            十进制(十进制 首位后面有几个零, 就是十的多少次方);
                1 == 1;
                10 == 10;
                100 == 10 ^ 2;(十的平方 or 十的二次方)
                100 == 10 ^ 2;(十的三次方)
                1000 == 10 ^ 4;(十的四次方)

                
            二进制(二进制 首位后面有几个零, 就是二的多少次方);
                1 == 1;
                10 == 2;
                100 == 2 ^ 2;
                1000 == 2 ^ 3;
                10000 == 2 ^ 4;
                    
                
                
    2.this
        1.函数预编译过程 this ==> window;
        2.全局作用域里this ==> window;
        3.call/apply可以改变函数运行时this指向;
        4.obj.fn(); fn()里面的this指向obj;

            
            1.函数预编译过程 this ==> window;
                function show(p) {
                    var a = 123;
                    function b() {
                        console.log(this);
                    }
                    b();
                }
                show(1);
                在函数预编译过程中形成的AO, 有一个与生俱来的arguments 指向的是实参列表;
                还有一个生来就有的就是this 指向的是 window(全局GO); 
                如果有new操作符: 就会有一个隐式的this转换;
                    var this = Object.create(show.prototype);
                就会将原来的this指向的window替换掉;
                    
                A0 : {
                    arguments : [1],
                    this : window,
                    a : undefined,
                    b : function () {},
                    p : 1,
                }
                    
            2.全局作用域里this ==> window;
                console.log(this);
                就是在全局中打印 this 理所当然就是指向全局GO(也就是window);

            3.call/apply可以改变函数运行时this指向;
                function foo() {
                    bar.apply(foo);
                }
                function bar() {
                    console.log(this);
                }

                foo(1,2,3,4,5);
                    
                var obj = {
                    name : 'abc',
                    a : function () {
                        console.log(this.name);
                    }
                }
                obj.a();
                    
                var obj1 = {
                    name : 'cba',
                }
                    
                obj.a.apply(obj1);

                    
            4.obj.fn(); fn()里面的this指向obj;
                意思就是谁调用这个函数, 这个函数的this指向谁;
                var obj = {
                    name : 'abc',
                    a : function () {
                        console.log(this.name);
                    }
                }
                obj.a();

                    
        this 习题;
                
            第一题;
            var name = '123',
                a = {
                    name : '111',
                    say : function () {
                        console.log(this.name);
                    }
                },

                fun = a.say;
                
            fun();         123;
            a.say();       111;
            var b = {
                name : '333',
                say : function (fun) {
                    console.log(fun);
                }
            }
                
            b.say = a.say;          
            b.say();           333;



            第二题;
            var name = '222',
                a = {
                    name : '111',
                    say : function () {
                        console.log(this.name);
                    }
                },
                b = {
                    name : '333',
                    say : function (fun) {
                        fun();
                    this ==> b;
                    然而fun() 执行只是在这个方法体里执行 并没有被调用(this.fun());
                    b.say中是a.say方法; a.say()执行是打印this.name 
                    b.say中this是b, 但是a.say()中this是并不是a, say只是a的say函数引用,一个单独的函数执行; 函数并没有被任何对象调用
                    }
                }

            b.say(a.say);
            所以b.say执行的是形参传入的a的say方法执行 这个方法打印this.name, 中间并没有被调用, this直到b.say() 执行完毕都是指向window;
                

            第三题
            var foo = 123;
            function print() {
                this.foo = 234;
                console.log(foo);
            }

            new print();       123;

            var this = Object.create(print.prototype); (隐式变量this 挂到 AO身上, 是AO的this里面有foo,而并不是AO里面有foo);
            所以console.log(foo) AO身上并没有, 向上查找到GO 有一个foo值为123;

            AO : {
                this : {
                    foo : 234;
                }
            }
            Go : {
                foo : 123;
            }
                

            第四题(运行test, 和new test的结果分别是什么);
                    
                var a = 5; 
                function test() {
                    a = 0;
                    console.log(a);
                    console.log(this.a);
                    var a;
                    console.log(a);
                }
                
                new test()     0, undefined, 0;
                test()         0, 5, 0,
                
            
    3.callee, caller;(ES5中的'use Strict'(标准模式)下不允许使用, 而且还会报错);
        1.arguments.callee;
        2.fu.caller;
            1.arguments.callee;(指向当前的函数引用);
                arguments.callee 指向的是test函数的引用;
                function test() {
                    console.log(arguments.callee);
                }
                test();
                    
                以下是一个递归求某数阶乘, 如果立执行函数来弥补性能上的不足, 但是函数立执行函数没有函数名称
                此时想要拿到函数名称(函数引用) 除了arguments.callee别无他法;
                    function factorial(num) {
                        if(num == 1){
                            return 1;
                        }
                        return num * factorial(num - 1);
                    }
                        
                    var factorial = (function (num) {
                        if(num == 1){
                            return 1;
                        }
                        return num * arguments.callee(num - 1);
                    }(10));
                    
            2.fu.caller;(指向执行环境, 如果在全局调用就为null);
                function test() {
                    console.log(test.caller);
                    demo();
                }

                function demo() {
                    console.log(demo.caller);
                }
                test();
        
            



















拾伍.arguments,克隆,三元,数组

    1.克隆
        var obj = {
            name : 'leecs',
            age : 30,
            card : ['visa', 'master'],
            wife : {
                name : 'monroe',
                son : {
                    name : 'trump',
                }
            }
        }
    
        var obj1 = {};
            
        浅层克隆;
            function clone(origin, target) {
                var target = target || {};
                for(var prop in origin) {
                    target[prop] = origin[prop];
                }
                return target;
            }
            
            clone(obj,obj1);

            
            
        深层克隆;
            
            递归深层克隆;
                function deepClone(origin, target) {
                    var target = target || {},
                        toString = Object.prototype.toString;
                    for(var prop in origin){
                        判断是否是对象身上的属性,而并非原型的;
                        if(origin.hasOwnProperty(prop)){
                            判断引用值和原始值;
                            if(origin[prop] !== 'null' && typeof(origin[prop]) == 'object'){
                                判断原始值是对象还是数;
                                target[prop] = toString.call(origin[prop]) == '[object Array]' ? [] : {}
                                if(toString.call(origin[prop]) == '[object Array]'){
                                    target[prop] = [];
                                }else {
                                    target[prop] = {};
                                }
                                递归
                                arguments.callee(origin[prop], target[prop]);
                            }else{
                                target[prop] = origin[prop];
                            }
                        }
                    }
                }
                
                deepClone(obj,obj1);

            
            
    2.三元运算;
        条件判断 ? 是 : 否 (比if语句要强大的一点是自己返回运算结果或者值);

        var num = 1 > 0 ? 2 + 2 : 1 + 1;
        
        var num = 1 > 0 ? ('10' > 9 ? 1 : 0) : 2
        
        
        
        
    3.数组
        数组的定义
            数组字面量 
                var arr = [];
                var arr = [1,,1];           [1, empty, 1];
                var arr = [,,,,];           empty 就是空值, length就是0;
                
                var arr = [1,,,,,2];            length是6, 中间的值不是undefined,也不是null,是一个真正意义的空值;

            数组构造函数;
                var arr = new Array();
                数组的所有方法都来源于Array.prototype;
                var arr = new Array(1,2,3,4,5);
                
                字面量和构造函数数组的区别
                var arr = new Array(10);
                var arr1 = [10];
                如果构造函数数组参数值填一位, 系统就会把这一个参数当成长度, 创建一个一参数为准的长度的空数组;
                
        数组的读写
            var arr = [1,2,3,4,5];
            console.log(arr[10]);
            在JavaScript中数组报错除非是引用了Array没有的方法, 否则是不会报错的; 比如: 访问数组长度以外的数组位返回undefined, 不会报错;
            
            因为arr是基于对象的; 如果arr[10]来访问 就相当于  obj[10], 所以数组就是另外一种形式的对象; 
            obj没有为10的属性就返回的是undefined, 和arr[10]是一样的;
            而且 取值没问题, 赋值也是没问题的
            arr[10] = 'abc';  这个数组第十位就是一个abc, 之前6789位没有的就都是empty;
            
        
        数组方法;
            改变原数组的方法(只有这七个方法能够改变原数组);
                push, pop, shift, unshift, sort, reverse, splice; 

                var arr = [1,2,3];
                arr.push(10,20,30);       返回值: 数组长度, 功能: 数组最后一位添加值;
                    模拟push方法;
                    Array.prototype.push = function () {
                        for (var i = 0; i < arguments.length; i++) {
                            不明确是arr, 还是arr1调用push方法; 所以只能用this代替调用者(调用myPush的对象);
                            this[this.length] = arguments[i];
                            arr的最后一位是push()参数中的每一位;
                        }
                        return this.length;
                    }
                
                arr.pop();              返回值: 剪切最后一位的值, 功能: 剪切(删除)最后一位, 传参无效;
                
                arr.shift();            返回值: 剪切第一位的值, 功能: 剪切(删除)第一位, 传参无效;

                arr.unshift();            返回值: 数组长度, 功能: 数组第一位添加值
                
                arr.reverse();           返回值: 数组反转后的结果, 功能: 反转数组;
                
                arr.splice(开始截取位, 截取长度, 切口处添加新的数据);            返回值: 截取的索引位数据, 功能: 数组剪接;
                    var arr = [1,2,3,5];    想要实现1,2,3,4,5; 在3和5之间加个4;
                    arr.splice(3,0,4);      第三位开始截取, 截取零位(不截取), 加入一个4;
                
                arr.sort();                返回值: 数组排序后的结果, 功能: 数组排序;
                    排序是按照阿斯克码排的; 数据10会被当成一零而小于2;
                    sort() 方法，有一个可选参数，必须是函数，供它调用

                    回调函数的参数要有两个：第一个参数的元素肯定在第二个参数的元素前面!!!

                    这个方法的排序是看回调函数的返回值：

                    如果返回值大于 0，则位置互换。
                    如果返回值小于 0，则位置不变。
                    var arr = [1,3,5,4,10];

                    arr.sort(function (a, b) {
                        a > b    另一种个表示方式    a - b > 0
                        if(a > b) {
                            return 1;
                        }else{
                            return -1;
                        }

                        如果2 > 1 返回2 - 1,
                        否则2 < 3 返回2 - 3;
                        无论如何都返回a - b; 并且结果也都是对的;
                        if(a > b) {
                            return a - b;
                        }else{
                            return a - b;
                        }

                        所以横竖有都是返回a - b 那么倒不如直接返回a - b了;
                        

                        return a - b;   升序;x
                        
                        if(a < b){
                            return 1;
                        }else {
                            return -1;
                        }
                        

                        if(a < b) {
                            return b - a;
                        }else{
                            return b - a;
                        }
                        
                        return b - a;   降序;
                        
                    })
                    
                
                
            不能改变原数组的方法:
                concat, join, split, toString, slice;
                    
                var arr = [1,2,3,4,5,6],
                    arr1 = [7,8,9,0];
                
                concat       连接两个数组
                    var result = arr.concat(arr1);
                    
                toString;        将数组改变成字符串;
                    var result = arr.toString();
                
                slice        数组截取, 不改变原数组所以只能接收他的返回值了,
                
                    slice();     没有参数就将整个截取; (截完之后就是一个数组); 以后一个类数组转换成一个数组,可以使用slice()来实现,
                    slice(开始截取位一直截取到结束);     一个参数
                    slice(开始截取位, 截取到该位);     两个参数
                        
                join         将数组的每一位连接返回字符串类型;
                    arr.join('-');   如果没有参数, 就会默认用逗号相连, 并且没有参数就和Array原型上系统重写过的toString()方法功能一样;
                    join和字符串的方法split是作用相反替补的;
                
                
                    
                    
    4.类数组
        1.可以利用属性名模拟数组的特性;
        2.可以动态的增长length属性
        3.如果强行让类数组调用push方法, 则会根据length属性值的位置进行属性的扩充;
        
            1.可以利用属性名模拟数组的特性;
                
                arr = ['a', 'b', 'c'];
                var obj = {
                    '0' : 'a',
                    '1' : 'b',
                    '2' : 'c',
                    'length' : 3,
                    'push' : Array.prototype.push,
                    'splice' : Array.prototype.splice,
                };
                以上就是一个类数组, 他必要的组成部分: 
                    1.属性为索引(0,1,2)属性;
                    2.必须有length属性; 
                    3.必须有splice方法, 类数组最好也加上一个Array的push方法,方便操作;
                    如果加上splice方法就是一个数组, name这个对象展示就不是{}, 而是[]数组的样子了, 那么就不仅是对象, 而且还可以当作数组使用;
                那么数组也不过就是比类数字多了Array.prototype原型以及原型链上的一些方法和属性;
                类数组不仅能想对象一样使用, 还能想数组一样使用, 他的存储结构就更强大(能够把数组和对象的特性拼到一起);
                DOM方法生成的所有类似于数组的东西,全是类数组;
            
            
    习题
        给一个有序的数组乱序;
        var arr = [1,2,3,4,5,6,7,8,9];
        arr.sort(function () {
            return Math.random() - 0.5;
        })

        
        根据对象的age属性进行排序;
        var leecs = {
            name : 'leecs',
            age : 18,
            sex : 'male',
        }
        var sunny = {
            name : 'sunny',
            age : 30,
            sex : 'male',
        }
        var monroe = {
            name : 'monroe',
            age : 40,
            sex : 'male',
        }
        
        var arr = [leecs, monroe, sunny];
        
        arr.sort(function (a,b) {
            
            return a['age'] - b['age'];
            
        })
        


        根据字符串长度排序;     
        var arr = ['a', 'bb', 'ccc', 'dddd', 'eeeee', 'ffffff', 'ggggggggg', 'asdfasdasdfasfdasdf', 'c', 'cc', 'ccc', 'ccccc', 'ccc', 'cccc'];
        
        arr.sort(function (a,b) {
            return a['length'] - b['length'];
        })
        
        
        obj此时是什么;
        var obj = {
            '2' : 'a',
            '3' : 'b',
            'length' : 2,
            'push' : Array.prototype.push,
        };
        obj.push('c');
        obj.push('d');
        console.log(obj);
        
        
        
        封装type方法, typeof() 返回的并不精准, 封装一个type方法和typeof一样, 凡是返回值一定准确;
        
            function type(target) {
                var template = {
                    "[object Array]" : "array",
                    "[object Object]" : 'object',
                    "[object Number]" : 'number - object',
                    "[object Boolean]" : 'boolean - object',
                    "[object String]" : 'string - object',
                },result = typeof target;
                switch (result) {
                    case null:
                        return 'null';
                    case "object":
                        var strType = Object.prototype.toString.call(target);
                        return template[strType];
                    default :
                        return result;
                };
            }

        数组去重, 要求在原型链上操作;

            var arr = [1,1,2,2,3,3,4,5,6];
            Array.prototype.unique = function () {
                var obj = {},
                    newArr = [];
                方法一;
                    for(let i = 0; i < this.length; i++) {
                        obj[this[i]] = 'a';
                    }
                    for(let item in obj) {
                        newArr.push(item);
                    }
                    return newArr;
                方法二
                    for(let i = 0; i < this.length; i++) {
                        if(!obj[this[i]]) {
                            obj[this[i]] = '随便添值';
                            newArr.push(this[i]);
                        }
                    }
                    return newArr;
            }

    































拾陆.try...catch,ES5标准模式;

    1.try{}catch(e){};   容错语句;
        在try代码块里面发生的错误, 不会影响try代码块外面的整个代码块的后续执行, 但是同样在try代码块中的错误不会执行;
        catch就是把错误捕捉到 而里面的参数error就是系统传过来的一个错误对象, 里面包含了两个信息一个是error.name, 一个是error.message;
        如果try没有错误就不会执行catch, 因为没错误就不会捕捉;
        try{
            console.log('s');
            console.log('a');
            console.log(a);
            console.log('b');
        }catch(e) {
            console.log(e);
            console.log(e.message + '   =======================')
            console.log(e.name + '   =======================');
        }
        console.log('d');
    
            
            
        错误信息分类:
            1.EvalError: eval()的使用与定义不一致;
                eval(); 可以使一段字符串当作代码块来执行;
                    var a = 's';
                    eval('console.log(a)');
            2.RangeError: 数值越界;
            3.ReferenceError: 非法或者不能识别的引用数值;
                如果一个变量未经声明就使用, 当一个函数没有声明就调用...等等;
                就是一系列的东西, 没有定义就使用了;
            4.SyntaxError: 语法解析错误;
                语法解析错误, 这种错误容错语句不会生效;
                
            5.TypeError: 操错类型错误;
                一般就是误用数组的方法操作了对象, 对象的方法操作了数组;
                或者对象中的属性重复..等, 对象的误操作, 就会发生这个错误信息;
            6.URLError: URL处理函数使用不当;
    
    
    
    
    
    2.ES5严格模式
        'use strict'
            不在兼容ES3的一些不规则语法, 使用全新的ES5规范;
            现在浏览器是基于ES3.0 和 ES5.0的新增方法使用的;
            
            严格模式启用之后: ES3 和 ES5产生冲突的部分就全面使用ES5规范;
            
        两种用法
            全局严格模式
                必须写在当前代码模块的最顶端, 之前不能有任何代码;
            局部函数内严格模式(推荐);
                局部定义仍然要卸载最顶端, 局部之前不能有任何代码;
                function test() {
                    "use strict";
                    console.log(arguments.callee);
                }
                test();

                
                function demo() {
                    console.log(arguments.callee);
                }
                demo();

        不支持 with, arguments.callee, function.caller, 变量赋值前必须声明, 局部this必须被赋值, 拒绝重复属性和参数;
            为什么严格模式的启动方式不是一个函数执行, 而是页面开头一段字符串?
                
                'use strict'
                之所以采用这种写法, 而不是采用 strict()的函数执行的写法是因为能够向下兼容浏览器不能识别而报错;
                因为老的浏览器如果没有升级到ES5的话就不会有strict方法 如果此时页面出现一个没有的strict() 函数调用就会发生引用错误;
                但是如果一串字符串放在页面中, 他就是一个表达式, 最起码不会报错;
                
            with();
                with可以改变作用域链, 它可以把它里面的代码的作用域链的最顶端, 变成with括号里面的对象;
                也就是说with代码块中 最多能访问的东西, 只有with括号中的对象;
                就是因为这么强大, 能够更改作用域链的东西, 所以对于JS引擎执行和浏览器的解析都是一个很大的性能消耗;
                所以就因为操作了作用域链的缘故, 在严格模式中考虑运行效率是禁止使用的;
                
                
                var obj = {
                    name : 'obj',
                }
                
                var name = 'window';
                
                function test() {
                    var name = 'scope';
                    with(obj) {
                        console.log(name);
                    }
                    
                }



                with 用处
                    命名空间的用法;
                    var org = {
                        department1 : {
                            leecs : {
                                name : 'leecs',
                                age : 18,
                            },
                            sunny : {
                                name : 'sunny',
                                age : 28,
                            }
                        },
                        department2 : {
                            xxx : {},
                        }
                    }
            
                    with(org.department1.leecs) {
                        console.log(name);
                    }
                    with(org.department1.sunny) {
                        console.log(name);
                    }
                    
                    

                    对象解构;
                    with(console) {
                        log('ss');
                    }
                    with(document) {
                        write('ss');
                    }

                    
            变量赋值前必须声明, 也就是不存在暗示全局变量;
                'use strict';
                var a = b = 1;

                
            局部的this必须被赋值, 也就是局部中的this不在默认指向window了, 而是undefined;
                'use strict';
                function person() {
                    console.log(this);
                }
                person();
                new person();
                person.call(123);
        
            拒绝重复属性和参数;
                'use strict';
                function test(name, name) {
                    console.log(name);
                }
                test('ss', 'aa');

                var obj = {
                    name : 'a',
                    name : 'b',
                }
            




























拾柒.DOM操作初探;
    
    




























拾捌.DOM选择器,节点类型;
     
    什么是DOM;
        1.Document(文档)
        2.Object(对象)
        3.Model(模型)
        
    DOM定义了表示和修改文档所需的方法. DOM也是一个对象别称宿主对象, 由浏览器厂商定义, 用来操作html和xml功能的一类对象的集合.
    也可以说DOM是对HTML以及XML的标准编程接口;
        什么是xml;
        xml是html的一个最早版本, 开始现有的是xml, 后来衍生xhtml, 现在是html4.0, 以及5.0; 这么一个过程
        xml和html唯一的不用就是可以标签名可以自定义, 由于这个特性XML和JSON一样, 就成为了一种数据存储结构一种数据存储方法了, 存储格式就是标签语义格式;
        最开始数据库的基本格式都是基于XML的, 现在被JSON格式慢慢取代了;
        DOM只能操作html 包括其中的属性等, 所以属性中有一个style可以操作样式, DOM可以间接的操作样式并不能直接操作css样式表, css为后缀的样式文件;
        
    节点类型
                                nodeType返回的节点值;
        元素节点                 1;
        属性节点                 2;
        文本节点                 3;
        注释节点                 8;
        document                 9;
        documentFragment         11;
        获取节点类型方法         nodeType;

        


    节点属性;
        每一个节点基本上都有四个属性;
        nodeName             (元素节点的标签名, 以大写形式表示, 只读;)
            var div = document.getElementsByTagName('div')[0];
            console.log(document.nodeName);
                document是个单独的节点类型;
            console.log(div.childNodes[0].nodeName);
                有内容的文本节点;
            console.log(div.childNodes[1].nodeName);
                注释节点;
            console.log(div.childNodes[2].nodeName);
                无内容的文本节点;
            console.log(div.nodeName);
                div的标签节点;
            console.log(div.lastElementChild.nodeName);
                em的标签节点;

        nodeValue            (attribute节点,Text节点或者Comment节点的文本内容, 可读写; 只有文本节点和注释节点或者属性节点有nodeValue属性,其他节点类型都没有这个属性);
            var div = document.getElementsByTagName('div')[0];
            console.log(div.childNodes[0].nodeValue);
                div.childNodes[0].nodeValue = '930316';
                console.log(div.childNodes[0]);
            console.log(div.childNodes[1].nodeValue);
                div.childNodes[1].nodeValue = 'that is Comment';
                console.log(div.childNodes[1]);

        nodeType             (返回该节点的类型, 只读;)
            var div = document.getElementsByTagName('div')[0];
            console.log(div.childNodes[0].nodeType + '====================123');
            console.log(div.childNodes[1].nodeType + '====================<!-- this is Comment');
            console.log(div.childNodes[2].nodeType + '====================emptyText');
            console.log(div.childNodes[3].nodeType + '====================<strong class=\'isStrong\' id="isStrongOnly"></strong>');
            console.log(div.childNodes[4].nodeType + '====================emptyText');

            封装一个能返回元素节点的方法;
            function retElementChild(node) {
                    
                创建一个类数组
                var classArr = {
                    length:0,
                    push: Array.prototype.push,
                    splice: Array.prototype.splice,
                },
                child = node.childNodes;
                for(var i = 0; i < child.length; i++) {
                    if(child[i].nodeType == 1) {
                        classArr.push(child[i]);
                    }
                }
                return classArr;
            }
                
            retElementChild(div);
                
            
        attributes           (Element 属性节点的集合, 只有元素节点才有这个属性; 可读写);
            var strong = document.getElementsByTagName('strong')[0];
            console.log(strong.attributes);
                属性节点集合;
            console.log(strong.attributes[0]);
                属性节点;
            console.log(strong.attributes[0].nodeType);
                属性节点返回2;

            通过attributes身上的value属性还可以取值和赋值!
            但是不可以更改name属性(也就是标签上的属性名 id class这些);
            console.log(strong.attributes[0].name);
            console.log(strong.attributes[0].value);
            strong.attributes[0].value = 'sss';
            console.log(strong.attributes[0]);
                
            strong.getAttribute('id') === strong.attributes[1].value === strong.attributes[1].nodeValue;
            strong.setAttribute('id', 'asdf') === (strong.attributes[1].value = 'asdf') === (strong.attributes[1].nodeValue = 'asdf');
                
                
                
        hasChildNodes();         (判断该元素是否有子节点, 返回布尔值);
            var div = document.getElementsByTagName('div')[0];
            var empty = document.getElementById('empty');
                console.log(div.hasChildNodes());
                console.log(empty.hasChildNodes());
        
            
        
    节点的查询;
        查找元素节点;
            document代表整个文档;
                document是页面不可展示的根元素, document是html的父元素; html.parentNode是document, docuemnt.parentNode是null,
                也就是说document就是顶级父元素;
                document是html标签以外的标签元素, 但是并不会显示出来, html是document中的根标签, 并不能代表整个文档;
            返回通过元素ID名称匹配的元素;
            document.getElementById()
                var div = document.getElementById('only');
            返回通过元素标签名称匹配的元素;
            document.getElementsByTagName();
                var p = document.getElementsByTagName('p')[0];
            返回通过元素name属性匹配的元素;(需要注意, 理论上只有部分表单标签name可生效, (表单元素, img, iframe), 现在任何标签的name属性都可以获取了);
            document.getElementsByName();
                var input =  document.getElementsByName('input')[0];
            返回通过元素类名匹配的元素;(可以多个class放在一起);
            document.getElementsByClassName();
                var classp = document.getElementsByClassName('class')[0];
            返回通过css查询选择器匹配的元素;(IE7 以及一下版本中不生效);
            document.querySelector();
                var strong = document.querySelector('div > span > strong');
                但是因为querySelect和querySelectAll不是实时的, 所以导致在用法上特别收局限, 虽然querySelect和All特别强大,
                但这个致命的缺点导致它并不常用在开发中, 除非特殊情况保存一个DOM元素副本保存起来, 否则很少使用;
                非实时就是当页面元素删除或者新增时, querySelect并不能同时动态变更查找到的元素, 原来查找到几个元素就定死了,
                如果再次新增或删除元素, querySelect返回的元素或者元素集合中不会在改变了, 也就是集合储存定死了第一次查找到的一个镜像;
                但是其他操作都是可以正常施行的;
                    
            返回通过css查询选择器匹配的元素集合;(IE7 以及一下版本中不生效);
            document.querySelectorAll();
                var strong = document.querySelectorAll('div > span > strong');
            返回一个创建的DIV元素;
            document.createElement('div');
                
            遍历节点树;
            parentNode          父节点(最顶端的parentNode为#document);
                var strong = document.getElementsByTagName('strong')[0];
                console.log(strong.parentNode);
                console.log(strong.parentNode.parentNode.parentNode.parentNode);
                    
            childNodes          子节点集合;
                var div = document.getElementsByTagName('div')[0];
                console.log(div.childNodes);
                console.log(div.childNodes.length);

            firstChild          第一个子节点;
                var div = document.getElementsByTagName('div')[0];
                console.log(div.firstChild);
                
            lastChild           最后一个子节点;
                var div = document.getElementsByTagName('div')[0];
                console.log(div.lastChild);
                
            nextSibling         下一个兄弟节点;
                var strong = document.getElementsByTagName('strong')[0];
                console.log(strong.nextSibling);
                
            previousSibling     前一个兄弟节点;
                var strong = document.getElementsByTagName('strong')[0];
                console.log(strong.previousSibling);
            

        基于元素节点树的遍历;(遍历元素节点的方法中除了children以外, 其他方法都是IE9以及IE9以下不兼容);
            parentElement           返回当前元素的父元素节点(IE不兼容);
                var strong = document.getElementsByTagName('strong')[0];
                console.log(strong.parentElement);
                    
            children                返回当前元素的子节点;
                var div = document.getElementsByTagName('div')[0];
                console.log(div.children);
                    
            node.childElementCount  ===  node.children.length;
                                    返回当前元素节点的子元素个数(后者IE不兼容);
                    
                var div = document.getElementsByTagName('div')[0];
                console.log(div.children.length);
                console.log(div.childElementCount);
                
            firstElementChild       返回第一个元素节点(IE不兼容);
                var div = document.getElementsByTagName('div')[0];
                console.log(div.firstElementChild)
                
            lastElementChild        返回最后一个元素节点(IE不兼容)
                var div = document.getElementsByTagName('div')[0];
                console.log(div.lastElementChild);
                
            nextElementSibling      返回下一个兄弟元素节点(IE不兼容);
                var span = document.getElementsByTagName('span')[0];
                console.log(span.nextElementSibling);

            previousElementSibling  返回上一个兄弟元素节点(IE不兼容);
                var span = document.getElementsByTagName('span')[0];
                console.log(span.previousElementSibling);
                
                
                
        













拾玖.DOM继承树,DOM基本操作

    DOM结构树(表示的也是继承关系);
    Node        1.Document              HTMLDocument
                                        XMLDocument
        
                2.CharacterData         1.Text
                                        2.Comment
                
                3.Element               HTMLElement             1.HTMLHeadElement
                                                                2.HTMLBodyElement
                                                                3.HTMLTitleElement
                                                                4.HTMLParagraphElement
                                                                5.HTMLInputElement
                                                                6.HTMLTableElement
                                                                7.  ...etc...
                4.Attr
    
    
        1.Document
            Document并不是docuemnt直接的构造函数;
            document的构造函数是HTMLDocument, 而并不是Document;
            
                document.__proto__  === HTMLDocument.prototype;
                HTMLDocument.prototype.__proto__ === Document.prototype;
                Document.prototype.__proto__ === Node.prototype;
                Node.prototype.__proto__ === EventTarget.prototype;
                EventTarget.prototype.__proto__ === Object.prototype;

        2.CharacterData
            Text(文本节点的方法直接继承自Text.prototype)
            Comment(文本节点的方法直接继承自Comment.prototype)
            

        3.Element
            每一个标签都是一个对象, 他们的构造函数分别是  (HTML{标签名}Element);
            HTMLElement.prototype.test = 'test';
            HTMLBodyElement.prototype.test = 'test';
            var body = document.getElementsByTagName('body')[0];
            var body = document.body;           (document身上只有两个系统定义好的元素就是body和head);
            var head = document.getElementsByTagName('head')[0];
            var head = document.head;           (document身上只有两个系统定义好的元素就是body和head);
            console.log(body.test);
            console.log(head.test);

    
    
    DOM基本操作;
        1.getElementById方法定义在了Docuemnt.prototype上, 
            也就说明: Element 节点上不能用, 但是HTML和XML可以使用;
        2.getElementsByName方法定义在了HTMLDocument.prototype上,
            也就说明: 非html中的document不能使用 比如: XMLDocument, Element;
        3.getElementsByTagName方法定义在了Document上.prototype上和Element.prototype上;
            也就说明: Element和Document都可以使用这个方法;
            div.getgetElementsByTagName('*')[0];
            不光document有这个方法, Element(div, p, span)标签元素身上也都有这些方法;
        4.HTMLDocument.prototype定义了一些常用的属性, body,head, 分别指代HTML文档中的<body></body>,<head></head>元素;
            document是HTMLDocument.prototype构造出来的, 所以说: document有系统定义好的两个属性就是body和head;
            console.log(document.body);
            console.log(document.head);
        5.Document.prototype上定义了一个documentElement属性, 指代文档的根元素;
            document.documentElement它指的就是<html></html>
            console.log(document.documentElement);
        6.getElementsByClassName, querySelector, querySelectorAll; 在Document.prototype和Element.prototype类中均有定义;
            跟标签选择器一样都可以在标签元素上使用;
            div.getElementsByClassName('class')[0];
            div.querySelector('select');
            div.querySelectorAll('select')[0];

        
    
    DOM元素节点增删改查
        增(所有增加的标签只是JS引擎创建了, 但是并不是document中的, 所以我们要appendChild添加到某个页面中的元素中之后才可以出现在document中);
            document.createElement();创建元素节点;
                var div = document.createElement('div');
            document.createTextNode();创建文本节点;
                var text = document.createTextNode('leecs');
            document.createComment();
                var comment = document.createComment('leecs is cool  leecs is cool  leecs is cool  leecs is cool  leecs is cool');
            document.createDocumentFragment();
                
        
        插
            PARENTNODE.appendChild();
                任何一个元素节点都有一个appendChild方法, 可以理解成push, 在一个元素集合(类数组)的最后一位插入一个元素;
                var div = document.createElement('div'),
                    span = document.createElement('span'),
                    text = document.createTextNode('文本节点'),
                    comment = document.createComment('leecs is cool  leecs is cool  leecs is cool  leecs is cool  leecs is cool');
                document.body.appendChild(div);
                div.appendChild(span);
                span.appendChild(text);
                div.appendChild(comment);
                如果span再次appendChild了注释节点, 那么就会将div.appendChild的注释节点覆盖掉;
                只创建了一次的节点(任何节点)只能被appendChild一次;
                span.appendChild(comment);

                而且appendChild还会让页面原有的结构改变, h4和h5兄弟节点通过appendChild变为父子节点;
                var h4 = document.getElementsByTagName('h4')[0];
                var h5 = document.getElementsByTagName('h5')[0];
                h4.appendChild(h5);
            PARENTNODE.insertBefore(a,b);
                父元素.insertBefore(插入元素, 在哪个元素之前);
                var div = document.getElementsByClassName('insertBefore')[0],
                    span = div.getElementsByTagName('span')[0];
                    strong = document.createElement('strong');
                strong.appendChild(document.createTextNode('strong'));
                div.insertBefore(strong, span);

                
        删
            parent.removeChild();
                父级removeChild返回被删除的元素, 相当于剪切的功能;
                var div = document.getElementsByClassName('removeChild')[0];
                div.removeChild(document.querySelector('.removeChild span'));
            child.remove();
                没有返回值, 返回undefined, 相当于真正的销毁了;
                var div = document.getElementsByClassName('removeChild')[0];
                div.remove();
                
        替换
            parent.replaceChild(new, origin);
            var div = document.getElementsByClassName('replaceChild')[0],
                span = document.querySelector('.replaceChild span');
                strong = document.createElement('strong');
            div.replaceChild(strong,span);
            返回被替换后的元素;


    
    DOM元素节点属性/方法;

        innerHTML    (获取/写入 一个元素的内容  并且写入标签会当作HTML解析);
            var div = document.getElementsByClassName('innerHTML')[0];
            console.log(div.innerHTML);
            div.innerHTML += '<span style="background:red;color:yellow;">我爱你</span>';
            console.log(div.innerHTML);
        
        innerText    (获取/写入  一个元素的文本内容   但是写入的标签会当作纯文本解析);火狐不好使;
        textContent  (获取/写入  一个元素的文本内容   但是写入的标签会当作纯文本解析);老版本IE不好使
            var div = document.getElementsByClassName('innerText')[0];
            div.innerText += '<span>sss</span>'
            div.textContent += '<span>sss</span>'
            
        setAttribute(属性名, 属性值);  (给一个元素节点设值属性);
            var div = document.getElementsByClassName('setAttribute')[0];
            div.setAttribute('id', 'setAttribute');
        
        getAttribute(属性名);
            var div = document.getElementsByClassName('getAttribute')[0];
            console.log(div.getAttribute('class'));
        
        removeAttribute();
            var div = document.getElementsByClassName('removeAttribute')[0];
            console.log(div.removeAttribute('style'));
        
        className,id     (查看/更改  元素节点的类名和id);
            var div = document.getElementById('id');
            console.log(div.className);
            console.log(div.id);
            div.className = '改过了class';
            div.id = '改过了ID';
            console.log(div.className);
            console.log(div.id);
            
        
            
    

    习题
        1.遍历元素节点树,(在原型链上编程);
            
        2.封装函数, 返回元素e的第n层祖先元素节点;
            var i = document.getElementsByTagName('i')[0];
            function returnParent(ele,n){
                
                判断条件的意思是如果ele是null的时候就为false直接返回ele;
                while(ele && n) {
                    ele = ele.parentElement;
                    n--;
                }
                return ele;
            }
            
        3.封装函数, 返回元素e的第n个兄弟元素节点; n为正, 返回后面的兄弟元素节点, n为负, 返回前面的, n为0, 返回自己;
            var h1 = document.getElementsByTagName('h1')[0];
            function returnSibling(ele, n) {
                while(ele && n){
                    if(n > 0) {
                        兼容IE9--
                        if(ele.nextElementSibling) {
                            ele = ele.nextElementSibling;
                        } else {
                            for(ele = ele.nextSibling; ele && ele.nodeType != 1; ele = ele.nextSibling) ;
                        }
                        n--;
                    } else {
                        if(ele.previousElementSibling) {
                            ele = ele.previousElementSibling;
                        } else {
                            for(ele = ele.previousSibling; ele && ele.nodeType != 1; ele = ele.previousSibling) ;
                        }
                        n++;
                    }
                }
                return ele;
            }
        
        4.编辑函数, 封装myChildren功能, 解决以前部分浏览器的兼容性问题, 不可以使用children属性;
            var div = document.getElementsByTagName('div')[0];
            Element.prototype.myChildren = function () {
                var arr = [];
                for(var i = 0; i < this.childNodes.length; i++) {
                    if(this.childNodes[i].nodeType == 1) {
                        arr.push(this.childNodes[i]);
                    }
                }
                return arr
            }

        5.自己封装hasChildren()方法, 不可用children属性;
            var div = document.getElementsByTagName('div')[0];
            Element.prototype.hasChildren = function () {
                for(var i = 0; i < this.childNodes.length; i++) {
                    if(this.childNodes[i].nodeType == 1) {
                        return true;
                    }
                }
                return false;
            }

        6.创建一个div, 给他的子元素设置一个this-name属性;
            var div = document.createElement('div'),
                span = document.createElement('span'),
                strong = document.createElement('strong'),
                address = document.createElement('address');
            document.body.appendChild(div);
            div.appendChild(span);
            div.appendChild(strong);
            div.appendChild(address);

            for(var i = 0; i < div.children.length; i++) {
                div.children[i].setAttribute('this-name', div.children[i].nodeName);
                div.children[i].innerHTML += div.children[i].tagName;
                div.children[i].innerHTML += div.children[i].nodeName;
            }

        
        7.封装函数insertAfter(), 功能类似于insertBefore(), (在Element.prototype上编程);
                var div = document.createElement('div'),
                    pre = document.createElement('pre'),
                    span = document.createElement('span'),
                    strong = document.createElement('strong');
                document.body.insertBefore(div, document.getElementsByClassName('className')[0]);
                div.appendChild(pre);
                div.appendChild(strong);
                div.className = 'inserAfter';
                    
                Element.prototype.insertAfter = function (insertEle, targetEle) {
                    var nextEle = targetEle.nextElementSibling;
                    if (nextEle == null) {
                        this.appendChild(insertEle);
                    } else {
                        this.insertBefore(insertEle, nextEle);
                    }
                }

                div.insertAfter(span, pre);
                
            
                
        8.将目标节点内部的节点顺序逆序;

    


    
    

















贰拾.date对象,定时器
    
            
    日期对象(是系统提供的 new Date());
        var date = new Date();
        console.log(date);
        Date对象方法;
            
            Date()                  返回当前日期和时间的字符串形式;
                console.log(Date());
            getDate();              从Date对象中返回一个月中的某一天(1 - 31);
                 console.log(date.getDate());
            getDay();                从Date对象中返回一周中的某一天(0 - 6);
                console.log(date.getDay());
                周日返回零, 周一返回一, 周六返回六;
            getMonth();              返回当前月份, (0 - 11);
                console.log(date.getMonth());
                一月返回零, 十二月返回十一;
            getFullYear();           返回四位数的年份;
                console.log(date.getFullYear());
            getHours();              返回当前小时(0 - 23);
                console.log(date.getHours());
            getMinutes();            返回当前的分钟数(0 - 59);
                console.log(date.getMinutes());
            getSeconds();            返回当前秒数(0 - 59);
                console.log(date.getSeconds());
            getMilliseconds();       返回当前毫秒数(0 - 999);
                console.log(date.getMilliseconds());
            getTime();               返回1970年1月1日至今的毫秒数, (时间戳);
                console.log(date.getTime());

                var firstTime = new Date().getTime();
                for(var i = 0; i < 100000000; i++) {};
                var secondTime = new Date().getTime();
                console.log(secondTime - firstTime);
            
            setDate();               设置date对象中的月份的某一天, 返回一段调整过的日期毫秒表示;
                console.log(date);
                date.setDate(21);
                console.log(date);

            setMonth()	                设置 Date 对象中月份 (0 ~ 11)
                console.log(date);
                date.setMonth(11 - 1);
                console.log(date);
                
            setFullYear()	            设置 Date 对象中的年份（四位数字）
                console.log(date);
                date.setFullYear(1993);
                console.log(date);
                
            setHours()	                设置 Date 对象中的小时 (0 ~ 23)
                console.log(date);
                date.setHours(23);
                console.log(date);
                
            setMinutes()	                设置 Date 对象中的分钟 (0 ~ 59)
                console.log(date);
                date.setMinutes(50);
                console.log(date);

            setSeconds()	                设置 Date 对象中的秒钟 (0 ~ 59)
                console.log(date);
                date.setSeconds(35);
                console.log(date);

            setMilliseconds()	        设置 Date 对象中的毫秒 (0 ~ 999)
                console.log(date);
                date.setMilliseconds(999);
                console.log(date);

            setTime()	                以毫秒设置 Date 对象    
                console.log(date);
                date.setTime(1569142246751);
                console.log(date);

                设置到56分的一个时间, 如果现在的时间大于56分时, 每间隔一秒执行一次handler;
                date.setMinutes(56);
                setInterval(function () {
                    if(new Date().getTime() > date.getTime()) {
                        console.log('handler');
                    }
                },1000);

                
                设置时间戳( 里面是立即执行函数求一个定义时间的时间戳,然后返回 );
                date.setTime((function () {date.setDate(22); date.setMinutes(09); return date.getTime() }()));
                setInterval(function () {
                    if (new Date().getTime() > date.getTime()) {
                        console.log('handler');
                    }
                },1000);

            toString();              把时间对象转换成字符串形式;
                console.log(date.toString());

                
    定时器(window上的方法, 内部的this全指向的是Global);
        setInterval();               设置定时器;

            setInterval(function () {
                console.log('asdf');
            },1000)


            每一个setInterval都会返回一个数字作为这个定时器的唯一标识;
            var time = setInterval(function () {}, 1000);
            console.log(time);
            
            
            证明JS的定时器是不准的;
            var firstTime = new Date().getTime();
            setInterval(function () {
                var lastTime = new Date().getTime();
                console.log(lastTime - firstTime);
                firstTime = lastTime;
            },1000);
            
        clearInterval();             清除定时器;
            参数是interval的返回值, 就是他的一个唯一标识;
            
            var time = setInterval(function () {console.log('ss')}, 1000);
            clearInterval(time);

            var i = 0;
            setInterval(function () {
                console.log(i++);
                if(i > 10) {
                    clearInterval(1);
                }
            })
            同等于以下的写法;
            var i = 0;
            var time = setInterval(function () {
                console.log(i++);
                if(i > 10) {
                    clearInterval(time);
                }
            })

    延时器(window上的方法, 内部的this全指向的是Global);
        setTimeout();            同setInterval是一样的, 不同点就是他在延迟执行后只执行一次;
            setTimeout(function () {
                console.log('timeout');
            },1000);

        clearTimeout();          他们的返回值是不会重写覆盖的;timeout是1, interval就是2, 是不会重叠覆盖的;
            var time = setTimeout(function () {
                console.log('settimeout');
            })
            clearTimeout(time);
            
                
        定时器,延时器的第一个参数如果是字符串也会有eval的功能, 当成代码来执行;
        
            setInterval("console.log('asdf')", 1000);

            function handler() {console.log('asdf')};
            setInterval(handler,1000);
                
        
                    
    习题
        1.封装函数, 打印当前是何年何月何日, 几时几分几秒;
            
        2.计时器, 到三分钟时停止;
            
            var minutesEle = document.getElementsByTagName('input')[0],
                secondsEle = document.getElementsByTagName('input')[1],
                minutes = 0,seconds = 0;
            var interval = setInterval(function () {
                seconds++;
                if (seconds == 59) {
                    seconds = 0;
                    minutes++;
                }
                secondsEle.value = seconds;
                minutesEle.value = minutes;

                if (minutes == 3) {
                    clearInterval(interval);
                }
                
            },50)




















贰壹.获取窗口属性,获取BOM尺寸,脚本化CSS

    
        
        var div = document.getElementsByClassName('box')[0],
            offsetLeft = document.getElementById('offsetLeft');
        
        获取窗口属性, 获取BOM尺寸, 脚本化CSS;
            1.查看滚动条的滚动距离;
                window.(pageXOffset/pageYOffset); (IE8以及IE8以下不兼容);
                    滚动条水平的滚动距离
                    console.log(window.pageXOffset);
                    滚动条垂直的滚动距离;
                    console.log(window.pageYOffset);
                    
                (document.body/documentElement).(scrollLeft/scrollTop);(IE8以及IE8以下方法);
                    滚动条水平的滚动距离;
                    console.log(documentElement.scrollLeft + document.body.scrollLeft);
                    滚动条垂直的滚动距离;
                    console.log(documentElement.scrollTop + document.body.scrollTop);
                        兼容行混乱问题, 虽然他们都是解决IE8以下兼容的, 但是有一个很复杂的兼容;
                        如果一个浏览器中documentElement.scrollLeft有值, 那么document.body.scrollLeft一定没值;
                        同样, 如果document.body.scrollLeft有值, 那么documentElement.scrollLeft一定没值;
                        所以以上结论: 处理IE8下问题为了更好的解决兼容问题最好的就是两者相加;因为这俩方法之间只会存在一个有值的!
                    window.addEventListener('scroll',function () {
                        console.log(documentElement.scrollTop + document.body.scrollTop);
                    })

                    
            2.查看可是区域窗口的尺寸;
                window.(innerWidth/innerHeight);(IE8以及IE8以下不兼容);
                    屏幕的宽度;
                    console.log(window.innerWidth);
                    屏幕的高度;
                    console.log(window.innerHeight);
                
                文档开头有<!DOCTYPE html>标签代表标准模式, 如果没有<!DOCTYPE html>就代表怪异(混杂)模式;
                浏览器会读取文档模式进行页面渲染; 怪异模式一旦启动JS引擎识别的语法就会想前兼容, 就是能够识别IE6之前的语法;
                (document.documentElement/document.body).(clientWidth/clientHeight);(IE8以及IE8以下的方法);
                    IE8下获取屏幕的宽度;     标准模式下生效;
                    console.log(document.docuemntElement.clientWidth)
                    IE8下获取屏幕的宽度;     怪异(混杂)模式下生效;
                    console.log(document.body.clientWidth);
                
        
            3.查看元素的几何尺寸
                dom.getBoundingClientRect(),  (兼容性很好)
                返回一个对象; 对象里面有left, top, right, bottom等属性; 
                left和top代表该元素左上角的X坐标和Y坐标, right和bottom代表元素右下角的X坐标和Y坐标;
                
                    var div = document.getElementsByClassName('box')[0];
                    console.log(div.getBoundingClientRect());
                    
                但是返回的结果并不是实时的;
                    
                    var boxObj = div.getBoundingClientRect();
                    div.style.width = '200px';
                    console.log(boxObj);
                    证明只是一个静态写照, 并不会实时更新;
                
            4.查看元素的尺寸
                
                dom.(offsetWidth/offsetHeight);
                    查看元素的宽度;
                    console.log(div.offsetWidth);
                    查看元素的高度;
                    console.log(div.offsetHeight);

            5.查看元素的位置
                dom.(offsetLeft/offsetTop);
                对于无定位父级的元素, 相对的是文档的坐标. 对于有定位父级的元素, 相对的是最近的有定位的父级元素;
                    查看元素距离左边距离
                    console.log(offsetLeft.offsetLeft);
                    查看元素距离上边的距离
                    console.log(offsetLeft.offsetTop);
                    
                dom.offsetParent
                    返回最近的有定位的父级元素, 如果没有返回body, body.offsetParent返回null;
                    var offsetParent = document.getElementsByClassName('offsetParent')[0],
                        div = offsetParent.children[0];
                    div的父级定位元素是div.offsetParent元素;
                    console.log(div.offsetParent);
                    div.offsetParent的父级元素是body(最顶级的父级定位元素);
                    console.log(offsetParent.offsetParent);
                    body是最顶层的定位元素;
                    console.log(offsetParent.offsetParent.offsetParent);

            6.滚动条滚动;
                window上有三个方法, (不光是所有dom元素都有这三个方法);
                domEle.scroll/scrollTo();  scrollBy();
                    scroll和scrollTo(x, y);两个方法是一样的, 兼容也是一样的;
                    第一个参数是滚动条的X轴坐标, 第二个参数是滚动条的Y轴坐标, 可以设置滚动条;
                        将滚动条返回到顶部;
                        console.log(window.scrollTo(0,0))
                        将滚动条设定到距离顶部500px的位置;
                        console.log(window.scrollTo(0,500))
                    
                    scrollBy(); 和scrollTo/scroll()方法类似,参数也相同; 区别: By会在之前的数据基础上做累加;
                        console.log(window.scrollBy(0, 10));
            
            
            7.滚动条位置
                domEle.scrollTop; (垂直元素滚动条距离顶部距离);
                domEle.scrollLeft; (水平元素滚动条距离左边距离);
                domEle.scrollHeight(垂直方向元素滚动条的长度);
                domEle.scrollWidth(水平方向元素滚动条的长度);
                domEle.clientWidth(元素可视区域的宽度);
                domEle.clientHeight(元素可视区域的高度);


            window.scrollTo(0, 9999);

            
            
            脚本化CSS;(JS 中只有style这个对象来写入样式属性, 别的方法都只是可以读取, 都不能写入操作);
                domEle.style.prop; 可读写行间样式, 没有兼容性问题, 遇到float这样的保留字属性, 前面应加CSS;
                    div.style.float
                    div.style.cssFloat;

                domEle.style返回一个类数组, 一个CSS的声明(就是这个元素可以使用的css属性集合);
                domEle.style这个对象是可读可写的; 而且无论是读取还是写入操作的都是行间样式; 内部样式表和外链样式不会被读取到;
                    var div = document.getElementsByClassName('scriptCSS')[0];
                    读
                    console.log(div.style['width'])
                    写
                    div.style['border'] = '10px solid #000';
                    

                    
                查询行间样式;
                    window.getComputedStyle(ele, null);(W3C标准方法);
                        
                        获取样式的一个方法(获取的都是计算过的, 所以只能读取, 不能写入, 写入操作会报错,这个方法获取的属性是计算过的);
                        var div = document.getElementsByClassName('getComputedStyle')[0];
                        这里返回的还是CSSStyleDeclaration 这个对象;
                        和style返回的不同之处在于, computedStyle获取的是当前元素所展示出的一切CSS的显示值, 包括默认值;
                        并且getComputedStyle可以找到这个元素在内部样式表和外部样式表以及行内样式的一切 CSS 属性; 返回权重最高的属性;
                        而style只是操作行内属性的;
                        
                        console.log(window.getComputedStyle(div,null));
                        console.log(window.getComputedStyle(div,null).width);
                        
                        第二个参数是获取伪元素样式的一个方法;
                        console.log(window.getComputedStyle(div, 'after'));
                        console.log(window.getComputedStyle(div, 'after').width);

                        
                        计算样式只读;
                        返回的计算样式的值都是绝对值; 没有相对单位;

                        
                        
                    domEle.currentStyle.prop;(IE8以及一下版本的方法);

                        和W3C的getComputedStyle属性是功能是一样的, 只不过是IE8以及一下版本独有的属性;
                        var div = document.getElementsByClassName('getComputedStyle')[0];
                        console.log(div.currentStyle);





        习题:
            封装一个兼容方法, 求滚动轮滚动距离getScrollOffset();
                function getScrollOffset() {
                    if(window.pageXOffset){
                        return {
                            x : window.pageXOffset,
                            y : window.pageYOffset,
                        }
                    } else {
                        return {
                            x : document.documentElement.scrollLeft + document.body.scrollLeft,
                            y : document.documentElement.scrollTop + document.body.scrollTop,
                        }
                    }
                }

            封装一个兼容方法, 求页面的可视区宽度;
                function getClientOffset() {
                    if(window.innerWidth) {
                        return {    
                            w : window.innerWidth,
                            h : window.innerHeight,
                        }
                    } else {
                        document上的compatMode方法判断文档如果是怪异模式就会返回BackCompat;
                        debugger;
                        if(document.compatMode = 'BackCompat') {
                            return {
                                w : document.body.clientWidth,
                                h : document.body.clientHeight,
                            }
                        } else {
                            return {
                                w : document.documentElement.clientWidth,
                                h : document.documentElement.clientHeight,
                            }
                        }
                    }
                }

            求元素相对于文档的坐标 getElementPosition;
                
            模拟实现阅读器自动滚动;
                    
                var div = document.createElement('div'),
                    divBoxFirst = document.getElementsByClassName('box')[0],
                    start = document.createElement('div'),
                    stop = document.createElement('div'),
                    body = document.body,
                    time,key = true;
                
                body.insertBefore(div, divBoxFirst);
                div.className = 'readerContent';
                div.innerHTML =
                    `
                        吴邪和胖子来到亨得烈博物馆，一般书画的保存要防光防尘，尤其是紫外线对书画损伤特别大，这里的书画却直接被光线照射，十分不专业。吴邪准备找馆长说说看，胖子想要劝吴邪却没有劝住。吴邪找到馆长亨得烈，但他不知道这个亨得烈就是阿宁的老板裘德考。吴邪跟亨得烈讲了书画要如何保存，结果亨得烈却称那些是明清两朝的文物，作者名气不大，价值一般，对他来说就如同废纸一般。吴邪这才意识到亨得烈只是商人，跟他说那么多是一点意义也没有。
                        
                        吴邪和胖子找到一旁的工作人员，打听有关拍卖会和博物馆里是否有蛇眉铜鱼的事，结果却被告知根本没有拍卖会的事，也没有见过蛇眉铜鱼。忽然，吴邪在人群中看见三叔的身影，三叔正匆匆地离去。吴邪连忙追了上去，却不见了三叔。吴邪肯定那个人就是三叔，他继续追了上去，果真看见三叔正跟一个老外在说话，还把手中的箱子给了老外，而这个老外刚刚就跟馆长亨得烈在一起。

                        吴邪和胖子准备上前找三叔，可转眼三叔就不见了，最后决定跟踪跟三叔见面的那个老外。吴邪心中存疑，这个老外拿着三叔的箱子要去什么地方，三叔和亨得烈又是什么关系，还有拍卖会又是怎么回事。吴邪感觉他的生活四处都是谜团，四面八方都是入口，走出去才发现每一条路都是死路。胖子劝吴邪要控制情绪，不要那么较真。可吴邪收到的短信和网页都在指引他们来到这里，并且认为能找到蛇眉铜鱼，可来到这里才发现什么都没有。

                        胖子早就说过这里面透露着阴谋诡计，是有人在设局。吴邪不相信三叔会对他设局，胖子并没有说是三叔，还开玩笑说很可能是阿宁的公司，因为在海底墓没有弄死吴邪，所以选择在国外。只是阿宁把三叔和考古队的事说得有鼻子有眼，还有解连环死的时候拿着蛇眉铜鱼，吴邪因此怀疑还有一个蛇眉铜鱼是在阿宁手上。
                        吴邪和胖子来到拍卖会上，只是他们没有邀请函，无法进入会场。好在有个女的见吴邪长得帅气，声称吴邪是她的同伴，成功将吴邪带进会场。到了会场的吴邪看到拍卖的手册，上面果真有蛇眉铜鱼。胖子假装是会场的服务员混了进来，他告诉吴邪在潘家园见过那个老外，是个中国通，对手工艺品特别感兴趣，到处拜师学艺，就不学好事。是个文物贩子，拍卖会里的那些东西就是他们在倒腾，胖子是恨不得把他们拉出去枪毙。

                        吴邪感慨没有信仰是建不成眼前这么大的金塔，就像一个信仰的支撑，才能守住小城，所以信仰很重要。胖子的信仰就是钞票，吴邪的信仰就是做一切有意义的事情，他今晚是一定要把蛇眉铜鱼拍下来。拍卖东西要很多钱，可吴邪没钱，只得打电话四处借钱，可对方听说是借钱，就找各种理由拒绝。胖子见吴邪为了借钱的事愁眉不展，偷偷地把他在潘家园的房子给卖了帮吴邪。

                        拍卖会正式开始，第一件拍品是一个瓷瓶，拍卖师介绍这件瓷瓶的历史是出自圆明园。吴邪不想属于中国的文物落入外国人之手，他竞起价来。胖子提醒吴邪他们来的目的是拍下蛇眉铜鱼，像瓷瓶那样的文物有很多，他们根本拍不回来。可吴邪还是执意竞价，最终拍下这件瓷瓶。
                        吴邪和胖子来到亨得烈博物馆，一般书画的保存要防光防尘，尤其是紫外线对书画损伤特别大，这里的书画却直接被光线照射，十分不专业。吴邪准备找馆长说说看，胖子想要劝吴邪却没有劝住。吴邪找到馆长亨得烈，但他不知道这个亨得烈就是阿宁的老板裘德考。吴邪跟亨得烈讲了书画要如何保存，结果亨得烈却称那些是明清两朝的文物，作者名气不大，价值一般，对他来说就如同废纸一般。吴邪这才意识到亨得烈只是商人，跟他说那么多是一点意义也没有。

                        吴邪和胖子找到一旁的工作人员，打听有关拍卖会和博物馆里是否有蛇眉铜鱼的事，结果却被告知根本没有拍卖会的事，也没有见过蛇眉铜鱼。忽然，吴邪在人群中看见三叔的身影，三叔正匆匆地离去。吴邪连忙追了上去，却不见了三叔。吴邪肯定那个人就是三叔，他继续追了上去，果真看见三叔正跟一个老外在说话，还把手中的箱子给了老外，而这个老外刚刚就跟馆长亨得烈在一起。

                        吴邪和胖子准备上前找三叔，可转眼三叔就不见了，最后决定跟踪跟三叔见面的那个老外。吴邪心中存疑，这个老外拿着三叔的箱子要去什么地方，三叔和亨得烈又是什么关系，还有拍卖会又是怎么回事。吴邪感觉他的生活四处都是谜团，四面八方都是入口，走出去才发现每一条路都是死路。胖子劝吴邪要控制情绪，不要那么较真。可吴邪收到的短信和网页都在指引他们来到这里，并且认为能找到蛇眉铜鱼，可来到这里才发现什么都没有。

                        胖子早就说过这里面透露着阴谋诡计，是有人在设局。吴邪不相信三叔会对他设局，胖子并没有说是三叔，还开玩笑说很可能是阿宁的公司，因为在海底墓没有弄死吴邪，所以选择在国外。只是阿宁把三叔和考古队的事说得有鼻子有眼，还有解连环死的时候拿着蛇眉铜鱼，吴邪因此怀疑还有一个蛇眉铜鱼是在阿宁手上。
                        吴邪和胖子来到拍卖会上，只是他们没有邀请函，无法进入会场。好在有个女的见吴邪长得帅气，声称吴邪是她的同伴，成功将吴邪带进会场。到了会场的吴邪看到拍卖的手册，上面果真有蛇眉铜鱼。胖子假装是会场的服务员混了进来，他告诉吴邪在潘家园见过那个老外，是个中国通，对手工艺品特别感兴趣，到处拜师学艺，就不学好事。是个文物贩子，拍卖会里的那些东西就是他们在倒腾，胖子是恨不得把他们拉出去枪毙。

                        吴邪感慨没有信仰是建不成眼前这么大的金塔，就像一个信仰的支撑，才能守住小城，所以信仰很重要。胖子的信仰就是钞票，吴邪的信仰就是做一切有意义的事情，他今晚是一定要把蛇眉铜鱼拍下来。拍卖东西要很多钱，可吴邪没钱，只得打电话四处借钱，可对方听说是借钱，就找各种理由拒绝。胖子见吴邪为了借钱的事愁眉不展，偷偷地把他在潘家园的房子给卖了帮吴邪。

                        拍卖会正式开始，第一件拍品是一个瓷瓶，拍卖师介绍这件瓷瓶的历史是出自圆明园。吴邪不想属于中国的文物落入外国人之手，他竞起价来。胖子提醒吴邪他们来的目的是拍下蛇眉铜鱼，像瓷瓶那样的文物有很多，他们根本拍不回来。可吴邪还是执意竞价，最终拍下这件瓷瓶。
                        吴邪和胖子来到亨得烈博物馆，一般书画的保存要防光防尘，尤其是紫外线对书画损伤特别大，这里的书画却直接被光线照射，十分不专业。吴邪准备找馆长说说看，胖子想要劝吴邪却没有劝住。吴邪找到馆长亨得烈，但他不知道这个亨得烈就是阿宁的老板裘德考。吴邪跟亨得烈讲了书画要如何保存，结果亨得烈却称那些是明清两朝的文物，作者名气不大，价值一般，对他来说就如同废纸一般。吴邪这才意识到亨得烈只是商人，跟他说那么多是一点意义也没有。

                        吴邪和胖子找到一旁的工作人员，打听有关拍卖会和博物馆里是否有蛇眉铜鱼的事，结果却被告知根本没有拍卖会的事，也没有见过蛇眉铜鱼。忽然，吴邪在人群中看见三叔的身影，三叔正匆匆地离去。吴邪连忙追了上去，却不见了三叔。吴邪肯定那个人就是三叔，他继续追了上去，果真看见三叔正跟一个老外在说话，还把手中的箱子给了老外，而这个老外刚刚就跟馆长亨得烈在一起。

                        吴邪和胖子准备上前找三叔，可转眼三叔就不见了，最后决定跟踪跟三叔见面的那个老外。吴邪心中存疑，这个老外拿着三叔的箱子要去什么地方，三叔和亨得烈又是什么关系，还有拍卖会又是怎么回事。吴邪感觉他的生活四处都是谜团，四面八方都是入口，走出去才发现每一条路都是死路。胖子劝吴邪要控制情绪，不要那么较真。可吴邪收到的短信和网页都在指引他们来到这里，并且认为能找到蛇眉铜鱼，可来到这里才发现什么都没有。

                        胖子早就说过这里面透露着阴谋诡计，是有人在设局。吴邪不相信三叔会对他设局，胖子并没有说是三叔，还开玩笑说很可能是阿宁的公司，因为在海底墓没有弄死吴邪，所以选择在国外。只是阿宁把三叔和考古队的事说得有鼻子有眼，还有解连环死的时候拿着蛇眉铜鱼，吴邪因此怀疑还有一个蛇眉铜鱼是在阿宁手上。
                        吴邪和胖子来到拍卖会上，只是他们没有邀请函，无法进入会场。好在有个女的见吴邪长得帅气，声称吴邪是她的同伴，成功将吴邪带进会场。到了会场的吴邪看到拍卖的手册，上面果真有蛇眉铜鱼。胖子假装是会场的服务员混了进来，他告诉吴邪在潘家园见过那个老外，是个中国通，对手工艺品特别感兴趣，到处拜师学艺，就不学好事。是个文物贩子，拍卖会里的那些东西就是他们在倒腾，胖子是恨不得把他们拉出去枪毙。

                        吴邪感慨没有信仰是建不成眼前这么大的金塔，就像一个信仰的支撑，才能守住小城，所以信仰很重要。胖子的信仰就是钞票，吴邪的信仰就是做一切有意义的事情，他今晚是一定要把蛇眉铜鱼拍下来。拍卖东西要很多钱，可吴邪没钱，只得打电话四处借钱，可对方听说是借钱，就找各种理由拒绝。胖子见吴邪为了借钱的事愁眉不展，偷偷地把他在潘家园的房子给卖了帮吴邪。

                        拍卖会正式开始，第一件拍品是一个瓷瓶，拍卖师介绍这件瓷瓶的历史是出自圆明园。吴邪不想属于中国的文物落入外国人之手，他竞起价来。胖子提醒吴邪他们来的目的是拍下蛇眉铜鱼，像瓷瓶那样的文物有很多，他们根本拍不回来。可吴邪还是执意竞价，最终拍下这件瓷瓶。
                    `
                div.style.cssText = 'height:500px; overflow:scroll; padding:10px;position:relative;';
                div.appendChild(start);div.appendChild(stop);
                start.innerHTML = 'start';
                stop.innerHTML = 'stop';
                start.style.cssText = 'width:50px;height:50px;position:fixed;top:50px;left:0px;background:#0f0;font-size:20px;';
                stop.style.cssText = 'width:50px;height:50px;position:fixed;top:100px;left:0px;background:#f00;font-size:20px;';
                start.onclick = function () {
                    if(key){
                        time = setInterval(function () {
                            div.scrollBy(0,1);
                        }, 20);
                        key = false;
                    }
                }

                stop.onclick = function () {
                    clearInterval(time);
                    key = true;
                }
            
                
            封装兼容性方法getStyle(ele,prop);
                function getStyle(ele,prop) {
                    
                    if(window.getComputedStyle) {
                        return window.getComputedStyle(ele,null)[prop];
                    }else{
                        return ele.currentStyle[prop];
                    }
                }

            
            运动方块
                var div = document.createElement('div'),
                    body = document.body,
                    speed = 1;
                body.appendChild(div);
                div.style.cssText = 'width:100px;height:100px; background:red;';
                var time = setInterval(function () {
                    speed += speed/10;
                    div.style.marginLeft = parseInt(getStyle(div,'marginLeft')) + speed + 'px';
                    
                    if(parseInt(getStyle(div,'marginLeft')) > 960) {
                        clearInterval(time);
                    }
                },10);
                console.log(parseInt(getStyle(div, 'marginLeft')));
                
                
                function getStyle(ele,prop) {
                    if(window.getComputedStyle){
                        return window.getComputedStyle(ele,null)[prop];
                    }else{
                        return ele.currentStyle[prop];
                    }
                }
                



    
    
    
    
    
    
    

    
    
    
    
    
    
    
贰贰.JS事件;

    document.onclick = function () {
        console.log('click handler');
    }
    
    var div = document.getElementsByClassName('click')[0],
        a = document.getElementsByTagName('a')[0];
    
    1.绑定事件处理函数
        1.ele.onxxx = function (event) {};兼容性好, 但是一个元素的同一个事件只能绑定一个处理程序, 基本等同于写在HTML上, this指向正常ele;

            句柄事件写法;
            div.onclick = function() {console.log('a')};
            
            
        2.obj.addEventListener('type', fn, false), IE9以下不兼容, 可以为一个事件,绑定多个处理程序; this指向正常obj;
            
            不管几个事件处理函数都会触发, (可以绑定多个事件处理函数);
            div.addEventListener('click',function () {console.log('aa')});
            div.addEventListener('click',function () {console.log('bb')});
            div.addEventListener('click',function () {console.log('cc')});
        
        3.obj.attachEvent('on' + type, fn), IE独有,一个事件同样可以绑定多个处理程序, this指向window;
        
            div.attachEvent('onclick', function () {});
            
    2.解除事件处理函数, (如果绑定了匿名函数, 则无法解除);

        1.ele.onclick = false/''/null;
            div.onclick = function () {alert('ss')};
            div.onclick = null;
            
        2.ele.removeEventListener(type, fn, false);
            div.addEventListener('click', test,false);
            div.removeEventListener('click',test,false);
            function test () {
                console.log('ss');
            }
            如果想要通过addEventListener对事件进行清除, 那么就必要在外面写一个函数作为引用, 清楚的时候在用这个引用;
            否则不用这个方法永远也清楚不掉了, 因为唯一的一个函数引用就是一个匿名函数了;
            
            
        3.ele.detachEvent('on' + type, fn);
            div.attachEvent('onclick', test);
            div.detachEvent('onclick', test);
            function test () {
                console.log('ss');
            }
            和addEventListener是一样的, 必须要有一个函数引用;
            
        
    3.事件处理模型, 事件冒泡,捕获; 出发顺序: 先捕获, 后冒泡;
        一个对象的一个事件类型, 只能存在一个事件模型, (假如一个click的事件类型, 如果结构嵌套, 那么他的事件模型要不是冒泡, 要么是捕获, 不可能同时存在冒泡和捕获);
        没有冒泡的事件有: focus, blur, change, submit, reset, select等;
        1.事件冒泡;
        结构上嵌套关系的元素, 会存在事件冒泡的功能, 即同一事件, 自子元素冒泡向父元素;(由内向外);
            
            
            var wrap = document.getElementsByClassName('wrap')[0],
                content = document.getElementsByClassName('content')[0],
                box = document.getElementsByClassName('box')[0];
            
            wrap.addEventListener('click', function() {
                console.log('red');
            }, false);
            content.addEventListener('click', function() {
                console.log('blue');
            }, false);
            box.addEventListener('click', function() {
                console.log('green');
            }, false);
            
        
        
        
        
        
        2.事件捕获;
        结构上嵌套关系的元素, 会存在事件捕获的功能, 即同一事件, 自父元素捕获之子元素(事件源元素); (由外向内);
        捕获事件只有在webkit内核上的浏览器上有, 其他内核的浏览器没有, 而触发捕获事件, 只需要改变addEventListener的第三个参数;
        第三个参数如果是false, 事件处理模型就是冒泡模式, 如果是true, 事件处理模型就是捕获模式;
            
            
            var wrap = document.getElementsByClassName('wrap')[0],
                content = document.getElementsByClassName('content')[0],
                box = document.getElementsByClassName('box')[0];
            
            wrap.addEventListener('click', function() {
                console.log('red');
            }, true);
            content.addEventListener('click', function() {
                console.log('blue');
            }, true);
            box.addEventListener('click', function() {
                console.log('green');
            }, true);

            
        3.触发顺序: 先捕获,后冒泡, 而并不是先写那个就先触发哪个;
            var wrap = document.getElementsByClassName('wrap')[0],
                content = document.getElementsByClassName('content')[0],
                box = document.getElementsByClassName('box')[0];
            
            wrap.addEventListener('click', function() {
                console.log('red');
            }, false);
            content.addEventListener('click', function() {
                console.log('blue');
            }, false);
            box.addEventListener('click', function() {
                console.log('green');
            }, false);
            
            wrap.addEventListener('click', function() {
                console.log('red');
            }, true);
            content.addEventListener('click', function() {
                console.log('blue');
            }, true);
            box.addEventListener('click', function() {
                console.log('green');
            }, true);


    
    4.取消冒泡;
    在每一个事件处理函数里面, 可以自定义一个形参, 这个形参就是系统定义一个事件对象;
    事件对象上的每一个属性, 都记载了这个对象发生时的一些关键数据和一些关键信息;
        event.stopPropagation();(IE9以下版本不兼容, W3C标准);
            div.onclick = function (e) {
                console.log(e);
                e.stopPropagation();
                这个事件对象上有一个 stopPropagation() 方法;
                一旦调用了这个方法, e.stopPropagation() 就会起到阻止冒泡的功能;
            }
    
        event.cancleBubble = true;(IE浏览器独有, 谷歌实现了这个方法);
            div.onclick = function (e) {
                console.log(e);
                e.cancelBubble = true;
                这个事件对象上有一个 stopPropagation() 方法;
                一旦调用了这个方法, e.stopPropagation() 就会起到阻止冒泡的功能;
            }
            
            

    5.阻止默认事件, (表单提交, a标签跳转, 右键菜单等等);

        href中JavaScript中的void(), 就相当于写返回值return, 如果是零就返回零, false就返回false;
        <a href='javascript:void(false)'></a>
        
        rturn false;(以对象属性的方式才会生效, 兼容性很好);
            document.oncontextmenu = function (e) {
                console.log('aaa');
                return false;
            }

            a.onclick = function(e) {
                e.stopPropagation();
                return false;
            }
            
        event.preventDefault();(W3C标准, IE9以下不兼容);
            document.oncontextmenu = function (e) {
                console.log('aaa');
                e.preventDefault();
            }

        event.returnValue = false;(兼容IE);
            document.oncontextmenu = function (e) {
                console.log('aaa');
                e.returnValue = false;
            }
        
        
    
    6.事件对象
        
        W3C标准的事件对象是事件处理函数中的第一个参数
            div.onclick = function (e) {
                console.log(e);
            }

        IE浏览器的事件对象封装在window.event中的;
            div.onclick = function () {
                console.log(window.event);
            }
        
        所以经常处理事件对象和事件源对象(target,srcElement)兼容问题的时候如下一步操作即可;
            div.onclick = function (e) {
                var event = e || window.event,
                    target = event.target || event.srcElement;
            }
            


    7.事件委托
        利用事件冒泡和事件源对象进行处理, 优点:
            1.性能, 不需要循环所有的元素一个个绑定事件;
            2.灵活, 当有新子元素时不需要重新绑定事件;
            
                var aul = document.getElementById('eventEntrust');
                var lis = aul.getElementsByTagName('li');
                
            循环遍历的方式, 把点击事件放在li子元素上循环每一个执行打印这个li的内容;
                for(var i = 0; i < lis.length; i++) {
                    lis[i].onclick = function () {
                        console.log(this.innerHTML);
                    }
                }
                
            事件委托方式, 把点击事件放到ul元素上, 通过事件源对象打印这个事件源的内容
                aul.onclick = function(e) {
                    var event = e || window.event,
                        target = event.target || event.srcElement;
                    console.log(target.innerHTML);
                }

                
            
    8.事件分类
        鼠标事件
        click, mousedown, mouseup, mousemove, contextmenu, mouseover, mouseout, mouseenter, mouseleave, mousewheel;
            
            var div = document.getElementsByClassName('eventType')[0];
            

            click == mousedown + mouseup; 执行顺序为(mousedown > mouseup > click);
                document.onclick = function () {console.log('click')};
                document.onmousedown = function () {console.log('mousedown')};
                document.onmouseup = function () {console.log('mouseup')};

            enter和over, leave和out功能一样, enter和leave是H5的新规范;
            enter不支持冒泡, 只有在鼠标指针穿过被选元素时, 才会触发mouseenter事件
            over支持冒泡, 不论鼠标指针穿过被选元素或其子元素, 都会触发mouseover事件
                div.onmouseover = function () {
                    div.style.background = 'yellow';
                }
                div.onmouseout = function () {
                    div.style.background = 'green';
                }
                div.onmouseenter = function () {
                    div.style.background = 'yellow';
                }
                div.onmouseleave = function () {
                    div.style.background = 'green';
                }

            区分鼠标左键, 右键;
            只有mousedown和mouseup可以通过e.button判断鼠标左右和滚轮事件, 其他事件的事件对象没有button属性;
            mousedown事件的滚轮事件是按下的时候,并不是滑动的时候, 滚轮滑动事件是onmousewheel;    
                
                div.onmousedown = function (e) {
                    console.log(e.button);
                }
                div.onmousewheel = function (e) {
                    console.log(e);
                }
            
            DOM3标准规定: click只能监听鼠标左键点击事件;
            移动端没有mouse事件, touchstart, touchmove, touchend;三个移动端事件;
            区分一个元素的事件拖拽还是点击, (点击是按下和抬起事件组合, 所以点击两个事件会有很微小的差别), 就通过这种生物行为来区分事件是怎样的;
                
                var firstTime = 0,
                    lastTime = 0,
                    key = false;
                
                document.onmousedown = function() {
                    console.log('mousedown');
                    firstTime = new Date().getTime()
                }

                document.onmouseup = function () {
                    lastTime = new Date().getTime()
                    console.log('mouseup');
                    if(lastTime - firstTime < 300 ) {
                        key = true;
                    }
                }
                
                document.onclick = function () {
                    if(key) {
                        console.log('click');
                        key = false;
                    }
                }

                    
                    
        键盘事件                
        keydown, keyup, keypress; 执行顺序为(keydown > keypress > keyup);
            
            document.onkeypress = function (e) {console.log('keypress')};
            document.onkeydown = function (e) {console.log('keydown')};
            document.onkeyup = function (e) {console.log('keyup')};
        
            
            keydown和keypress的区别; (String.fromCharCode() 输入unicode编码转换成unicode字符,unicode是包含ASCII码的);
                document.onkeypress = function (e) {
                    console.log(String.fromCharCode(e.keyCode))
                };
                document.onkeydown = function (e) {
                    console.log(String.fromCharCode(e.keyCode))
                };
                
                keydown可以响应任意键盘按键, keypress只可以响应字符类键盘按键(不包括ctrl, alt, shift, tab等功能键);
                keydown的keyCode, which是根据的键盘上的108键给出的键码, 所以字符按键(非功能键)一般用keypress监听;
                keypress的keyCode, which, charCode是根据当前按下键的字符在ASCII码中对应的编码,
                可以通过String.fromCharCode(e.charCode)转换相应的字符;
                
                
        文本类操作事件;
        input, focus, blur, change;
            var input = document.getElementsByTagName('input')[0];
            
            input(只要输入或者删除就会一直触发input);
                input.oninput = function (e) {
                    console.log(this.value);
                }

            change(只有在失去焦点时, 并且文本框中的内容改变了才会触发)
                input.onchange = function (e) {
                    console.log(this.value);
                }
            
            focus(当获取焦点的时候触发)
                input.onfocus = function () {
                    console.log(this.value);
                }

            blur(当试去焦点的时候触发);
                input.onblur = function () {
                    console.log(this.value);
                }
                
        窗体类操作事件(window上的事件);
        scroll, load
            var div = document.getElementsByClassName('scroll')[0];

            scroll;(当元素或者window滚动的时候触发);
                div.onscroll = function () {
                    console.log(div.scrollTop + ' ' + div.scrollLeft);
                }
                window.onscroll = function () {
                    console.log(window.pageXOffset + ' ' + window.pageYOffset);
                }
            
                
            load; (当渲染树全部加载完毕的时候执行, onload方法中的代码块最后被执行);
                window.onload = function () {
                    console.log(document.getElementsByClassName('load')[0]);
                }
                

    
    
    
    
    习题
        一组li当每一个点击的时候输出它们每一个当前index;
            var ul = document.getElementsByTagName('ul')[0],
                liCollection = document.getElementsByTagName('li');
            
            for(var i = 0; i < liCollection.length; i++) {
                (function (i) {
                    liCollection[i].addEventListener('click', function () {
                        console.log(i);
                    }, false);
                }(i))
            }
        封装一个addEvent方法, 给一个元素添加该事件类型的处理函数;
            function addEvent(ele, type, handle) {
                if(ele.addEventListener) {
                    ele.addEventListener(type, handle, false);
                }else if(ele.attachEvent){
                    ele.attachEvent('on' + type, function () {
                        handle.call(ele);
                    });
                }else{
                    ele['on' + type] = handle;
                }
            }
            
        封装取消冒泡函数stopBubble(event);
            function stopBubble(event) {
                if(event.stopPropagation) {
                    event.stopPropagation();
                }else{
                    event.cancelBubble = true;
                }
            }

        封装阻止默认事件的函数, cancelHandler;
            function cancelHandler (event) {
                if(event.preventDefault) {
                    event.preventDefault();
                }else{
                    event.returnValue = false;
                }
            }
            
        拖拽
            var div = document.getElementsByClassName('dragDrop')[0],
                disX,disY;
            div.onmousedown = function (e) {
                disX = e.pageX - parseInt(div.style.left);
                disY = e.pageY - parseInt(div.style.top);
                console.log(disX + '  ' + disY);
                document.onmousemove = function (e) {
                    var event = e || window.event;
                    
                    div.style.left = event.pageX - disX + 'px';
                    div.style.top = event.pageY - disY + 'px';
                }

                document.onmouseup = function (e) {
                    document.onmousemove = null;
                }
                
            }
            
        
        
        









        

    

    
    
    
    
    
    
    









贰叁.JSON,异步加载,时间线;

    JSON
        JSON是一种传输数据的格式, 早之前使用的是xml, 以对象为样板, 本质上就是对象,但用途有区别, 
        对象就是本地用户的, JSON是用来传输数据的;
        JSON中的键,规定必须加双引号, 用来分别JSON;
        前后端数据传输的时候是只能传输文本格式, 对象传过去不会识别; 
        所以就需要传输一个JSON格式的字符串; 字符串里面是一个JSON; 
        把一个JSON变成字符串的JSON, 手动加双引号并不可行;
        JOSN是一个静态类, 虽然是个函数,但不用构造它, 它身上就有很多方法;

        var obj = {
            'name' : 'leecs',
            'age' : 123,
        }
            
        JOSN.stringify(); 解析JSON为JSON串;
            var JSONStr = JSON.stringify(obj);
            console.log(JSONStr);
        JSON.parse(); 解析JOSN串为JSON;
            var JSONObj = JSON.parse(JSONStr);
            console.log(JSONObj);


        
        window.location.host,                            返回url 的主机部分
        window.location.hostname,                        返回服务器地址（域名）
        window.location.href,                            返回整个url字符串(在浏览器中就是完整的地址栏)
        window.location.pathname,                        返回path
        window.location.protocol,                        返回协议名
        window.location.port,                            url 的端口
        window.location.search,                          传参
        




    
    异步加载JS;
        JS加载的缺点: 加载工具类的JS文件时没必要阻塞文档, 过多的JS加载会影响, 页面效率,
        一旦网速不好, 整个网站将等待JS加载完毕, 不进行后续渲染等工作, 所以有些工具类JS包需要按需加载;
        JS异步加载三种方案:
            1.defer 异步加载, 但是要等到DOM文档全部解析完才会被执行. (IE9的方法, 也可以将代码写到内部);
                1.<script defer="defer" src="tools.js"><\/script>
                2.<script defer="defer">
                    Code...
                <\/script>
                
            2.async 异步加载, 加载完就执行, async只能加载外部脚本, 不能把JS写到script里面; (和defer功能相同, W3C的标准方法;)
                1.<script async="async" src="tools.js"><\/script>
                不能把Code写到 script标签之间, 如上defer可以这么写, async不可以;
                
            3.创建script, 插入到DOM中, 加载完毕后callback, (IE和W3C都兼容的两种方式, 同时实现了预加载, 异步加载, 按需加载等需要);
            
                function loadScript(url, callback) {
                    var script = document.createElement('script');
                    script.type = "text/javascript";
                    document.head.appendChild(script);
                    当把这个script标签插入到DOM中去的时候才会执行里面的脚本;
                    
                    如果script有readyState方法证明是IE下, 走IE方法, 否则走W3C标准方法;
                    if(script.readyState) {
                        IE中提供的事件当读取状态码改变的时候;
                        script.onreadystatechange = function () {
                            script标签上有个readyState的状态码成功的时候会返回complete或者loaded;
                            if(script.readyState == 'complete' || script.readyState == 'loaded') {
                                if(typeof(callback) == 'string') {
                                    eval(callback)();
                                }else{
                                    callback();
                                }
                            }
                        }
                    } else {
                        script.onload = function () {
                            if(typeof(callback) == 'string') {
                                eval(callback)();
                            }else{
                                callback();
                            }
                        }
                    }
                    script.src = url;
                    系统读取到script.src = "tools.js", 的时候就会下载tools.js文件;
                }
                
                这样调用的问题是会在当前代码块中找test这个变量,或是函数声明, 然而并没有, 结果是undefined, 所以就传了一个undefined进去;
                loadScript('./demoJS/demo1.js',test);
                
                传递一个匿名函数的引用进去, 执行的时候执行函数引用, 而引用中的代码还是test执行;
                loadScript('./demoJS/demo1.js',function () {test()});
                
                传递一个字符串,然后进行eval转化成代码;
                loadScript('./demoJS/demo1.js','test');

                
                
    JS加载时间线;
        1.创建一个Document, 开始解析WEB页面, 这个阶段document.readyState = 'loading';
        2.遇到link外部引入的CSS, 创建线程加载, 并继续解析文档;
        3.遇到script外部加载JS, 没有async,defer等异步属性, 同步加载, 并阻塞页面以后的加载, 等待当前JS加载完成, 然后继续解析文档;
        4.遇到script外部加载JS, 设有asyuc,defer时, 浏览器开启新的线程加载, 并且继续解析文档, 不阻塞文档解析, 对于async属性的脚本立即执行, defer脚本加载完成后执行;
            异步加载的JS和onload事件之后, 禁止使用(document.write()), 因为document.write会把之前的文档内容全部清空;
        5.遇到img等, 正常解析dom结构, 然后浏览器异步加载src, 并继续解析文档;
        6.当文档解析完成, document.readyState = 'interactive';
        7.文档解析完成后, 所有设置有defer脚本会按照顺序执行. (注意与async不同, async会同步执行);
        8.document对象触发DOMContentLoaded事件, 这也标志着程序执行从同步执行阶段, 转化为事件驱动阶段;
        9.当所有async脚本加载完成并执行后, img等加载完成后, document.readyState = 'complete'. window对象触发load事件;
        10.以上步骤走完, 文档以异步响应方式, 处理用户输入, 网络事件等;


    
    
        创建Document, 开始解析页面的时候;
        console.log(document.readyState);
        document.onreadystatechange = function () {
            文档解析完成和文档加载完成;
            console.log(document.readyState);
        }
        
        document.addEventListener('DOMContentLoaded', function () {
            console.log('文档解析完成之后');
        })
        DOMContentLoaded方法和jQuery的$(document).ready(function() {}) 是一样的, 在文档解析完执行, 而window.onload则是在加载完执行, 所以最好用jQuery的ready方法;
        DOMContentLoaded方法只有addEventListener来监听, on触发不了;
        于此同时监听DOM的方法还有以下几种, 称之为DOM变动事件: (DOM变动事件只能被addEventListener触发);
        document.addEventListener('DOMNodeInserted', function () {
            console.log('DOM子节点发生变化时触发');
        })
        document.addEventListener('DOMSubtreeModified', function () {
            console.log('DOM结构中发生任何变化时触发');
        })
        document.addEventListener('DOMNodeRemoved', function () {
            console.log('在节点从其父节点中被移除时触发');
        })
        document.addEventListener('DOMNodeInsertedIntoDocument', function () {
            console.log('在一个节点被直接插入文档中或者通过子树间接插入文档后触发,(DOMNodeInserted之后触发)');
        })
        document.addEventListener('DOMNodeRemovedFromDocument', function () {
            console.log('在一个节点被直接从文档中删除或通过子树间接从文档中移除之前触发,(DOMNodeRemoved之后触发)');
        })
        document.addEventListener('DOMAttrModified', function () {
            console.log('当属性被修改时触发');
        })
        document.addEventListener('DOMCharacterDataModified', function () {
            console.log('在文本节点的值发生变化的时候触发');
        })
        
    习题
        封装一个兼容的加载工具库的方法, 用来代替async, defer;
            function loadScript(url, callback) {
                var script = document.createElement('script');
                script.type = "text/javascript";
                document.head.appendChild(script);
                当把这个script标签插入到DOM中去的时候才会执行里面的脚本;
                
                如果script有readyState方法证明是IE下, 走IE方法, 否则走W3C标准方法;
                if(script.readyState) {
                    IE中提供的事件当读取状态码改变的时候;
                    script.onreadystatechange = function () {
                        script标签上有个readyState的状态码成功的时候会返回complete或者loaded;
                        if(script.readyState == 'complete' || script.readyState == 'loaded') {
                            if(typeof(callback) == 'string') {
                                eval(callback)();
                            }else{
                                callback();
                            }
                        }
                    }
                } else {
                    script.onload = function () {
                        if(typeof(callback) == 'string') {
                            eval(callback)();
                        }else{
                            callback();
                        }
                    }
                }
                script.src = url;
                系统读取到script.src = "tools.js", 的时候就会下载tools.js文件;
            }
            


    



