<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <div class="ReverseOrder">
        <i></i>
        <b></b>
        <span></span>
    </div>
    
    <div class="className" id="id"></div>

    <div class="removeAttribute" style="color:red;">fdsa</div>
    
    <!-- <div class="getAttribute">
        
    </div> -->

    <!-- <div class="setAttribute">
        
    </div> -->
    
    <!-- <div class="innerText">
        <span>234</span>
    </div> -->
    <!-- <div class="innerHTML">
        <span>123</span>
    </div> -->
    
    <!-- <div class="replaceChild">
        <span></span>
        <em></em>
        <i></i>
    </div> -->

    <!-- <div class="removeChild">
        <span></span>
        <em></em>
        <i></i>
    </div> -->
    
    
    <!-- <div class="insertBefore">
        <span></span>
    </div> -->
    
    <h4></h4>
    <h5></h5>
    <!-- 2.封装函数, 返回元素e的第n层祖先元素节点; -->
    <!-- <div><span><strong><em><i></i></em></strong></span></div> -->

    

    <!-- 4.编辑函数, 封装myChildren功能, 解决以前部分浏览器的兼容性问题; -->
    <!-- 5.自己封装hasChildren()方法, 不可用children属性; -->
    <div>
        <!-- this is comment -->
        adsf
        <div></div>
        <!-- this is comment -->
        <pre></pre>
        <a href=""></a>
    </div>

    
    <!-- 3.封装函数, 返回元素e的第n个兄弟元素节点; n为正, 返回后面的兄弟元素节点, n为负, 返回前面的, n为0, 返回自己; -->
    <!-- <div>
        <span></span>
        <input type="text">
        <iframe src="" frameborder="0"></iframe>
        <pre></pre>
        <h1></h1>
        <em></em>
        <i></i>
        <strong></strong>
        <b></b>
    </div> -->


    
    
    
    
    
    

    
    <script>

        // DOM结构树(表示的也是继承关系);
        // Node     1.Document              HTMLDocument
        //                                  XMLDocument
        //  
        //          2.CharacterData         1.Text
        //                                  2.Comment
        //          
        //          3.Element               HTMLElement             1.HTMLHeadElement
        //                                                          2.HTMLBodyElement
        //                                                          3.HTMLTitleElement
        //                                                          4.HTMLParagraphElement
        //                                                          5.HTMLInputElement
        //                                                          6.HTMLTableElement
        //                                                          7.  ...etc...
        //          4.Attr
        
        
            // 1.Document
                // Document并不是docuemnt直接的构造函数;
                // document的构造函数是HTMLDocument, 而并不是Document;
                
                    // document.__proto__  === HTMLDocument.prototype;
                    // HTMLDocument.prototype.__proto__ === Document.prototype;
                    // Document.prototype.__proto__ === Node.prototype;
                    // Node.prototype.__proto__ === EventTarget.prototype;
                    // EventTarget.prototype.__proto__ === Object.prototype;

            // 2.CharacterData
                // Text(文本节点的方法直接继承自Text.prototype)
                // Comment(文本节点的方法直接继承自Comment.prototype)
                

            // 3.Element
                // 每一个标签都是一个对象, 他们的构造函数分别是  (HTML{标签名}Element);
                // HTMLElement.prototype.test = 'test';
                // HTMLBodyElement.prototype.test = 'test';
                // var body = document.getElementsByTagName('body')[0];
                // var body = document.body;           // (document身上只有两个系统定义好的元素就是body和head);
                // var head = document.getElementsByTagName('head')[0];
                // var head = document.head;           // (document身上只有两个系统定义好的元素就是body和head);
                // console.log(body.test);
                // console.log(head.test);

        
        
        // DOM基本操作;
            // 1.getElementById方法定义在了Docuemnt.prototype上, 
                // 也就说明: Element 节点上不能用, 但是HTML和XML可以使用;
            // 2.getElementsByName方法定义在了HTMLDocument.prototype上,
                // 也就说明: 非html中的document不能使用 比如: XMLDocument, Element;
            // 3.getElementsByTagName方法定义在了Document上.prototype上和Element.prototype上;
                // 也就说明: Element和Document都可以使用这个方法;
                // div.getgetElementsByTagName('*')[0];
                // 不光document有这个方法, Element(div, p, span)标签元素身上也都有这些方法;
            // 4.HTMLDocument.prototype定义了一些常用的属性, body,head, 分别指代HTML文档中的<body></body>,<head></head>元素;
                // document是HTMLDocument.prototype构造出来的, 所以说: document有系统定义好的两个属性就是body和head;
                // console.log(document.body);
                // console.log(document.head);
            // 5.Document.prototype上定义了一个documentElement属性, 指代文档的根元素;
                // document.documentElement它指的就是<html></html>
                // console.log(document.documentElement);
            // 6.getElementsByClassName, querySelector, querySelectorAll; 在Document.prototype和Element.prototype类中均有定义;
                // 跟标签选择器一样都可以在标签元素上使用;
                // div.getElementsByClassName('class')[0];
                // div.querySelector('select');
                // div.querySelectorAll('select')[0];

            
        
        // DOM元素节点增删改查
            // 增(所有增加的标签只是JS引擎创建了, 但是并不是document中的, 所以我们要appendChild添加到某个页面中的元素中之后才可以出现在document中);
                // document.createElement();// 创建元素节点;
                    // var div = document.createElement('div');
                // document.createTextNode();// 创建文本节点;
                    // var text = document.createTextNode('leecs');
                // document.createComment();
                    // var comment = document.createComment('leecs is cool  leecs is cool  leecs is cool  leecs is cool  leecs is cool');
                // document.createDocumentFragment();
                    // 
            
            // 插
                // PARENTNODE.appendChild();
                    // 任何一个元素节点都有一个appendChild方法, 可以理解成push, 在一个元素集合(类数组)的最后一位插入一个元素;
                    // var div = document.createElement('div'),
                    //     span = document.createElement('span'),
                    //     text = document.createTextNode('文本节点'),
                    //     comment = document.createComment('leecs is cool  leecs is cool  leecs is cool  leecs is cool  leecs is cool');
                    // document.body.appendChild(div);
                    // div.appendChild(span);
                    // span.appendChild(text);
                    // div.appendChild(comment);
                    // // 如果span再次appendChild了注释节点, 那么就会将div.appendChild的注释节点覆盖掉;
                    // // 只创建了一次的节点(任何节点)只能被appendChild一次;
                    // span.appendChild(comment);

                    // // 而且appendChild还会让页面原有的结构改变, h4和h5兄弟节点通过appendChild变为父子节点;
                    // var h4 = document.getElementsByTagName('h4')[0];
                    // var h5 = document.getElementsByTagName('h5')[0];
                    // h4.appendChild(h5);
                // PARENTNODE.insertBefore(a,b);
                    // 父元素.insertBefore(插入元素, 在哪个元素之前);
                    // var div = document.getElementsByClassName('insertBefore')[0],
                    //     span = div.getElementsByTagName('span')[0];
                    //     strong = document.createElement('strong');
                    // strong.appendChild(document.createTextNode('strong'));
                    // div.insertBefore(strong, span);

                    
            // 删
                // parent.removeChild();
                    // 父级removeChild返回被删除的元素, 相当于剪切的功能;
                    // var div = document.getElementsByClassName('removeChild')[0];
                    // div.removeChild(document.querySelector('.removeChild span'));
                // child.remove();
                    // 没有返回值, 返回undefined, 相当于真正的销毁了;
                    // var div = document.getElementsByClassName('removeChild')[0];
                    // div.remove();
                    
            // 替换
                // parent.replaceChild(new, origin);
                // var div = document.getElementsByClassName('replaceChild')[0],
                //     span = document.querySelector('.replaceChild span');
                //     strong = document.createElement('strong');
                // div.replaceChild(strong,span);
                // 返回被替换后的元素;


        
        // DOM元素节点属性/方法;

            // innerHTML    (获取/写入 一个元素的内容  并且写入标签会当作HTML解析);
                // var div = document.getElementsByClassName('innerHTML')[0];
                // console.log(div.innerHTML);
                // div.innerHTML += '<span style="background:red;color:yellow;">我爱你</span>';
                // console.log(div.innerHTML);
            
            // innerText    (获取/写入  一个元素的文本内容   但是写入的标签会当作纯文本解析);火狐不好使;
            // textContent  (获取/写入  一个元素的文本内容   但是写入的标签会当作纯文本解析);老版本IE不好使
                // var div = document.getElementsByClassName('innerText')[0];
                // div.innerText += '<span>sss</span>'
                // div.textContent += '<span>sss</span>'
                
            // setAttribute(属性名, 属性值);  (给一个元素节点设值属性);
                // var div = document.getElementsByClassName('setAttribute')[0];
                // div.setAttribute('id', 'setAttribute');
            
            // getAttribute(属性名);
                // var div = document.getElementsByClassName('getAttribute')[0];
                // console.log(div.getAttribute('class'));
            
            
            // removeAttribute(属性名);
                // var div = document.getElementsByClassName('removeAttribute')[0];
                // console.log(div.removeAttribute('style'));
                
            
            
            // className,id     (查看/更改  元素节点的类名和id);
                // var div = document.getElementById('id');
                // console.log(div.className);
                // console.log(div.id);
                // div.className = '改过了class';
                // div.id = '改过了ID';
                // console.log(div.className);
                // console.log(div.id);
                
            
                
        













        // 习题
            // 1.遍历元素节点树,(在原型链上编程);
                
            // 2.封装函数, 返回元素e的第n层祖先元素节点;
                // var i = document.getElementsByTagName('i')[0];
                // function returnParent(ele,n){
                    
                //     // 判断条件的意思是如果ele是null的时候就为false直接返回ele;
                //     while(ele && n) {
                //         ele = ele.parentElement;
                //         n--;
                //     }
                //     return ele;
                // }
                
            // 3.封装函数, 返回元素e的第n个兄弟元素节点; n为正, 返回后面的兄弟元素节点, n为负, 返回前面的, n为0, 返回自己;
                // var h1 = document.getElementsByTagName('h1')[0];
                // function returnSibling(ele, n) {
                //     while(ele && n){
                //         if(n > 0) {
                //             // 兼容IE9--
                //             if(ele.nextElementSibling) {
                //                 ele = ele.nextElementSibling;
                //             } else {
                //                 for(ele = ele.nextSibling; ele && ele.nodeType != 1; ele = ele.nextSibling) ;
                //             }
                //             n--;
                //         } else {
                //             if(ele.previousElementSibling) {
                //                 ele = ele.previousElementSibling;
                //             } else {
                //                 for(ele = ele.previousSibling; ele && ele.nodeType != 1; ele = ele.previousSibling) ;
                //             }
                //             n++;
                //         }
                //     }
                //     return ele;
                // }
            
            // 4.编辑函数, 封装myChildren功能, 解决以前部分浏览器的兼容性问题, 不可以使用children属性;
                // var div = document.getElementsByTagName('div')[0];
                // Element.prototype.myChildren = function () {
                //     var arr = [];
                //     for(var i = 0; i < this.childNodes.length; i++) {
                //         if(this.childNodes[i].nodeType == 1) {
                //             arr.push(this.childNodes[i]);
                //         }
                //     }
                //     return arr
                // }

            // 5.自己封装hasChildren()方法, 不可用children属性;
                // var div = document.getElementsByTagName('div')[0];
                // Element.prototype.hasChildren = function () {
                //     for(var i = 0; i < this.childNodes.length; i++) {
                //         if(this.childNodes[i].nodeType == 1) {
                //             return true;
                //         }
                //     }
                //     return false;
                // }

            // 6.创建一个div, 给他的子元素设置一个this-name属性;
                // var div = document.createElement('div'),
                //     span = document.createElement('span'),
                //     strong = document.createElement('strong'),
                //     address = document.createElement('address');
                // document.body.appendChild(div);
                // div.appendChild(span);
                // div.appendChild(strong);
                // div.appendChild(address);

                // for(var i = 0; i < div.children.length; i++) {
                //     div.children[i].setAttribute('this-name', div.children[i].nodeName);
                //     div.children[i].innerHTML += div.children[i].tagName;
                //     div.children[i].innerHTML += div.children[i].nodeName;
                // }

            // 7.封装函数insertAfter(), 功能类似于insertBefore(), (在Element.prototype上编程);
                // var div = document.createElement('div'),
                //     pre = document.createElement('pre'),
                //     span = document.createElement('span'),
                //     strong = document.createElement('strong');
                // document.body.insertBefore(div, document.getElementsByClassName('className')[0]);
                // div.appendChild(pre);
                // div.appendChild(strong);
                // div.className = 'inserAfter';
                    
                // Element.prototype.insertAfter = function (insertEle, targetEle) {
                //     var nextEle = targetEle.nextElementSibling;
                //     if (nextEle == null) {
                //         this.appendChild(insertEle);
                //     } else {
                //         this.insertBefore(insertEle, nextEle);
                //     }
                // }

                // div.insertAfter(span, pre);
                
            
                
            // 8.将目标节点内部的节点顺序逆序;
                    
            

    </script>
</body>
</html>