<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 节流应用 -->
    <div id="show">0</div>
    <button id="btn">按钮</button>
    <br>
    <!-- 防抖应用 -->
    <input type="text" id="inp">
    <script type="text/javascript">

        // 节流&防抖;
            // 在开发过程中, 用户会频繁的触发事件执行, 对于DOM操作, 资源加载等消耗性能的处理, 很可能会导致页面卡顿, 甚至浏览器的崩溃;
            // 函数节流和防抖就是用来解决这类的事情的;


            // 节流就是预定一个函数,只有在大于等于执行周期时才会执行, 周期内调用不执行, 就好比水滴积攒到一定重量才会落下一样;
            // 应用场景: 抢购疯狂点击, 也买滚动, 窗口调整等...

                // // 应用实例
                //     var oDiv = document.getElementById('show');
                //     var oBtn = document.getElementById('btn');
                //     // 节流函数(事件函数, 等待时间);
                //     function throttle(handler, wait) {
                //         var prevTime = 0;
                //         // 返回的这个函数是作为click的事件处理函数(this指向oBtn), 所以事件对象要传到这里;
                //         return function (e) {
                //             // arguments的第零位就是事件对象, 也可handler.apply(this, arguments) 把arguments整个传入;
                //             // 获取当前时间戳;
                //             var nowTime = new Date().getTime();
                //             // 如果现在的时间减去上一次执行的时间大于指定时间时, 就执行这个点击事件; 如果小于就意为在规定的时间内连续的出发了点击事件;
                //             if(nowTime - prevTime > wait) {
                //                 // 我们要拿到这件对象e, 就涉及到this问题, handler其实就是buy这个事件函数
                //                 // 但是这样执行这个事件函数this还是buy的也就是说没有任何对象调用它; 他的this还是window;
                //                 // 所以我们要用到现在的this也就是真正的调用者而不是window; 所以不能handler()来执行;
                //                 handler.apply(this, arguments);
                //                 prevTime = nowTime;
                //             }
                //         }
                //     }
                    
                    
                //     function buy(e) {
                //         // 如下, 疯狂的点击触发buy事件就会累加, 如果说是购物按钮的话, 点击一次就会请求一次后台, 那么用户疯狂点击的时候, 无数次的请求后台;
                //         // 就会导致,服务器的崩溃或者浏览器的崩溃, 所以接下来使用节流, 来实现两秒或者三秒内点击按钮只触发一次;
                //         oDiv.innerHTML = parseInt(oDiv.innerHTML) + 1;

                //         // 如果在throttle中不写 handler.apply(this, arguments), 而是handler()来执行的话, 
                //         // 那么一下打印的结果就将会是windows和undefined;
                //         console.log(this);
                //         console.log(e);
                //     }

                //     // 这里当点击时执行节流函数;
                //     // 在一秒钟内不管点击多少次, 只触发一次;
                //     oBtn.onclick = throttle(buy, 3000);
                


                
                
                
                
                
                
                
                
            // 函数防抖就是在函数需要频繁触发情况时, 只有足够的空闲时间, 才能触发一次, 好比如公交车司机等乘客都上车之后在出发一样;
            // 应用场景: 实时搜索(keyup),拖拽(mousemove);
            // 比如百度实时搜索, 当把最后一个字输完之后, 在进行页面的更新;
                
                // // 应用实例;
                // var oInp = document.getElementById('inp');

                // // 防抖函数(事件函数, 延迟时间);
                // function debounce(handler, delay){
                //     var timer = null;
                //     return function (e) {
                //         var self = this,args = arguments;
                //         clearTimeout(timer);
                //         timer = setTimeout(function() {
                //             handler.apply(self, args);
                //         },delay);
                //     }
                // }
                
                // function ajax(e) {
                //     console.log(this.value);
                // }
                
                // // 当每次输入一个字符时, 都会出发这个函数, 防抖的需求就是当输入到最后一个字时, 才出发这个事件;
                // oInp.oninput = debounce(ajax, 2000);
            

    
    </script>
</body>
</html>